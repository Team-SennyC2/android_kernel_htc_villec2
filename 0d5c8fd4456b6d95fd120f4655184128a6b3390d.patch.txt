From 0d5c8fd4456b6d95fd120f4655184128a6b3390d Mon Sep 17 00:00:00 2001
From: bilalliberty <bilal_liberty@live.com>
Date: Sun, 24 Nov 2013 21:06:58 +0300
Subject: [PATCH] msmfb: M7 4.2.2 kernel

---
 drivers/video/msm/mdp.c                      |  97 +++-
 drivers/video/msm/mdp.h                      |   1 +
 drivers/video/msm/mdp4.h                     |  40 +-
 drivers/video/msm/mdp4_overlay.c             | 258 ++++++++--
 drivers/video/msm/mdp4_overlay_dsi_cmd.c     |  60 +--
 drivers/video/msm/mdp4_overlay_dsi_video.c   |  71 ++-
 drivers/video/msm/mdp4_overlay_dtv.c         |  61 +--
 drivers/video/msm/mdp4_overlay_lcdc.c        |  17 +-
 drivers/video/msm/mdp4_overlay_writeback.c   | 675 +++++++++++++++++++++++++++
 drivers/video/msm/mdp4_util.c                |  14 +-
 drivers/video/msm/mdp4_wfd_writeback.c       |  96 ++++
 drivers/video/msm/mdp4_wfd_writeback_panel.c |  84 ++++
 drivers/video/msm/mdp4_wfd_writeback_util.h  |  28 ++
 drivers/video/msm/mdp_dma.c                  |   3 +
 drivers/video/msm/mdp_dma_s.c                |   3 +
 drivers/video/msm/mipi_dsi.c                 |  52 ++-
 drivers/video/msm/mipi_dsi.h                 |   7 +-
 drivers/video/msm/mipi_dsi_host.c            |  84 +++-
 drivers/video/msm/msm_fb.c                   | 645 ++++++++++++++++++++++++-
 drivers/video/msm/msm_fb.h                   |  48 +-
 drivers/video/msm/msm_fb_panel.h             |  23 +
 include/linux/msm_mdp.h                      |  60 ++-
 23 files changed, 2262 insertions(+), 210 deletions(-)
 create mode 100644 drivers/video/msm/mdp4_overlay_writeback.c
 create mode 100644 drivers/video/msm/mdp4_wfd_writeback.c
 create mode 100644 drivers/video/msm/mdp4_wfd_writeback_panel.c
 create mode 100644 drivers/video/msm/mdp4_wfd_writeback_util.h

diff --git a/drivers/video/msm/mdp.c b/drivers/video/msm/mdp.c
index 4eef7e2..6e8369b 100644
--- a/drivers/video/msm/mdp.c
+++ b/drivers/video/msm/mdp.c
@@ -25,6 +25,7 @@
 #include <linux/hrtimer.h>
 #include <linux/clk.h>
 #include <mach/hardware.h>
+#include <mach/debug_display.h>
 #include <linux/io.h>
 #include <linux/debugfs.h>
 #include <linux/delay.h>
@@ -51,6 +52,7 @@
 int mdp_rev;
 int mdp_iommu_split_domain;
 u32 mdp_max_clk = 200000000;
+u32 mdp_min_clk = 0;
 u32 mdp_ov0_blt_ctl = MDP4_BLT_SWITCH_TG_OFF;
 
 static struct platform_device *mdp_init_pdev;
@@ -604,7 +606,7 @@ void __mdp_histogram_reset(struct mdp_hist_mgmt *mgmt)
 
 static int mdp_hist_init_mgmt(struct mdp_hist_mgmt *mgmt, uint32_t block)
 {
-	uint32_t bins, extra, index, intr =0, term = 0;
+	uint32_t bins, extra, index, intr = 0, term = 0;
 	init_completion(&mgmt->mdp_hist_comp);
 	mutex_init(&mgmt->mdp_hist_mutex);
 	mutex_init(&mgmt->mdp_do_hist_mutex);
@@ -909,7 +911,7 @@ int _mdp_histogram_ctrl(boolean en, struct mdp_hist_mgmt *mgmt)
 		else
 			ret = mdp_histogram_disable(mgmt);
 	} else {
-		pr_warn("%s start = false\n", __func__);
+		pr_debug("%s start = false\n", __func__);
 	}
 	mutex_unlock(&mgmt->mdp_hist_mutex);
 
@@ -1205,7 +1207,7 @@ static void mdp_hist_read_work(struct work_struct *data)
 static int _mdp_copy_hist_data(struct mdp_histogram_data *hist,
 						struct mdp_hist_mgmt *mgmt)
 {
-	int ret;
+	int ret = 0;
 
 	if (hist->c0) {
 		ret = copy_to_user(hist->c0, mgmt->c0,
@@ -1337,6 +1339,65 @@ int mdp_ppp_pipe_wait(void)
 	return ret;
 }
 
+#define DEFAULT_FRAME_RATE        60
+
+u32 mdp_get_panel_framerate(struct msm_fb_data_type *mfd)
+{
+        u32 frame_rate = 0, pixel_rate = 0, total_pixel;
+        struct msm_panel_info *panel_info = &mfd->panel_info;
+
+        if ((panel_info->type == MIPI_VIDEO_PANEL ||
+             panel_info->type == MIPI_CMD_PANEL) &&
+            panel_info->mipi.frame_rate)
+                frame_rate = panel_info->mipi.frame_rate;
+
+        if (mfd->dest == DISPLAY_LCD) {
+                if (panel_info->type == MDDI_PANEL && panel_info->mddi.is_type1)
+                        frame_rate = panel_info->lcd.refx100 / (100 * 2);
+                else if (panel_info->type != MIPI_CMD_PANEL)
+                        frame_rate = panel_info->lcd.refx100 / 100;
+        }
+        pr_debug("%s type=%d frame_rate=%d\n", __func__,
+                 panel_info->type, frame_rate);
+
+        if (frame_rate)
+                return frame_rate;
+
+        pixel_rate =
+                (panel_info->type == MIPI_CMD_PANEL ||
+                 panel_info->type == MIPI_VIDEO_PANEL) ?
+                panel_info->mipi.dsi_pclk_rate :
+                panel_info->clk_rate;
+
+        if (!pixel_rate)
+                pr_warn("%s pixel rate is zero\n", __func__);
+
+        total_pixel =
+                (panel_info->lcdc.h_back_porch +
+                 panel_info->lcdc.h_front_porch +
+                 panel_info->lcdc.h_pulse_width +
+                 panel_info->xres) *
+                (panel_info->lcdc.v_back_porch +
+                 panel_info->lcdc.v_front_porch +
+                 panel_info->lcdc.v_pulse_width +
+                 panel_info->yres);
+
+        if (total_pixel)
+                frame_rate = pixel_rate / total_pixel;
+        else
+                pr_warn("%s total pixels are zero\n", __func__);
+
+        if (frame_rate == 0) {
+                frame_rate = DEFAULT_FRAME_RATE;
+                pr_warn("%s frame rate=%d is default\n", __func__, frame_rate);
+        }
+        pr_debug("%s frame rate=%d total_pixel=%d, pixel_rate=%d\n", __func__,
+                frame_rate, total_pixel, pixel_rate);
+
+        return frame_rate;
+}
+
+
 static DEFINE_SPINLOCK(mdp_lock);
 static int mdp_irq_mask;
 static int mdp_irq_enabled;
@@ -2047,6 +2108,7 @@ static int mdp_on(struct platform_device *pdev)
 	if (mfd->panel.type == MIPI_CMD_PANEL)
 		mdp4_dsi_cmd_vsync_ctrl(NULL,1);
 #endif
+
 	return ret;
 }
 
@@ -2227,6 +2289,10 @@ static int mdp_irq_clk_setup(struct platform_device *pdev,
 		clk_set_rate(mdp_lut_clk, mdp_clk_rate);
 	mutex_unlock(&mdp_clk_lock);
 
+	if (mdp_pdata && mdp_pdata->mdp_min_clk) {
+		mdp_min_clk = mdp_pdata->mdp_min_clk;
+		PR_DISP_INFO("%s: get mdp min clk = %d\n", __func__, mdp_min_clk);
+	}
 
 	MSM_FB_DEBUG("mdp_clk: mdp_clk=%d\n", (int)clk_get_rate(mdp_clk));
 #endif
@@ -2359,6 +2425,7 @@ static int mdp_probe(struct platform_device *pdev)
 	
 	mfd->pdev = msm_fb_dev;
 	mfd->mdp_rev = mdp_rev;
+	mfd->vsync_init = NULL;
 
 	if (mdp_pdata) {
 		if (mdp_pdata->cont_splash_enabled && mfd->panel.type != MIPI_CMD_PANEL) {
@@ -2709,6 +2776,30 @@ static int mdp_probe(struct platform_device *pdev)
 
 	pdev_list[pdev_list_cnt++] = pdev;
 	mdp4_extn_disp = 0;
+
+	if (mfd->vsync_init != NULL) {
+		mfd->vsync_init(0);
+
+		if (!mfd->vsync_sysfs_created) {
+			mfd->dev_attr.attr.name = "vsync_event";
+			mfd->dev_attr.attr.mode = S_IRUGO;
+			mfd->dev_attr.show = mfd->vsync_show;
+			sysfs_attr_init(&mfd->dev_attr.attr);
+
+			rc = sysfs_create_file(&mfd->fbi->dev->kobj,
+							&mfd->dev_attr.attr);
+			if (rc) {
+				pr_err("%s: sysfs creation failed, ret=%d\n",
+					__func__, rc);
+				return rc;
+			}
+
+			kobject_uevent(&mfd->fbi->dev->kobj, KOBJ_ADD);
+			pr_debug("%s: kobject_uevent(KOBJ_ADD)\n", __func__);
+			mfd->vsync_sysfs_created = 1;
+		}
+	}
+
 	return 0;
 
       mdp_probe_err:
diff --git a/drivers/video/msm/mdp.h b/drivers/video/msm/mdp.h
index 93fce9d..6cef732 100644
--- a/drivers/video/msm/mdp.h
+++ b/drivers/video/msm/mdp.h
@@ -833,6 +833,7 @@ int mdp_ppp_v4l2_overlay_play(struct fb_info *info,
 	unsigned long srcp0_addr, unsigned long srcp0_size,
 	unsigned long srcp1_addr, unsigned long srcp1_size);
 
+u32 mdp_get_panel_framerate(struct msm_fb_data_type *mfd);
 #ifdef CONFIG_FB_MSM_DTV
 void mdp_vid_quant_set(void);
 #else
diff --git a/drivers/video/msm/mdp4.h b/drivers/video/msm/mdp4.h
index 7fdbb18..51b95ac 100644
--- a/drivers/video/msm/mdp4.h
+++ b/drivers/video/msm/mdp4.h
@@ -28,6 +28,7 @@
 extern char *mmss_cc_base;	
 extern spinlock_t dsi_clk_lock;
 extern u32 mdp_max_clk;
+extern u32 mdp_min_clk;
 
 #define MDP4_OVERLAYPROC0_BASE	0x10000
 #define MDP4_OVERLAYPROC1_BASE	0x18000
@@ -339,7 +340,7 @@ struct mdp4_overlay_pipe {
 	uint32 ov_cnt;
 	uint32 dmap_cnt;
 	uint32 dmae_cnt;
-	uint32 blt_end;
+	uint32 blt_end;	
 	uint32 blt_ov_koff;
 	uint32 blt_ov_done;
 	uint32 blt_dmap_koff;
@@ -433,6 +434,15 @@ void mdp_pipe_ctrl(MDP_BLOCK_TYPE block, MDP_BLOCK_POWER_STATE state,
 void mdp4_dma_p_cfg(void);
 unsigned is_mdp4_hw_reset(void);
 void mdp4_overlay_cfg_init(void);
+void mdp4_overlay_free_base_pipe(struct msm_fb_data_type *mfd);
+void mdp4_lcdc_vsync_ctrl(struct fb_info *info, int enable);
+void mdp4_overlay0_done_dsi_video(int cndx);
+void mdp4_overlay0_done_dsi_cmd(int cndx);
+void mdp4_primary_rdptr(void);
+void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd);
+int mdp4_overlay_commit(struct fb_info *info);
+int mdp4_dsi_video_pipe_commit(int cndx, int wait);
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait);
 void mdp4_hw_init(void);
 void mdp4_isr_read(int);
 void mdp4_clear_lcdc(void);
@@ -536,16 +546,19 @@ int mdp4_overlay_dtv_unset(struct msm_fb_data_type *mfd,
 void mdp4_overlay0_done_dsi_cmd(int cndx);
 void mdp4_primary_rdptr(void);
 void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd);
-int mdp4_overlay_commit(struct fb_info *info, int mixer);
-int mdp4_dsi_video_pipe_commit(void);
-int mdp4_dsi_cmd_pipe_commit(void);
+int mdp4_lcdc_pipe_commit(int cndx, int wait);
+int mdp4_dtv_pipe_commit(int cndx, int wait);
 int mdp4_dsi_cmd_update_cnt(int cndx);
-int mdp4_lcdc_pipe_commit(void);
-int mdp4_dtv_pipe_commit(void);
 void mdp4_dsi_rdptr_init(int cndx);
 void mdp4_dsi_vsync_init(int cndx);
 void mdp4_lcdc_vsync_init(int cndx);
 void mdp4_dtv_vsync_init(int cndx);
+ssize_t mdp4_dsi_cmd_show_event(struct device *dev,
+	struct device_attribute *attr, char *buf);
+ssize_t mdp4_dsi_video_show_event(struct device *dev,
+	struct device_attribute *attr, char *buf);
+ssize_t mdp4_dtv_show_event(struct device *dev,
+	struct device_attribute *attr, char *buf);
 void mdp4_overlay_dsi_state_set(int state);
 int mdp4_overlay_dsi_state_get(void);
 void mdp4_overlay_rgb_setup(struct mdp4_overlay_pipe *pipe);
@@ -569,6 +582,7 @@ int mdp4_overlay_dtv_unset(struct msm_fb_data_type *mfd,
 int mdp4_overlay_play_wait(struct fb_info *info,
 	struct msmfb_overlay_data *req);
 int mdp4_overlay_play(struct fb_info *info, struct msmfb_overlay_data *req);
+int mdp4_overlay_commit(struct fb_info *info);
 struct mdp4_overlay_pipe *mdp4_overlay_pipe_alloc(int ptype, int mixer);
 void mdp4_overlay_dma_commit(int mixer);
 void mdp4_overlay_vsync_commit(struct mdp4_overlay_pipe *pipe);
@@ -581,7 +595,7 @@ int mdp4_overlay_play_wait(struct fb_info *info,
 void mdp4_overlay_dmap_xy(struct mdp4_overlay_pipe *pipe);
 void mdp4_overlay_dmae_cfg(struct msm_fb_data_type *mfd, int atv);
 void mdp4_overlay_dmae_xy(struct mdp4_overlay_pipe *pipe);
-int mdp4_overlay_pipe_staged(int mixer);
+int mdp4_overlay_pipe_staged(struct mdp4_overlay_pipe *pipe);
 void mdp4_lcdc_primary_vsyn(void);
 void mdp4_overlay0_done_lcdc(int cndx);
 void mdp4_overlay0_done_mddi(struct mdp_dma_data *dma);
@@ -757,6 +771,8 @@ void mdp4_mddi_kickoff_video(struct msm_fb_data_type *mfd,
 void mdp4_dsi_video_wait4vsync(int cndx, long long *vtime);
 void mdp4_dsi_cmd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_dsi_video_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
+int mdp4_dsi_video_pipe_commit(int cndx, int wait);
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait);
 void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info, int enable);
 void mdp4_dsi_video_vsync_ctrl(struct fb_info *info, int enable);
 #ifdef CONFIG_FB_MSM_MDP303
@@ -806,6 +822,14 @@ static inline void mdp4_dsi_video_pipe_queue(int cndx,
 			struct mdp4_overlay_pipe *pipe)
 {
 }
+static inline int mdp4_dsi_video_pipe_commit(int cndx, int wait)
+{
+	return 0;
+}
+static inline int mdp4_dsi_cmd_pipe_commit(int cndx, int wait)
+{
+	return 0;
+}
 static inline void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info,
 					int enable)
 {
@@ -913,4 +937,6 @@ int mdp4_overlay_mdp_pipe_req(struct mdp4_overlay_pipe *pipe,
 int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
 			      struct mdp4_overlay_pipe *plist);
 void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd, int flag);
+
+void mdp4_overlay_mdp_perf_dump(void);
 #endif 
diff --git a/drivers/video/msm/mdp4_overlay.c b/drivers/video/msm/mdp4_overlay.c
index cd8e785..6f0d219 100644
--- a/drivers/video/msm/mdp4_overlay.c
+++ b/drivers/video/msm/mdp4_overlay.c
@@ -42,6 +42,7 @@
 #include "mdp4.h"
 
 #define VERSION_KEY_MASK	0xFFFFFF00
+const int mdp44_max_clk = 266667000;
 
 struct mdp4_overlay_ctrl {
 	struct mdp4_overlay_pipe plist[OVERLAY_PIPE_MAX];
@@ -121,7 +122,6 @@ struct mdp4_overlay_perf perf_current = {
 
 static struct ion_client *display_iclient;
 
-
 void mdp4_overlay_iommu_unmap_freelist(int mixer)
 {
 	int i;
@@ -686,8 +686,14 @@ void mdp4_overlay_rgb_setup(struct mdp4_overlay_pipe *pipe)
 		op_mode &= ~(MDP4_OP_FLIP_LR + MDP4_OP_SCALEX_EN);
 		op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
 		outpdw(rgb_base + 0x0058, op_mode);
-	} else
+	} else {
+		if (pipe->op_mode & MDP4_OP_FLIP_LR && mdp_rev >= MDP_REV_42) {
+			
+			
+			pipe->op_mode |= 0x01;
+		}
 		outpdw(rgb_base + 0x0058, pipe->op_mode);
+	}
 	outpdw(rgb_base + 0x005c, pipe->phasex_step);
 	outpdw(rgb_base + 0x0060, pipe->phasey_step);
 
@@ -1478,36 +1484,19 @@ void mdp4_overlayproc_cfg(struct mdp4_overlay_pipe *pipe)
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
 
-int mdp4_overlay_pipe_staged(int mixer)
+int mdp4_overlay_pipe_staged(struct mdp4_overlay_pipe *pipe)
 {
-	uint32 data, mask, i, off;
-	int p1, p2;
+	uint32 data, mask;
+	int mixer;
 
-	if (mixer == MDP4_MIXER2)
-		off = 0x100F0;
-	else
-		off = 0x10100;
+	mixer = pipe->mixer_num;
+	data = ctrl->mixer_cfg[mixer];
 
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	data = inpdw(MDP_BASE + off);
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-	p1 = 0;
-	p2 = 0;
-	for (i = 0; i < 8; i++) {
-		mask = data & 0x0f;
-		if (mask) {
-			if (mask <= 4)
-				p1++;
-			else
-				p2++;
-		}
-		data >>= 4;
-	}
+	mask = 0x0f;
+	mask <<= (4 * pipe->pipe_num);
+	data &= mask;
 
-	if (mixer)
-		return p2;
-	else
-		return p1;
+	return data;
 }
 
 int mdp4_mixer_info(int mixer_num, struct mdp_mixer_info *info)
@@ -1516,7 +1505,7 @@ int mdp4_mixer_info(int mixer_num, struct mdp_mixer_info *info)
 	int ndx, cnt;
 	struct mdp4_overlay_pipe *pipe;
 
-	if (mixer_num > MDP4_MIXER_MAX)
+	if (mixer_num >= MDP4_MIXER_MAX)
 		return -ENODEV;
 
 	cnt = 0;
@@ -1648,6 +1637,12 @@ void mdp4_overlay_borderfill_stage_up(struct mdp4_overlay_pipe *pipe)
 
 	bspipe = ctrl->stage[mixer][MDP4_MIXER_STAGE_BASE];
 
+	if(bspipe == NULL) {
+		pr_err("%s: no base layer at mixer=%d\n",
+			__func__, mixer);
+		return;
+	}
+
 	bspipe = mdp4_overlay_ndx2pipe(bspipe->pipe_ndx);
 
 	
@@ -1690,6 +1685,7 @@ void mdp4_overlay_borderfill_stage_down(struct mdp4_overlay_pipe *pipe)
 	struct mdp4_overlay_pipe *bspipe;
 	int ptype, pnum, pndx, mixer;
 	int format, alpha_enable, alpha;
+	struct mdp4_iommu_pipe_info iom;
 
 	if (pipe->pipe_type != OVERLAY_TYPE_BF)
 		return;
@@ -1704,6 +1700,7 @@ void mdp4_overlay_borderfill_stage_down(struct mdp4_overlay_pipe *pipe)
 		return;
 	}
 
+	iom = bspipe->iommu;
 	ptype = bspipe->pipe_type;
 	pnum = bspipe->pipe_num;
 	pndx = bspipe->pipe_ndx;
@@ -1717,6 +1714,7 @@ void mdp4_overlay_borderfill_stage_down(struct mdp4_overlay_pipe *pipe)
 	bspipe->src_format = format;
 	bspipe->alpha_enable = alpha_enable;
 	bspipe->alpha = alpha;
+	bspipe->iommu = iom;
 
 	bspipe->pipe_used++;	
 
@@ -2266,6 +2264,11 @@ static int mdp4_overlay_req2pipe(struct mdp_overlay *req, int mixer,
 	}
 
 	if (req->id == MSMFB_NEW_REQUEST) {  
+		if ( mixer != pipe->mixer_num && mdp4_overlay_pipe_staged(pipe)) {
+			pr_err("%s: ndx=%d still staged\n", __func__,
+						pipe->pipe_ndx);
+			return -EPERM;
+		}
 		pipe->pipe_used++;
 		pipe->mixer_num = mixer;
 		pr_debug("%s: zorder=%d pipe ndx=%d num=%d\n", __func__,
@@ -2335,12 +2338,6 @@ static int mdp4_calc_pipe_mdp_clk(struct msm_fb_data_type *mfd,
 		return ret;
 	}
 
-	if (pipe->mixer_num) {
-		pr_debug("%s: force mdp max clk in mixer %d\n", __func__, pipe->mixer_num);
-		pipe->req_clk = mdp_max_clk;
-		return 0;
-	}
-
 	pr_debug("%s: pipe sets: panel res(x,y)=(%d,%d)\n",
 		 __func__,  mfd->panel_info.xres, mfd->panel_info.yres);
 	pr_debug("%s: src(w,h)(%d,%d),src(x,y)(%d,%d)\n",
@@ -2455,10 +2452,20 @@ static int mdp4_calc_pipe_mdp_clk(struct msm_fb_data_type *mfd,
 
 	if (pipe->flags & MDP_DEINTERLACE) {
 		rst = (rst > mdp_max_clk) ? rst : mdp_max_clk;
+
+		if (mfd->panel_info.lcdc.v_back_porch < 4) {
+			const int deint_req_clk = 266667000;
+			rst = (rst > deint_req_clk) ? rst : deint_req_clk;
+		}
 		pr_info("%s deinterlace requires max mdp clk.\n",
 			__func__);
 	}
 
+	if (pipe->mixer_num && rst < mdp_max_clk) {
+		rst = mdp_max_clk;
+		pr_debug("%s: force mdp max clk in mixer %d\n", __func__, pipe->mixer_num);
+	}
+
 	pipe->req_clk = (u32) rst;
 
 	pr_debug("%s: required mdp clk %d mixer %d pipe ndx %d\n",
@@ -2473,6 +2480,27 @@ static int mdp4_calc_pipe_mdp_clk(struct msm_fb_data_type *mfd,
 
 #define OVERLAY_BUS_SCALE_TABLE_BASE	6
 
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+static int cabc_cur_mode = 0;
+static int cabc_mode = 0;
+
+static int mdp4_overlay_is_rgb_type(int format)
+{
+	switch (format) {
+	case MDP_RGB_565:
+	case MDP_RGB_888:
+	case MDP_BGR_565:
+	case MDP_XRGB_8888:
+	case MDP_ARGB_8888:
+	case MDP_RGBA_8888:
+	case MDP_BGRA_8888:
+	case MDP_RGBX_8888:
+		return 1;
+	default:
+		return 0;
+	}
+}
+#endif
 
 static int mdp4_calc_pipe_mdp_bw(struct msm_fb_data_type *mfd,
 			  struct mdp4_overlay_pipe *pipe)
@@ -2576,6 +2604,7 @@ int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
 	struct mdp4_overlay_pipe *pipe = plist;
 	u32 cnt = 0;
 	int ret = -EINVAL;
+	int burst_mdpclk = 0;
 
 	if (!mfd) {
 		pr_err("%s: mfd is null!\n", __func__);
@@ -2604,8 +2633,14 @@ int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
 		if (pipe->req_clk > mdp_max_clk) {
 			if (pipe->mixer_num == MDP4_MIXER0)
 				perf_req->use_ov0_blt = 1;
-			if (pipe->mixer_num == MDP4_MIXER1)
-				perf_req->use_ov1_blt = 1;
+			if (pipe->mixer_num == MDP4_MIXER1) {
+				if (mfd->mdp_rev == MDP_REV_44 && pipe->req_clk <= mdp44_max_clk) {
+					burst_mdpclk = 1;
+					pr_info("%s: req_clk %d > mdp_max_clk %d in mixer %d\n", __func__,
+							pipe->req_clk, mdp_max_clk, pipe->mixer_num);
+				} else
+					perf_req->use_ov1_blt = 1;
+			}
 		}
 
 		if (!pipe->req_bw) {
@@ -2621,6 +2656,21 @@ int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
 		if (pipe->req_bw < worst_mdp_bw)
 			worst_mdp_bw = pipe->req_bw;
 
+		if (pipe->mixer_num == MDP4_MIXER0) {
+			
+			switch (pipe->src_format) {
+			case MDP_XRGB_8888:
+			case MDP_ARGB_8888:
+			case MDP_RGBA_8888:
+			case MDP_BGRA_8888:
+			case MDP_RGBX_8888:
+				break;
+			default:
+				worst_mdp_bw = OVERLAY_PERF_LEVEL4;
+				break;
+			}
+		}
+
 		if (mfd->mdp_rev == MDP_REV_41) {
 			if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
 				if (pipe->dst_x != 0 && (OVERLAY_TYPE_RGB !=
@@ -2636,8 +2686,13 @@ int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
 	}
 
 	perf_req->mdp_clk_rate = worst_mdp_clk;
-	if (perf_req->mdp_clk_rate > mdp_max_clk)
-		perf_req->mdp_clk_rate = mdp_max_clk;
+	if (perf_req->mdp_clk_rate > mdp_max_clk) {
+		if (burst_mdpclk)
+			perf_req->mdp_clk_rate = mdp44_max_clk;
+		else
+			perf_req->mdp_clk_rate = mdp_max_clk;
+	} else if (perf_req->mdp_clk_rate < mdp_min_clk)
+		perf_req->mdp_clk_rate = mdp_min_clk;
 
 	perf_req->mdp_clk_rate = mdp_clk_round_rate(perf_req->mdp_clk_rate);
 
@@ -2691,7 +2746,9 @@ void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd,
 
 	if (flag) {
 		if (perf_req->mdp_clk_rate > perf_cur->mdp_clk_rate) {
-			perf_req->mdp_clk_rate = 200000000;
+#ifdef CONFIG_ARCH_MSM8X60
+			perf_req->mdp_clk_rate = 160000000;
+#endif
 			mdp_set_core_clk(perf_req->mdp_clk_rate);
 			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
 				__func__,
@@ -2739,17 +2796,18 @@ void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd,
 			perf_cur->use_ov1_blt = perf_req->use_ov1_blt;
 		}
 	} else {
+#ifndef CONFIG_ARCH_MSM8X60
 		if (perf_req->mdp_clk_rate < perf_cur->mdp_clk_rate) {
 			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
 				__func__,
 				flag,
 				perf_cur->mdp_clk_rate,
 				perf_req->mdp_clk_rate);
-
+			mdp_set_core_clk(perf_req->mdp_clk_rate);
 			perf_cur->mdp_clk_rate =
 				perf_req->mdp_clk_rate;
 		}
-
+#endif
 		if (perf_req->mdp_bw > perf_cur->mdp_bw) {
 			pr_info("%s mdp bw is changed [%d] from %d to %d\n",
 				__func__,
@@ -2791,6 +2849,19 @@ void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd,
 	return;
 }
 
+void mdp4_overlay_mdp_perf_dump()
+{
+	struct mdp4_overlay_perf *req = &perf_request;
+	struct mdp4_overlay_perf *cur = &perf_current;
+
+	pr_info("[DISP] req = {clk=%u, bw=%u, ov0_blt=%d, ov1_blt=%d}\n",
+	   req->mdp_clk_rate, req->mdp_bw, req->use_ov0_blt, req->use_ov1_blt);
+	pr_info("[DISP] cur = {clk=%u, bw=%u, ov0_blt=%d, ov1_blt=%d}\n",
+	   cur->mdp_clk_rate, cur->mdp_bw, cur->use_ov0_blt, cur->use_ov1_blt);
+
+	
+}
+
 static int get_img(struct msmfb_data *img, struct fb_info *info,
 	struct mdp4_overlay_pipe *pipe, unsigned int plane,
 	unsigned long *start, unsigned long *len, struct file **srcp_file,
@@ -2916,6 +2987,9 @@ int mdp4_overlay_set(struct fb_info *info, struct mdp_overlay *req)
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	int ret, mixer;
 	struct mdp4_overlay_pipe *pipe;
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	struct msm_fb_panel_data *pdata;
+#endif
 
 	if (mfd == NULL) {
 		pr_err("%s: mfd == NULL, -ENODEV\n", __func__);
@@ -2970,10 +3044,29 @@ int mdp4_overlay_set(struct fb_info *info, struct mdp_overlay *req)
 		}
 	}
 
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	if (!mdp4_overlay_is_rgb_type(pipe->src_format)) {
+		cabc_mode = 1;
+	}
+#endif
+
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 
 	mutex_unlock(&mfd->dma->ov_mutex);
 
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	if (cabc_cur_mode != cabc_mode) {
+		pdata = (struct msm_fb_panel_data *)mfd->pdev->
+			dev.platform_data;
+		if ((pdata) && (pdata->set_cabc)) {
+			down(&mfd->sem);
+			pdata->set_cabc(mfd, cabc_mode);
+			cabc_cur_mode = cabc_mode;
+			up(&mfd->sem);
+		}
+	}
+#endif
+
 	return 0;
 }
 
@@ -3003,6 +3096,9 @@ int mdp4_overlay_unset(struct fb_info *info, int ndx)
 	struct mdp4_overlay_pipe *pipe;
 	struct dpp_ctrl dpp;
 	int i;
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	struct msm_fb_panel_data *pdata;
+#endif
 
 	if (mfd == NULL)
 		return -ENODEV;
@@ -3036,6 +3132,12 @@ int mdp4_overlay_unset(struct fb_info *info, int ndx)
 		}
 	}
 
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	if (!mdp4_overlay_is_rgb_type(pipe->src_format)) {
+		cabc_mode = 0;
+	}
+#endif
+
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_down(pipe, 0);
 
@@ -3067,6 +3169,19 @@ int mdp4_overlay_unset(struct fb_info *info, int ndx)
 
 	mutex_unlock(&mfd->dma->ov_mutex);
 
+#ifdef CONFIG_MSM_CABC_VIDEO_ENHANCE
+	if (cabc_cur_mode != cabc_mode) {
+		pdata = (struct msm_fb_panel_data *)mfd->pdev->
+			dev.platform_data;
+		if ((pdata) && (pdata->set_cabc)) {
+			down(&mfd->sem);
+			pdata->set_cabc(mfd, cabc_mode);
+			cabc_cur_mode = cabc_mode;
+			up(&mfd->sem);
+		}
+	}
+#endif
+
 	return 0;
 }
 
@@ -3308,8 +3423,7 @@ int mdp4_overlay_play(struct fb_info *info, struct msmfb_overlay_data *req)
 		if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
 			
 			mdp4_dsi_cmd_pipe_queue(0, pipe);
-		}
-		if (ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO) {
+		} else if (ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO) {
 			
 			mdp4_dsi_video_pipe_queue(0, pipe);
 		} else if (ctrl->panel_mode & MDP4_PANEL_LCDC) {
@@ -3371,11 +3485,63 @@ int mdp4_overlay_play(struct fb_info *info, struct msmfb_overlay_data *req)
 		put_pmem_file(srcp2_file);
 #endif
 	
-	if (img->flags & MDP_MEMORY_ID_TYPE_FB)
+	if ((img->flags & MDP_MEMORY_ID_TYPE_FB) && srcp0_file)
 		fput_light(srcp0_file, ps0_need);
 	return ret;
 }
 
+int mdp4_overlay_commit(struct fb_info *info)
+{
+	int ret = 0;
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	int mixer;
+
+	if (mfd == NULL)
+		return -ENODEV;
+
+	if (!mfd->panel_power_on) 
+		return -EINVAL;
+
+	mixer = mfd->panel_info.pdest;	
+
+	if (mixer >= MDP4_MIXER_MAX)
+		return -EPERM;
+
+	mutex_lock(&mfd->dma->ov_mutex);
+
+	mdp4_overlay_mdp_perf_upd(mfd, 1);
+
+	msm_fb_wait_for_fence(mfd);
+
+	switch (mfd->panel.type) {
+	case MIPI_CMD_PANEL:
+		mdp4_dsi_cmd_pipe_commit(0, 1);
+		break;
+	case MIPI_VIDEO_PANEL:
+		mdp4_dsi_video_pipe_commit(0, 1);
+		break;
+	case LCDC_PANEL:
+		mdp4_lcdc_pipe_commit(0, 1);
+		break;
+	case DTV_PANEL:
+		mdp4_dtv_pipe_commit(0, 1);
+		break;
+	case WRITEBACK_PANEL:
+	default:
+		pr_err("Panel Not Supported for Commit (fb%d, type:%d)",
+		    mfd->index, mfd->panel.type);
+		ret = -EINVAL;
+		break;
+	}
+	msm_fb_signal_timeline(mfd);
+
+	mdp4_overlay_mdp_perf_upd(mfd, 0);
+
+	mutex_unlock(&mfd->dma->ov_mutex);
+
+	return ret;
+}
+
 struct msm_iommu_ctx {
 	char *name;
 	int  domain;
@@ -3504,7 +3670,7 @@ int mdp4_v4l2_overlay_play(struct fb_info *info, struct mdp4_overlay_pipe *pipe,
 	unsigned long srcp2_addr)
 {
 	struct msm_fb_data_type *mfd = info->par;
-	int err;
+	int err = 0;
 
 	if (mutex_lock_interruptible(&mfd->dma->ov_mutex))
 		return -EINTR;
diff --git a/drivers/video/msm/mdp4_overlay_dsi_cmd.c b/drivers/video/msm/mdp4_overlay_dsi_cmd.c
index a61ae95..b28acf3 100644
--- a/drivers/video/msm/mdp4_overlay_dsi_cmd.c
+++ b/drivers/video/msm/mdp4_overlay_dsi_cmd.c
@@ -77,6 +77,8 @@
 	ktime_t vsync_time;
 	struct work_struct vsync_work;
 	struct work_struct clk_work;
+	
+	int temp_cnt;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 static void vsync_irq_enable(int intr, int term)
@@ -251,7 +253,7 @@ void mdp4_dsi_cmd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 
 static void mdp4_dsi_cmd_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 
-int mdp4_dsi_cmd_pipe_commit(void)
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait)
 {
 	int  i, undx;
 	int mixer = 0;
@@ -267,6 +269,9 @@ int mdp4_dsi_cmd_pipe_commit(void)
 	vctrl = &vsync_ctrl_db[0];
 
 	mutex_lock(&vctrl->update_lock);
+	if(vctrl->temp_cnt > 0)
+		pr_info("[DISP]%s :update_lock done cnt=%d\n",__func__,vctrl->temp_cnt--);
+
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
@@ -376,6 +381,12 @@ int mdp4_dsi_cmd_pipe_commit(void)
 
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
+	if (wait) {
+		long long tick;
+
+		mdp4_dsi_cmd_wait4vsync(cndx, &tick);
+	}
+
 	return cnt;
 }
 
@@ -399,6 +410,10 @@ void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info, int enable)
 			pr_warning("[DISP] %s: suspended, no more vsync event ctrl\n", __func__);
 		enable = 0;
 	}
+	if (enable && (mdp4_overlay_dsi_state_get() <= ST_DSI_SUSPEND)) {
+		pr_info("[DISP] %s: dsi is suspend, req=%d\n", __func__, enable);
+		enable = 0;
+	}
 
 	mutex_lock(&vctrl->update_lock);
 	if (vctrl->vsync_enabled == enable) {
@@ -650,7 +665,7 @@ static void clk_ctrl_work(struct work_struct *work)
 	mutex_unlock(&vctrl->update_lock);
 }
 
-static ssize_t vsync_show_event(struct device *dev,
+ssize_t mdp4_dsi_cmd_show_event(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	int cndx;
@@ -695,14 +710,17 @@ void mdp4_dsi_rdptr_init(int cndx)
 	if (vctrl->inited)
 		return;
 
+	vctrl->temp_cnt = 5;
 	vctrl->inited = 1;
 	vctrl->update_ndx = 0;
 	vctrl->watchdog = 0;
 	mutex_init(&vctrl->update_lock);
+	pr_info("[DISP]%s update_lock init done\n",__func__);
 	init_completion(&vctrl->ov_comp);
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->vsync_comp);
 	spin_lock_init(&vctrl->spin_lock);
+	atomic_set(&vctrl->suspend, 1);
 	INIT_WORK(&vctrl->clk_work, clk_ctrl_work);
 }
 
@@ -856,7 +874,10 @@ static void mdp4_overlay_update_dsi_cmd(struct msm_fb_data_type *mfd)
 		pipe = vctrl->base_pipe;
 	}
 
-	MDP_OUTP(MDP_BASE + 0x021c, 100); 
+	if (mfd->panel_info.read_pointer)
+		MDP_OUTP(MDP_BASE + 0x021c, mfd->panel_info.read_pointer); 
+	else
+		MDP_OUTP(MDP_BASE + 0x021c, 100); 
 
 	MDP_OUTP(MDP_BASE + 0x000a0, 0x10);
 	
@@ -974,15 +995,6 @@ void mdp4_dsi_cmd_overlay_blt(struct msm_fb_data_type *mfd,
 	mdp4_dsi_cmd_do_blt(mfd, req->enable);
 }
 
-static DEVICE_ATTR(vsync_event, S_IRUGO, vsync_show_event, NULL);
-static struct attribute *vsync_fs_attrs[] = {
-	&dev_attr_vsync_event.attr,
-	NULL,
-};
-static struct attribute_group vsync_fs_attr_group = {
-	.attrs = vsync_fs_attrs,
-};
-
 int mdp4_dsi_cmd_on(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -1006,22 +1018,8 @@ int mdp4_dsi_cmd_on(struct platform_device *pdev)
 	mdp4_iommu_attach();
 
 	atomic_set(&vctrl->suspend, 0);
-	pr_debug("%s-:\n", __func__);
-
-	if (!vctrl->sysfs_created) {
-		ret = sysfs_create_group(&vctrl->dev->kobj,
-			&vsync_fs_attr_group);
-		if (ret) {
-			pr_err("%s: sysfs group creation failed, ret=%d\n",
-				__func__, ret);
-			return ret;
-		}
-
-		kobject_uevent(&vctrl->dev->kobj, KOBJ_ADD);
-		pr_debug("%s: kobject_uevent(KOBJ_ADD)\n", __func__);
-		vctrl->sysfs_created = 1;
-	}
 
+	pr_debug("%s-:\n", __func__);
 	return ret;
 }
 
@@ -1137,6 +1135,9 @@ void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd)
 	}
 
 	mutex_lock(&vctrl->update_lock);
+	if(vctrl->temp_cnt > 0)
+		pr_info("[DISP]%s :update_lock done cnt=%d\n",__func__,vctrl->temp_cnt);
+
 	if (atomic_read(&vctrl->suspend)) {
 		mutex_unlock(&vctrl->update_lock);
 		pr_warning("[DISP] %s: suspended, no more pan display\n", __func__);
@@ -1174,7 +1175,8 @@ void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd)
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
 	mutex_lock(&mfd->dma->ov_mutex);
-	mdp4_dsi_cmd_pipe_commit();
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
+	mdp4_dsi_cmd_pipe_commit(cndx, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
+	mdp4_overlay_mdp_perf_upd(mfd, 0);
 }
+
diff --git a/drivers/video/msm/mdp4_overlay_dsi_video.c b/drivers/video/msm/mdp4_overlay_dsi_video.c
index e62cc96..9d6fd62 100644
--- a/drivers/video/msm/mdp4_overlay_dsi_video.c
+++ b/drivers/video/msm/mdp4_overlay_dsi_video.c
@@ -37,6 +37,7 @@
 #include "mipi_dsi.h"
 
 #include <mach/iommu_domains.h>
+#include <mach/debug_display.h>
 
 #define DSI_VIDEO_BASE	0xE0000
 
@@ -150,7 +151,7 @@ void mdp4_dsi_video_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 static void mdp4_dsi_video_wait4dmap(int cndx);
 static void mdp4_dsi_video_wait4ov(int cndx);
 
-int mdp4_dsi_video_pipe_commit(void)
+int mdp4_dsi_video_pipe_commit(int cndx, int wait)
 {
 
 	int  i, undx;
@@ -162,7 +163,7 @@ int mdp4_dsi_video_pipe_commit(void)
 	unsigned long flags;
 	int cnt = 0;
 
-	vctrl = &vsync_ctrl_db[0];
+	vctrl = &vsync_ctrl_db[cndx];
 
 	mutex_lock(&vctrl->update_lock);
 	undx =  vctrl->update_ndx;
@@ -247,6 +248,13 @@ int mdp4_dsi_video_pipe_commit(void)
 
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
+	if (wait) {
+		if (pipe->ov_blt_addr)
+			mdp4_dsi_video_wait4ov(cndx);
+		else
+			mdp4_dsi_video_wait4dmap(cndx);
+	}
+
 	return cnt;
 }
 
@@ -359,13 +367,15 @@ static void mdp4_dsi_video_wait4ov(int cndx)
 	wait_for_completion(&vctrl->ov_comp);
 }
 
-static ssize_t vsync_show_event(struct device *dev,
+ssize_t mdp4_dsi_video_show_event(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
 	unsigned long flags;
+	int timeout = 0;
+	static int cnt = 0;
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
@@ -379,7 +389,15 @@ static ssize_t vsync_show_event(struct device *dev,
 	vctrl->wait_vsync_cnt++;
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	wait_for_completion(&vctrl->vsync_comp);
+	timeout = wait_for_completion_timeout(&vctrl->vsync_comp, HZ/20);
+
+	if (!timeout) {
+		if (cnt > 3)
+			PR_DISP_WARN("WARNING %s: vsync timeout\n", __func__);
+		cnt++;
+	} else
+		cnt = 0;
+
 
 	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu",
 			ktime_to_ns(vctrl->vsync_time));
@@ -396,7 +414,7 @@ void mdp4_dsi_vsync_init(int cndx)
 		return;
 	}
 
-	pr_info("%s: ndx=%d\n", __func__, cndx);
+	pr_debug("%s: ndx=%d\n", __func__, cndx);
 
 	vctrl = &vsync_ctrl_db[cndx];
 	if (vctrl->inited)
@@ -408,7 +426,7 @@ void mdp4_dsi_vsync_init(int cndx)
 	init_completion(&vctrl->vsync_comp);
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->ov_comp);
-	atomic_set(&vctrl->suspend, 0);
+	atomic_set(&vctrl->suspend, 1);
 	spin_lock_init(&vctrl->spin_lock);
 }
 
@@ -425,17 +443,6 @@ void mdp4_dsi_video_base_swap(int cndx, struct mdp4_overlay_pipe *pipe)
 	vctrl->base_pipe = pipe;
 }
 
-static DEVICE_ATTR(vsync_event, S_IRUGO, vsync_show_event, NULL);
-
-static struct attribute *vsync_fs_attrs[] = {
-	&dev_attr_vsync_event.attr,
-	NULL,
-};
-
-static struct attribute_group vsync_fs_attr_group = {
-	.attrs = vsync_fs_attrs,
-};
-
 int mdp4_dsi_video_on(struct platform_device *pdev)
 {
 	int dsi_width;
@@ -553,7 +560,6 @@ int mdp4_dsi_video_on(struct platform_device *pdev)
 		MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
 		mdelay(20);
 		mipi_dsi_controller_cfg(0);
-		mfd->cont_splash_done = 1;
 		mdp_clk_ctrl(0);
 	}
 #endif
@@ -639,6 +645,12 @@ int mdp4_dsi_video_on(struct platform_device *pdev)
 		active_v_end = 0;
 	}
 
+#ifdef CONFIG_FB_MSM_RESOLUTION_OVERRIDE
+	active_hctl = 0;
+	active_v_start = 0;
+	active_v_end = 0;
+#endif
+
 	dsi_underflow_clr |= 0x80000000;	
 	hsync_polarity = 0;
 	vsync_polarity = 0;
@@ -666,20 +678,6 @@ int mdp4_dsi_video_on(struct platform_device *pdev)
 
 	mdp_histogram_ctrl_all(TRUE);
 
-	if (!vctrl->sysfs_created) {
-		ret = sysfs_create_group(&vctrl->dev->kobj,
-			&vsync_fs_attr_group);
-		if (ret) {
-			pr_err("%s: sysfs group creation failed, ret=%d\n",
-				__func__, ret);
-			return ret;
-		}
-
-		kobject_uevent(&vctrl->dev->kobj, KOBJ_ADD);
-		pr_debug("%s: kobject_uevent(KOBJ_ADD)\n", __func__);
-		vctrl->sysfs_created = 1;
-	}
-
 	return ret;
 }
 
@@ -1000,7 +998,6 @@ static void mdp4_dsi_video_do_blt(struct msm_fb_data_type *mfd, int enable)
 			mdp4_dsi_video_wait4dmap_done(0);
 			MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
 			msleep(20);
-			mipi_dsi_controller_cfg(0);
 		}
 		mdp4_overlayproc_cfg(pipe);
 		mdp4_overlay_dmap_xy(pipe);
@@ -1018,7 +1015,6 @@ static void mdp4_dsi_video_do_blt(struct msm_fb_data_type *mfd, int enable)
 				mdp4_dsi_video_wait4ov(0);
 			}
 			mipi_dsi_sw_reset();
-			mipi_dsi_controller_cfg(1);
 			MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 1);
 		}
 		vctrl->blt_change = 0;
@@ -1075,14 +1071,15 @@ void mdp4_dsi_video_overlay(struct msm_fb_data_type *mfd)
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
 	mutex_lock(&mfd->dma->ov_mutex);
-	mdp4_dsi_video_pipe_commit();
+	mdp4_dsi_video_pipe_commit(cndx, 0);
 
 	if (pipe->ov_blt_addr)
-		mdp4_dsi_video_wait4ov(0);
+		mdp4_dsi_video_wait4ov(cndx);
 	else
-		mdp4_dsi_video_wait4dmap(0);
+		mdp4_dsi_video_wait4dmap(cndx);
 
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 }
 
+
diff --git a/drivers/video/msm/mdp4_overlay_dtv.c b/drivers/video/msm/mdp4_overlay_dtv.c
index 781ae32..a1acf93 100644
--- a/drivers/video/msm/mdp4_overlay_dtv.c
+++ b/drivers/video/msm/mdp4_overlay_dtv.c
@@ -26,6 +26,7 @@
 #include <asm/system.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
+#include <mach/debug_display.h>
 
 #include "mdp.h"
 #include "msm_fb.h"
@@ -34,6 +35,7 @@
 #define DTV_BASE	0xD0000
 
 static int dtv_enabled;
+static int dtv_pipe_ready = 0;
 
 #ifdef DEBUG
 static void __mdp_outp(uint32 port, uint32 value)
@@ -158,7 +160,7 @@ void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 static void mdp4_dtv_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 static void mdp4_dtv_wait4dmae(int cndx);
 
-int mdp4_dtv_pipe_commit(void)
+int mdp4_dtv_pipe_commit(int cndx, int wait)
 {
 
 	int  i, undx;
@@ -170,7 +172,7 @@ int mdp4_dtv_pipe_commit(void)
 	unsigned long flags;
 	int cnt = 0;
 
-	vctrl = &vsync_ctrl_db[0];
+	vctrl = &vsync_ctrl_db[cndx];
 	mutex_lock(&vctrl->update_lock);
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
@@ -183,6 +185,24 @@ int mdp4_dtv_pipe_commit(void)
 		return 0;
 	}
 
+	if(!dtv_pipe_ready) {
+		for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
+			real_pipe = mdp4_overlay_ndx2pipe(i);
+			if (real_pipe && real_pipe->pipe_used != 0
+				&& real_pipe->pipe_type != OVERLAY_TYPE_BF
+				&& real_pipe->mixer_num == MDP4_MIXER1) {
+				dtv_pipe_ready = true;
+				break;
+			}
+		}
+
+		if(!dtv_pipe_ready && dtv_enabled) {
+			PR_DISP_INFO("Dtv real pipe is not ready, skip this time\n");
+			mutex_unlock(&vctrl->update_lock);
+			return 0;
+		}
+	}
+
 	vctrl->update_ndx++;
 	vctrl->update_ndx &= 0x01;
 	vp->update_cnt = 0;	
@@ -225,6 +245,9 @@ int mdp4_dtv_pipe_commit(void)
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
+	if (wait)
+		mdp4_dtv_wait4dmae(cndx);
+
 	return cnt;
 }
 
@@ -296,7 +319,7 @@ static void mdp4_dtv_wait4dmae(int cndx)
 	wait_for_completion(&vctrl->dmae_comp);
 }
 
-static ssize_t vsync_show_event(struct device *dev,
+ssize_t mdp4_dtv_show_event(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	int cndx;
@@ -345,7 +368,7 @@ void mdp4_dtv_vsync_init(int cndx)
 	init_completion(&vctrl->vsync_comp);
 	init_completion(&vctrl->ov_comp);
 	init_completion(&vctrl->dmae_comp);
-	atomic_set(&vctrl->suspend, 0);
+	atomic_set(&vctrl->suspend, 1);
 	spin_lock_init(&vctrl->spin_lock);
 }
 
@@ -512,15 +535,6 @@ static int mdp4_dtv_stop(struct msm_fb_data_type *mfd)
 	return 0;
 }
 
-static DEVICE_ATTR(vsync_event, S_IRUGO, vsync_show_event, NULL);
-static struct attribute *vsync_fs_attrs[] = {
-	&dev_attr_vsync_event.attr,
-	NULL,
-};
-static struct attribute_group vsync_fs_attr_group = {
-	.attrs = vsync_fs_attrs,
-};
-
 int mdp4_dtv_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
@@ -562,19 +576,7 @@ int mdp4_dtv_on(struct platform_device *pdev)
 		pr_warn("%s: panel_next_on failed", __func__);
 
 	atomic_set(&vctrl->suspend, 0);
-	if (!vctrl->sysfs_created) {
-		ret = sysfs_create_group(&vctrl->dev->kobj,
-			&vsync_fs_attr_group);
-		if (ret) {
-			pr_err("%s: sysfs group creation failed, ret=%d\n",
-				__func__, ret);
-			return ret;
-		}
 
-		kobject_uevent(&vctrl->dev->kobj, KOBJ_ADD);
-		pr_debug("%s: kobject_uevent(KOBJ_ADD)\n", __func__);
-		vctrl->sysfs_created = 1;
-	}
 	pr_info("%s:\n", __func__);
 
 	return ret;
@@ -631,6 +633,7 @@ int mdp4_dtv_off(struct platform_device *pdev)
 #endif
 	
 	mdp_clk_ctrl(0);
+	dtv_pipe_ready = 0;
 
 	pr_info("%s:\n", __func__);
 	return ret;
@@ -848,6 +851,8 @@ void mdp4_dmae_done_dtv(void)
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
+	if (pipe == NULL)
+		return;
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
 
 	spin_lock(&vctrl->spin_lock);
@@ -881,6 +886,8 @@ void mdp4_overlay1_done_dtv(void)
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
+	if (pipe == NULL)
+		return;
 
 	spin_lock(&vctrl->spin_lock);
 	if (pipe->ov_blt_addr == 0) {
@@ -1026,7 +1033,9 @@ void mdp4_dtv_overlay(struct msm_fb_data_type *mfd)
 	}
 
 	mutex_lock(&mfd->dma->ov_mutex);
-	if (mdp4_dtv_pipe_commit())
+	mdp4_overlay_mdp_perf_upd(mfd, 1);
+	if (mdp4_dtv_pipe_commit(cndx, 0))
 		mdp4_dtv_wait4dmae(0);
+	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 }
diff --git a/drivers/video/msm/mdp4_overlay_lcdc.c b/drivers/video/msm/mdp4_overlay_lcdc.c
index b841081..eb6d592 100644
--- a/drivers/video/msm/mdp4_overlay_lcdc.c
+++ b/drivers/video/msm/mdp4_overlay_lcdc.c
@@ -145,7 +145,7 @@ void mdp4_lcdc_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 static void mdp4_lcdc_wait4dmap(int cndx);
 static void mdp4_lcdc_wait4ov(int cndx);
 
-int mdp4_lcdc_pipe_commit(void)
+int mdp4_lcdc_pipe_commit(int cndx, int wait)
 {
 
 	int  i, undx;
@@ -157,7 +157,7 @@ int mdp4_lcdc_pipe_commit(void)
 	unsigned long flags;
 	int cnt = 0;
 
-	vctrl = &vsync_ctrl_db[0];
+	vctrl = &vsync_ctrl_db[cndx];
 
 	mutex_lock(&vctrl->update_lock);
 	undx =  vctrl->update_ndx;
@@ -246,6 +246,13 @@ int mdp4_lcdc_pipe_commit(void)
 
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
 
+	if (wait) {
+		if (pipe->ov_blt_addr)
+			mdp4_lcdc_wait4ov(cndx);
+		else
+			mdp4_lcdc_wait4dmap(cndx);
+	}
+
 	return cnt;
 }
 
@@ -888,13 +895,13 @@ void mdp4_lcdc_overlay(struct msm_fb_data_type *mfd)
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
 	mutex_lock(&mfd->dma->ov_mutex);
-	mdp4_lcdc_pipe_commit();
+	mdp4_lcdc_pipe_commit(cndx, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 
 	if (pipe->ov_blt_addr)
-		mdp4_lcdc_wait4ov(0);
+		mdp4_lcdc_wait4ov(cndx);
 	else
-		mdp4_lcdc_wait4dmap(0);
+		mdp4_lcdc_wait4dmap(cndx);
 
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 }
diff --git a/drivers/video/msm/mdp4_overlay_writeback.c b/drivers/video/msm/mdp4_overlay_writeback.c
new file mode 100644
index 0000000..145ed17
--- /dev/null
+++ b/drivers/video/msm/mdp4_overlay_writeback.c
@@ -0,0 +1,675 @@
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/hrtimer.h>
+#include <linux/delay.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <mach/iommu_domains.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+
+#include <linux/fb.h>
+
+#include "mdp.h"
+#include "msm_fb.h"
+#include "mdp4.h"
+enum {
+	WB_OPEN,
+	WB_START,
+	WB_STOPING,
+	WB_STOP
+};
+enum {
+	REGISTERED,
+	IN_FREE_QUEUE,
+	IN_BUSY_QUEUE,
+	WITH_CLIENT
+};
+
+static struct mdp4_overlay_pipe *writeback_pipe;
+static struct msm_fb_data_type *writeback_mfd;
+static int busy_wait_cnt;
+static bool writeback_init_done = false;
+
+int mdp4_overlay_writeback_on(struct platform_device *pdev)
+{
+	struct msm_fb_data_type *mfd;
+	struct fb_info *fbi;
+	uint8 *buf;
+	struct mdp4_overlay_pipe *pipe;
+	int bpp;
+	int ret;
+	uint32 data;
+
+	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
+
+	if (!mfd)
+		return -ENODEV;
+
+	if (mfd->key != MFD_KEY)
+		return -EINVAL;
+
+	writeback_mfd = mfd;		  
+
+	fbi = mfd->fbi;
+
+	bpp = fbi->var.bits_per_pixel / 8;
+	buf = (uint8 *) fbi->fix.smem_start;
+	buf += fbi->var.xoffset * bpp +
+		fbi->var.yoffset * fbi->fix.line_length;
+
+	
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
+	mdp_clk_ctrl(1);
+	if (writeback_pipe == NULL) {
+		pipe = mdp4_overlay_pipe_alloc(OVERLAY_TYPE_BF, MDP4_MIXER2);
+		if (pipe == NULL)
+			pr_info("%s: pipe_alloc failed\n", __func__);
+		pipe->pipe_used++;
+		pipe->mixer_stage  = MDP4_MIXER_STAGE_BASE;
+		pipe->mixer_num  = MDP4_MIXER2;
+		pipe->src_format = MDP_ARGB_8888;
+		mdp4_overlay_panel_mode(pipe->mixer_num, MDP4_PANEL_WRITEBACK);
+		ret = mdp4_overlay_format2pipe(pipe);
+		if (ret < 0)
+			pr_info("%s: format2type failed\n", __func__);
+
+		writeback_pipe = pipe; 
+
+	} else {
+		pipe = writeback_pipe;
+	}
+	ret = panel_next_on(pdev);
+
+	
+	if (hdmi_prim_display)
+		data = 0x01;
+	else
+		data = 0x02;
+	outpdw(MDP_BASE + 0x100F4, data);
+
+	MDP_OUTP(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x5004,
+		((0x0 & 0xFFF) << 16) | 
+			(0x0 & 0xFFF));         
+	
+	MDP_OUTP(MDP_BASE + MDP4_OVERLAYPROC1_BASE + 0x5008,
+		(0x0 & 0xFFF));         
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	return ret;
+}
+
+int mdp4_overlay_writeback_off(struct platform_device *pdev)
+{
+	int ret;
+	struct msm_fb_data_type *mfd =
+			(struct msm_fb_data_type *)platform_get_drvdata(pdev);
+	if (mfd && writeback_pipe) {
+		mdp4_writeback_dma_busy_wait(mfd);
+		mdp4_overlay_pipe_free(writeback_pipe);
+		mdp4_overlay_panel_mode_unset(writeback_pipe->mixer_num,
+						MDP4_PANEL_WRITEBACK);
+		writeback_pipe = NULL;
+	}
+	ret = panel_next_off(pdev);
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	
+	outpdw(MDP_BASE + 0x100F4, 0x0);
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	mdp_clk_ctrl(0);
+
+	return ret;
+}
+int mdp4_overlay_writeback_update(struct msm_fb_data_type *mfd, struct mdp4_overlay_pipe *ov_pipe)
+{
+	struct fb_info *fbi;
+	uint8 *buf;
+	unsigned int buf_offset;
+	struct mdp4_overlay_pipe *pipe;
+	int bpp;
+
+	if (mfd->key != MFD_KEY)
+		return -ENODEV;
+
+	if (!writeback_pipe)
+		return -EINVAL;
+
+	fbi = mfd->fbi;
+
+	pipe = writeback_pipe;
+
+	bpp = fbi->var.bits_per_pixel / 8;
+	buf = (uint8 *) fbi->fix.smem_start;
+	buf_offset = fbi->var.xoffset * bpp +
+		fbi->var.yoffset * fbi->fix.line_length;
+
+	
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
+	if (ov_pipe && (ov_pipe->flags & MDP_BLIT_NON_CACHED)) {
+		
+		
+		pipe->src_width = ov_pipe->dst_w;
+		pipe->src_height = ov_pipe->dst_h;
+		pipe->src_w = ov_pipe->dst_w;
+		pipe->src_h = ov_pipe->dst_h;
+		
+		
+		
+		if(ov_pipe->src_format == MDP_Y_CBCR_H2V2 ||
+		   ov_pipe->src_format == MDP_Y_CRCB_H2V2) {
+			pipe->src_width = ov_pipe->dst_w;
+			pipe->src_height = ov_pipe->dst_h;
+			pipe->src_w = ov_pipe->dst_w;
+			pipe->src_h = ov_pipe->dst_h;
+		}
+		pipe->dst_w = ov_pipe->dst_w;
+		pipe->dst_h = ov_pipe->dst_h;
+		pipe->srcp0_ystride = ov_pipe->dst_w * 2;
+		pipe->src_x = ov_pipe->src_x;
+		pipe->src_y = ov_pipe->src_y;
+		pipe->dst_x = ov_pipe->dst_x;
+		pipe->dst_y = ov_pipe->dst_y;
+	} else {
+		pipe->src_height = fbi->var.yres;
+		pipe->src_width = fbi->var.xres;
+		pipe->src_h = fbi->var.yres;
+		pipe->src_w = fbi->var.xres;
+		pipe->dst_h = fbi->var.yres;
+		pipe->dst_w = fbi->var.xres;
+		pipe->srcp0_ystride = fbi->fix.line_length;
+		pipe->src_y = 0;
+		pipe->src_x = 0;
+		pipe->dst_y = 0;
+		pipe->dst_x = 0;
+	}
+	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+
+	if (mfd->display_iova)
+		pipe->srcp0_addr = mfd->display_iova + buf_offset;
+	else
+		pipe->srcp0_addr = (uint32)(buf + buf_offset);
+
+	mdp4_mixer_stage_up(pipe, 0);
+
+	mdp4_overlayproc_cfg(pipe);
+	mdp4_mixer_stage_commit(pipe->mixer_num);
+	
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+
+	wmb();
+	return 0;
+}
+void mdp4_writeback_dma_busy_wait(struct msm_fb_data_type *mfd)
+{
+	unsigned long flag;
+	int need_wait = 0;
+
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	if (mfd->dma->busy == TRUE) {
+		if (busy_wait_cnt == 0)
+			INIT_COMPLETION(mfd->dma->comp);
+		busy_wait_cnt = 1;
+		need_wait++;
+	}
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
+
+	if (need_wait) {
+		
+		pr_debug("%s: pending pid=%d\n",
+				__func__, current->pid);
+		wait_for_completion(&mfd->dma->comp);
+	}
+}
+
+void mdp4_overlay1_done_writeback(struct mdp_dma_data *dma)
+{
+	spin_lock(&mdp_spin_lock);
+	dma->busy = FALSE;
+	if (busy_wait_cnt)
+		busy_wait_cnt = 0;
+	mdp_disable_irq_nosync(MDP_OVERLAY2_TERM);
+	spin_unlock(&mdp_spin_lock);
+	complete_all(&dma->comp);
+	pr_debug("%s ovdone interrupt\n", __func__);
+
+}
+void mdp4_writeback_overlay_kickoff(struct msm_fb_data_type *mfd,
+				    struct mdp4_overlay_pipe *pipe)
+{
+	unsigned long flag;
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	mdp_enable_irq(MDP_OVERLAY2_TERM);
+
+	mfd->dma->busy = TRUE;
+	outp32(MDP_INTR_CLEAR, INTR_OVERLAY2_DONE);
+	mdp_intr_mask |= INTR_OVERLAY2_DONE;
+	outp32(MDP_INTR_ENABLE, mdp_intr_mask);
+
+	wmb();	
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
+	
+	mdp_pipe_kickoff(MDP_OVERLAY2_TERM, mfd);
+	wmb();
+	pr_debug("%s: before ov done interrupt\n", __func__);
+}
+void mdp4_writeback_dma_stop(struct msm_fb_data_type *mfd)
+{
+	
+	if (mfd && writeback_pipe) {
+		mdp4_writeback_dma_busy_wait(mfd);
+		mdp4_overlay_writeback_update(mfd, NULL);
+
+		mdp4_writeback_overlay_kickoff(mfd, writeback_pipe);
+	}
+}
+
+void mdp4_writeback_kickoff_video(struct msm_fb_data_type *mfd,
+		struct mdp4_overlay_pipe *pipe)
+{
+	struct msmfb_writeback_data_list *node = NULL;
+
+	if (!writeback_init_done) {
+		printk("[DISP] mdp4_writeback_kickoff_video: writeback_init_done is false!\n");
+		return;
+	}
+
+	mutex_lock(&mfd->unregister_mutex);
+	mutex_lock(&mfd->writeback_mutex);
+	if (!list_empty(&mfd->writeback_free_queue)
+		&& mfd->writeback_state != WB_STOPING
+		&& mfd->writeback_state != WB_STOP) {
+		node = list_first_entry(&mfd->writeback_free_queue,
+				struct msmfb_writeback_data_list, active_entry);
+	}
+	if (node) {
+		list_del(&(node->active_entry));
+		node->state = IN_BUSY_QUEUE;
+		mfd->writeback_active_cnt++;
+	}
+	mutex_unlock(&mfd->writeback_mutex);
+
+	writeback_pipe->ov_blt_addr = (ulong) (node ? node->addr : NULL);
+
+	
+	mdp4_overlay_iommu_unmap_freelist(writeback_pipe->mixer_num);
+
+	if (!writeback_pipe->ov_blt_addr) {
+		pr_err("%s: no writeback buffer 0x%x, %p\n", __func__,
+			(unsigned int)writeback_pipe->ov_blt_addr, node);
+		mutex_unlock(&mfd->unregister_mutex);
+		return;
+	}
+
+	if (writeback_pipe->blt_cnt == 0)
+		mdp4_overlay_writeback_update(mfd, pipe);
+
+	pr_debug("%s: pid=%d\n", __func__, current->pid);
+
+	mdp4_mixer_stage_commit(pipe->mixer_num);
+
+	mdp4_writeback_overlay_kickoff(mfd, pipe);
+	mdp4_writeback_dma_busy_wait(mfd);
+
+	
+	mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 0);
+
+	mutex_lock(&mfd->writeback_mutex);
+	list_add_tail(&node->active_entry, &mfd->writeback_busy_queue);
+	mutex_unlock(&mfd->writeback_mutex);
+	mfd->writeback_active_cnt--;
+	mutex_unlock(&mfd->unregister_mutex);
+	wake_up(&mfd->wait_q);
+
+}
+
+void mdp4_writeback_kickoff_ui(struct msm_fb_data_type *mfd,
+		struct mdp4_overlay_pipe *pipe)
+{
+
+	mdp4_mixer_stage_commit(pipe->mixer_num);
+
+	pr_debug("%s: pid=%d\n", __func__, current->pid);
+	mdp4_writeback_overlay_kickoff(mfd, pipe);
+}
+
+void mdp4_writeback_overlay(struct msm_fb_data_type *mfd)
+{
+	int ret = 0;
+	struct msmfb_writeback_data_list *node = NULL;
+
+	mutex_lock(&mfd->unregister_mutex);
+	mutex_lock(&mfd->writeback_mutex);
+	if (!list_empty(&mfd->writeback_free_queue)
+		&& mfd->writeback_state != WB_STOPING
+		&& mfd->writeback_state != WB_STOP) {
+		node = list_first_entry(&mfd->writeback_free_queue,
+				struct msmfb_writeback_data_list, active_entry);
+	}
+	if (node) {
+		list_del(&(node->active_entry));
+		node->state = IN_BUSY_QUEUE;
+		mfd->writeback_active_cnt++;
+	}
+	mutex_unlock(&mfd->writeback_mutex);
+
+	writeback_pipe->ov_blt_addr = (ulong) (node ? node->addr : NULL);
+
+	mutex_lock(&mfd->dma->ov_mutex);
+	pr_debug("%s in writeback\n", __func__);
+	if (writeback_pipe && !writeback_pipe->ov_blt_addr) {
+		pr_err("%s: no writeback buffer 0x%x\n", __func__,
+				(unsigned int)writeback_pipe->ov_blt_addr);
+		ret = mdp4_overlay_writeback_update(mfd, NULL);
+		if (ret)
+			pr_err("%s: update failed writeback pipe NULL\n",
+					__func__);
+		goto fail_no_blt_addr;
+	}
+
+	if (mfd && mfd->panel_power_on) {
+		pr_debug("%s in before busy wait\n", __func__);
+		mdp4_writeback_dma_busy_wait(mfd);
+
+		pr_debug("%s in before update\n", __func__);
+		ret = mdp4_overlay_writeback_update(mfd, NULL);
+		if (ret) {
+			pr_err("%s: update failed writeback pipe NULL\n",
+					__func__);
+			goto fail_no_blt_addr;
+		}
+
+		pr_debug("%s: in writeback pan display 0x%x\n", __func__,
+				(unsigned int)writeback_pipe->ov_blt_addr);
+		mdp4_writeback_kickoff_ui(mfd, writeback_pipe);
+		mdp4_iommu_unmap(writeback_pipe);
+
+		if (mfd->pan_waiting) {
+			mfd->pan_waiting = FALSE;
+			complete(&mfd->pan_comp);
+		}
+	}
+
+	mutex_lock(&mfd->writeback_mutex);
+	list_add_tail(&node->active_entry, &mfd->writeback_busy_queue);
+	mfd->writeback_active_cnt--;
+	mutex_unlock(&mfd->writeback_mutex);
+	wake_up(&mfd->wait_q);
+fail_no_blt_addr:
+	mutex_unlock(&mfd->dma->ov_mutex);
+	mutex_unlock(&mfd->unregister_mutex);
+}
+static int mdp4_overlay_writeback_register_buffer(
+	struct msm_fb_data_type *mfd, struct msmfb_writeback_data_list *node)
+{
+	if (!node) {
+		pr_err("Cannot register a NULL node\n");
+		return -EINVAL;
+	}
+	node->state = REGISTERED;
+	list_add_tail(&node->registered_entry, &mfd->writeback_register_queue);
+	return 0;
+}
+static struct msmfb_writeback_data_list *get_if_registered(
+			struct msm_fb_data_type *mfd, struct msmfb_data *data)
+{
+	struct msmfb_writeback_data_list *temp;
+	bool found = false;
+	int domain;
+
+	if (!list_empty(&mfd->writeback_register_queue)) {
+		list_for_each_entry(temp,
+				&mfd->writeback_register_queue,
+				registered_entry) {
+			if (temp && temp->buf_info.iova == data->iova) {
+				found = true;
+				break;
+			}
+		}
+	}
+	if (!found) {
+		temp = kzalloc(sizeof(struct msmfb_writeback_data_list),
+				GFP_KERNEL);
+		if (temp == NULL) {
+			pr_err("%s: out of memory\n", __func__);
+			goto register_alloc_fail;
+		}
+		temp->ihdl = NULL;
+		if (data->iova)
+			temp->addr = (void *)(data->iova + data->offset);
+		else if (mfd->iclient) {
+			struct ion_handle *srcp_ihdl;
+			ulong len;
+			srcp_ihdl = ion_import_dma_buf(mfd->iclient,
+						  data->memory_id);
+			if (IS_ERR_OR_NULL(srcp_ihdl)) {
+				pr_err("%s: ion import fd failed\n", __func__);
+				goto register_ion_fail;
+			}
+
+			if (mdp_iommu_split_domain)
+				domain = DISPLAY_WRITE_DOMAIN;
+			else
+				domain = DISPLAY_READ_DOMAIN;
+
+			if (ion_map_iommu(mfd->iclient,
+					  srcp_ihdl,
+					  domain,
+					  GEN_POOL,
+					  SZ_4K,
+					  0,
+					  (ulong *)&temp->addr,
+					  (ulong *)&len,
+					  0,
+					  ION_IOMMU_UNMAP_DELAYED)) {
+				ion_free(mfd->iclient, srcp_ihdl);
+				pr_err("%s: unable to get ion mapping addr\n",
+				       __func__);
+				goto register_ion_fail;
+			}
+			temp->addr += data->offset;
+			temp->ihdl = srcp_ihdl;
+		}
+		else {
+			pr_err("%s: only support ion memory\n", __func__);
+			goto register_ion_fail;
+		}
+
+		memcpy(&temp->buf_info, data, sizeof(struct msmfb_data));
+		if (mdp4_overlay_writeback_register_buffer(mfd, temp)) {
+			pr_err("%s: error registering node\n", __func__);
+			goto register_ion_fail;
+		}
+	}
+	return temp;
+ register_ion_fail:
+	kfree(temp);
+ register_alloc_fail:
+	return NULL;
+}
+int mdp4_writeback_start(
+		struct fb_info *info)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	mutex_lock(&mfd->writeback_mutex);
+	mfd->writeback_state = WB_START;
+	mutex_unlock(&mfd->writeback_mutex);
+	wake_up(&mfd->wait_q);
+	return 0;
+}
+
+int mdp4_writeback_queue_buffer(struct fb_info *info, struct msmfb_data *data)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msmfb_writeback_data_list *node = NULL;
+	int rv = 0;
+
+	mutex_lock(&mfd->writeback_mutex);
+	node = get_if_registered(mfd, data);
+	if (!node || node->state == IN_BUSY_QUEUE ||
+		node->state == IN_FREE_QUEUE) {
+		pr_err("memory not registered or Buffer already with us\n");
+		rv = -EINVAL;
+		goto exit;
+	}
+
+	list_add_tail(&node->active_entry, &mfd->writeback_free_queue);
+	node->state = IN_FREE_QUEUE;
+
+exit:
+	mutex_unlock(&mfd->writeback_mutex);
+	return rv;
+}
+static int is_buffer_ready(struct msm_fb_data_type *mfd)
+{
+	int rc;
+	mutex_lock(&mfd->writeback_mutex);
+	rc = !list_empty(&mfd->writeback_busy_queue) ||
+			(mfd->writeback_state == WB_STOPING);
+	mutex_unlock(&mfd->writeback_mutex);
+	return rc;
+}
+int mdp4_writeback_dequeue_buffer(struct fb_info *info, struct msmfb_data *data)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msmfb_writeback_data_list *node = NULL;
+	int rc = 0, domain;
+
+	rc = wait_event_interruptible(mfd->wait_q, is_buffer_ready(mfd));
+	if (rc) {
+		pr_err("failed to get dequeued buffer\n");
+		return -ENOBUFS;
+	}
+	mutex_lock(&mfd->writeback_mutex);
+	if (mfd->writeback_state == WB_STOPING) {
+		mfd->writeback_state = WB_STOP;
+		mutex_unlock(&mfd->writeback_mutex);
+		return -ENOBUFS;
+	} else	if (!list_empty(&mfd->writeback_busy_queue)) {
+		node = list_first_entry(&mfd->writeback_busy_queue,
+				struct msmfb_writeback_data_list, active_entry);
+	}
+	if (node) {
+		list_del(&node->active_entry);
+		node->state = WITH_CLIENT;
+		memcpy(data, &node->buf_info, sizeof(struct msmfb_data));
+		if (!data->iova)
+			if (mfd->iclient && node->ihdl) {
+				if (mdp_iommu_split_domain)
+					domain = DISPLAY_WRITE_DOMAIN;
+				else
+					domain = DISPLAY_READ_DOMAIN;
+
+				ion_unmap_iommu(mfd->iclient,
+						node->ihdl,
+						domain,
+						GEN_POOL);
+				ion_free(mfd->iclient,
+					 node->ihdl);
+			}
+	} else {
+		pr_err("node is NULL. Somebody else dequeued?\n");
+		rc = -ENOBUFS;
+	}
+	mutex_unlock(&mfd->writeback_mutex);
+	return rc;
+}
+
+static bool is_writeback_inactive(struct msm_fb_data_type *mfd)
+{
+	bool active;
+	mutex_lock(&mfd->writeback_mutex);
+	active = !mfd->writeback_active_cnt;
+	mutex_unlock(&mfd->writeback_mutex);
+	return active;
+}
+int mdp4_writeback_stop(struct fb_info *info)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	int mixer;
+
+	mutex_lock(&mfd->writeback_mutex);
+	mfd->writeback_state = WB_STOPING;
+	mutex_unlock(&mfd->writeback_mutex);
+	
+	wait_event_interruptible(mfd->wait_q, is_writeback_inactive(mfd));
+
+	
+	wake_up(&mfd->wait_q);
+	mixer = mfd->panel_info.pdest;
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+	return 0;
+}
+int mdp4_writeback_init(struct fb_info *info)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	mutex_init(&mfd->writeback_mutex);
+	mutex_init(&mfd->unregister_mutex);
+	INIT_LIST_HEAD(&mfd->writeback_free_queue);
+	INIT_LIST_HEAD(&mfd->writeback_busy_queue);
+	INIT_LIST_HEAD(&mfd->writeback_register_queue);
+	mfd->writeback_state = WB_OPEN;
+	init_waitqueue_head(&mfd->wait_q);
+
+	writeback_init_done = true;
+	return 0;
+}
+int mdp4_writeback_terminate(struct fb_info *info)
+{
+	struct list_head *ptr, *next;
+	struct msmfb_writeback_data_list *temp;
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	int rc = 0;
+
+	mutex_lock(&mfd->unregister_mutex);
+	mutex_lock(&mfd->writeback_mutex);
+
+	if (mfd->writeback_state != WB_STOPING &&
+		mfd->writeback_state != WB_STOP) {
+		pr_err("%s called without stopping\n", __func__);
+		rc = -EPERM;
+		goto terminate_err;
+
+	}
+
+	if (!list_empty(&mfd->writeback_register_queue)) {
+		list_for_each_safe(ptr, next,
+				&mfd->writeback_register_queue) {
+			temp = list_entry(ptr,
+					struct msmfb_writeback_data_list,
+					registered_entry);
+			list_del(&temp->registered_entry);
+			kfree(temp);
+		}
+	}
+	INIT_LIST_HEAD(&mfd->writeback_register_queue);
+	INIT_LIST_HEAD(&mfd->writeback_busy_queue);
+	INIT_LIST_HEAD(&mfd->writeback_free_queue);
+
+
+terminate_err:
+	mutex_unlock(&mfd->writeback_mutex);
+	mutex_unlock(&mfd->unregister_mutex);
+	writeback_init_done = false;
+	return rc;
+}
diff --git a/drivers/video/msm/mdp4_util.c b/drivers/video/msm/mdp4_util.c
index 60e79da..fb27499 100644
--- a/drivers/video/msm/mdp4_util.c
+++ b/drivers/video/msm/mdp4_util.c
@@ -353,6 +353,7 @@ irqreturn_t mdp4_isr(int irq, void *ptr)
 	struct mdp_hist_mgmt *mgmt = NULL;
 	char *base_addr;
 	int i, ret;
+	static unsigned long prev_jiffy = 0; 
 
 	mdp_is_in_isr = TRUE;
 
@@ -386,6 +387,17 @@ irqreturn_t mdp4_isr(int irq, void *ptr)
 		mdp4_stat.intr_underrun_e++;
 	}
 
+	if (isr & (INTR_PRIMARY_INTF_UDERRUN|INTR_EXTERNAL_INTF_UDERRUN)) {
+		if (time_after(jiffies, prev_jiffy + 5 * HZ) || !prev_jiffy) {
+			pr_info("%s: UNDERRUN isr: 0x%x (pri: %lu, ext: %lu)\n",
+			     __func__, isr,
+			     mdp4_stat.intr_underrun_p, mdp4_stat.intr_underrun_e);
+
+			mdp4_overlay_mdp_perf_dump();
+			prev_jiffy = jiffies;
+		}
+	}
+
 	isr &= mask;
 
 	if (isr == 0)
@@ -2850,7 +2862,7 @@ int mdp4_pcc_cfg(struct mdp_pcc_cfg_data *cfg_ptr)
 		break;
 
 	default:
-		break;
+		return ret;
 	}
 
 	if (0x8 & cfg_ptr->ops)
diff --git a/drivers/video/msm/mdp4_wfd_writeback.c b/drivers/video/msm/mdp4_wfd_writeback.c
new file mode 100644
index 0000000..332cd3c
--- /dev/null
+++ b/drivers/video/msm/mdp4_wfd_writeback.c
@@ -0,0 +1,96 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/ioctl.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+
+#include "mdp4_wfd_writeback_util.h"
+#include "msm_fb.h"
+
+static int writeback_on(struct platform_device *pdev)
+{
+	return 0;
+}
+static int writeback_off(struct platform_device *pdev)
+{
+	return 0;
+}
+static int writeback_probe(struct platform_device *pdev)
+{
+	struct msm_fb_data_type *mfd;
+	struct platform_device *mdp_dev = NULL;
+	struct msm_fb_panel_data *pdata = NULL;
+	int rc = 0;
+
+	WRITEBACK_MSG_ERR("Inside writeback_probe\n");
+	mfd = platform_get_drvdata(pdev);
+	if (!mfd)
+		return -ENODEV;
+	if (mfd->key != MFD_KEY)
+		return -EINVAL;
+
+	mdp_dev = platform_device_alloc("mdp", pdev->id);
+	if (!mdp_dev)
+		return -ENOMEM;
+	mfd->pdev = mdp_dev;
+	mfd->dest = DISPLAY_LCD;
+
+	if (platform_device_add_data
+			(mdp_dev, pdev->dev.platform_data,
+			 sizeof(struct msm_fb_panel_data))) {
+		pr_err("writeback_probe: "
+			"platform_device_add_data failed!\n");
+		platform_device_put(mdp_dev);
+		return -ENOMEM;
+	}
+	pdata = (struct msm_fb_panel_data *)mdp_dev->dev.platform_data;
+	pdata->on = writeback_on;
+	pdata->off = writeback_off;
+	pdata->next = pdev;
+
+	mfd->panel_info = pdata->panel_info;
+
+	mfd->fb_imgType = MDP_RGB_565;
+
+	platform_set_drvdata(mdp_dev, mfd);
+
+	rc = platform_device_add(mdp_dev);
+	if (rc) {
+		WRITEBACK_MSG_ERR("failed to add device");
+		platform_device_put(mdp_dev);
+		return rc;
+	}
+	return rc;
+}
+
+static struct platform_driver writeback_driver = {
+	.probe = writeback_probe,
+	.driver = {
+		.name = "writeback",
+	},
+};
+
+static int __init writeback_driver_init(void)
+{
+	int rc = 0;
+	WRITEBACK_MSG_ERR("Inside writeback_driver_init\n");
+	rc = platform_driver_register(&writeback_driver);
+	return rc;
+}
+
+module_init(writeback_driver_init);
diff --git a/drivers/video/msm/mdp4_wfd_writeback_panel.c b/drivers/video/msm/mdp4_wfd_writeback_panel.c
new file mode 100644
index 0000000..c6397ad
--- /dev/null
+++ b/drivers/video/msm/mdp4_wfd_writeback_panel.c
@@ -0,0 +1,84 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/ioctl.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+
+#include "mdp4_wfd_writeback_util.h"
+#include "msm_fb.h"
+
+static int __devinit writeback_panel_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	if (pdev->id == 0)
+		return 0;
+
+	if (!msm_fb_add_device(pdev)) {
+		WRITEBACK_MSG_ERR("Failed to add fd device\n");
+		rc = -ENOMEM;
+	}
+	return rc;
+}
+static struct msm_fb_panel_data writeback_msm_panel_data = {
+	.panel_info = {
+		.type = WRITEBACK_PANEL,
+		.xres = 1920,
+		.yres = 1920,
+		.pdest = DISPLAY_3,
+		.wait_cycle = 0,
+		.bpp = 24,
+		.fb_num = 1,
+		
+		.clk_rate = 177780000,
+	},
+};
+
+static struct platform_device writeback_panel_device = {
+	.name = "writeback_panel",
+	.id = 1,
+	.dev.platform_data = &writeback_msm_panel_data,
+};
+static struct platform_driver writeback_panel_driver = {
+	.probe = writeback_panel_probe,
+	.driver = {
+		.name = "writeback_panel"
+	}
+};
+
+static int __init writeback_panel_init(void)
+{
+	int rc = 0;
+	rc = platform_driver_register(&writeback_panel_driver);
+	if (rc) {
+		WRITEBACK_MSG_ERR("Failed to register platform driver\n");
+		goto fail_driver_registration;
+	}
+	rc = platform_device_register(&writeback_panel_device);
+	if (rc) {
+		WRITEBACK_MSG_ERR("Failed to register "
+				"writeback_panel_device\n");
+		goto fail_device_registration;
+	}
+	return rc;
+fail_device_registration:
+	platform_driver_unregister(&writeback_panel_driver);
+fail_driver_registration:
+	return rc;
+}
+
+late_initcall(writeback_panel_init);
diff --git a/drivers/video/msm/mdp4_wfd_writeback_util.h b/drivers/video/msm/mdp4_wfd_writeback_util.h
new file mode 100644
index 0000000..2d62713
--- /dev/null
+++ b/drivers/video/msm/mdp4_wfd_writeback_util.h
@@ -0,0 +1,28 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _WRITEBACK_UTIL_H_
+#define _WRITEBACK_UTIL_H_
+
+#define DEBUG
+
+#ifdef DEBUG
+	#define WRITEBACK_MSG_INFO(fmt...) pr_info(fmt)
+	#define WRITEBACK_MSG_WARN(fmt...) pr_warning(fmt)
+#else
+	#define WRITEBACK_MSG_INFO(fmt...)
+	#define WRITEBACK_MSG_WARN(fmt...)
+#endif
+	#define WRITEBACK_MSG_ERR(fmt...) pr_err(fmt)
+	#define WRITEBACK_MSG_CRIT(fmt...) pr_crit(fmt)
+#endif
diff --git a/drivers/video/msm/mdp_dma.c b/drivers/video/msm/mdp_dma.c
index 86b85ce..57304d7 100644
--- a/drivers/video/msm/mdp_dma.c
+++ b/drivers/video/msm/mdp_dma.c
@@ -418,6 +418,9 @@ void mdp_dma2_update(struct msm_fb_data_type *mfd)
 	MDPIBUF *iBuf;
 	uint32 upper_height;
 
+	if (!mfd)
+		return;
+
 	if (mfd->panel.type == EXT_MDDI_PANEL) {
 		mdp_dma2_update_sub(mfd);
 		return;
diff --git a/drivers/video/msm/mdp_dma_s.c b/drivers/video/msm/mdp_dma_s.c
index c91948b..01fc2f3 100644
--- a/drivers/video/msm/mdp_dma_s.c
+++ b/drivers/video/msm/mdp_dma_s.c
@@ -135,6 +135,9 @@ static void mdp_dma_s_update_lcd(struct msm_fb_data_type *mfd)
 
 void mdp_dma_s_update(struct msm_fb_data_type *mfd)
 {
+	if (!mfd)
+		return;
+
 	down(&mfd->dma->mutex);
 	if ((mfd) && (!mfd->dma->busy) && (mfd->panel_power_on)) {
 		down(&mfd->sem);
diff --git a/drivers/video/msm/mipi_dsi.c b/drivers/video/msm/mipi_dsi.c
index 905b818..3897dd6 100644
--- a/drivers/video/msm/mipi_dsi.c
+++ b/drivers/video/msm/mipi_dsi.c
@@ -29,12 +29,15 @@
 #include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/clk.h>
+#include <mach/debug_display.h>
 
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mdp.h"
 #include "mdp4.h"
 
+#include <mach/panel_id.h>
+
 u32 dsi_irq;
 u32 esc_byte_ratio;
 
@@ -96,7 +99,8 @@ static int mipi_dsi_off(struct platform_device *pdev)
 				if (MDP_REV_303 != mdp_rev)
 					gpio_free(vsync_gpio);
 			}
-			mipi_dsi_set_tear_off(mfd);
+			if (!mfd->panel_info.lcdc.no_set_tear)
+				mipi_dsi_set_tear_off(mfd);
 		}
 	}
 
@@ -121,6 +125,34 @@ static int mipi_dsi_off(struct platform_device *pdev)
 	return ret;
 }
 
+void mipi_exit_ulps(void)
+{
+	uint32 status;
+#if 0
+	status=MIPI_INP(MIPI_DSI_BASE + 0x00a4);
+	if ((status&0x1700)!=0) {
+	PR_DISP_DEBUG("%s: no need to exit ulps\n", __func__);
+	} else
+#endif
+	
+	{
+		status=MIPI_INP(MIPI_DSI_BASE + 0x00a8);
+		status&=0x10000000; 
+		status |= (BIT(8) | BIT(9) | BIT(10) | BIT(12));
+		MIPI_OUTP(MIPI_DSI_BASE + 0x00a8, status);
+		mb();
+		msleep(5);
+		status=MIPI_INP(MIPI_DSI_BASE + 0x00a4);
+		if ((status&0x1700)!=0) {
+			status=MIPI_INP(MIPI_DSI_BASE + 0x00a8);
+			status&=0x10000000; 
+			MIPI_OUTP(MIPI_DSI_BASE + 0x00a8, status);
+		} else {
+			PR_DISP_DEBUG("%s: cannot exit ulps\n", __func__);
+		}
+	}
+}
+
 static int mipi_dsi_on(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -133,8 +165,9 @@ static int mipi_dsi_on(struct platform_device *pdev)
 	u32 ystride, bpp, data;
 	u32 dummy_xres, dummy_yres;
 	int target_type = 0;
+	static bool bfirsttime = true;
 
-	pr_debug("%s+:\n", __func__);
+	PR_DISP_INFO("%s+:\n", __func__);
 
 	mfd = platform_get_drvdata(pdev);
 	fbi = mfd->fbi;
@@ -241,6 +274,11 @@ static int mipi_dsi_on(struct platform_device *pdev)
 
 	ret = panel_next_on(pdev);
 
+	if (mipi->force_leave_ulps && bfirsttime) {
+		mipi_exit_ulps();
+		bfirsttime = false;
+	}
+
 	mipi_dsi_op_mode_config(mipi->mode);
 
 	if (mfd->panel_info.type == MIPI_CMD_PANEL) {
@@ -286,7 +324,8 @@ static int mipi_dsi_on(struct platform_device *pdev)
 					}
 				}
 			}
-			mipi_dsi_set_tear_on(mfd);
+			if (!mfd->panel_info.lcdc.no_set_tear)
+				mipi_dsi_set_tear_on(mfd);
 		}
 		mipi_dsi_clk_cfg(0);
 	}
@@ -303,7 +342,7 @@ static int mipi_dsi_on(struct platform_device *pdev)
 	else
 		up(&mfd->dma->mutex);
 
-	pr_debug("%s-:\n", __func__);
+	PR_DISP_INFO("%s-:\n", __func__);
 
 	return ret;
 }
@@ -395,7 +434,7 @@ static int mipi_dsi_probe(struct platform_device *pdev)
 		if (mipi_dsi_clk_init(pdev))
 			return -EPERM;
 
-		if (mipi_dsi_pdata->splash_is_enabled &&
+		if (mipi_dsi_pdata && mipi_dsi_pdata->splash_is_enabled &&
 			!mipi_dsi_pdata->splash_is_enabled()) {
 			mipi_dsi_ahb_ctrl(1);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x118, 0);
@@ -451,7 +490,7 @@ static int mipi_dsi_probe(struct platform_device *pdev)
 	else
 		mfd->dest = DISPLAY_LCD;
 
-	if (mdp_rev == MDP_REV_303 &&
+	if (mdp_rev == MDP_REV_303 && mipi_dsi_pdata &&
 		mipi_dsi_pdata->get_lane_config) {
 		if (mipi_dsi_pdata->get_lane_config() != 2) {
 			pr_info("Changing to DSI Single Mode Configuration\n");
@@ -583,3 +622,4 @@ static int __init mipi_dsi_driver_init(void)
 }
 
 module_init(mipi_dsi_driver_init);
+
diff --git a/drivers/video/msm/mipi_dsi.h b/drivers/video/msm/mipi_dsi.h
index 0e53b81..938b11b 100644
--- a/drivers/video/msm/mipi_dsi.h
+++ b/drivers/video/msm/mipi_dsi.h
@@ -130,6 +130,7 @@ enum dsi_trigger_type {
 extern int mipi_dsi_clk_on;
 extern u32 dsi_irq;
 extern u32 esc_byte_ratio;
+extern int panel_type;
 
 extern void  __iomem *periph_base;
 extern char *mmss_cc_base;	
@@ -188,7 +189,7 @@ struct dsi_clk_desc {
 #define DSI_HDR_DATA1(data)	((data) & 0x0ff)
 #define DSI_HDR_WC(wc)		((wc) & 0x0ffff)
 
-#define DSI_BUF_SIZE	64
+#define DSI_BUF_SIZE	1024
 #define MIPI_DSI_MRPS	0x04	
 
 #define MIPI_DSI_LEN 8 
@@ -345,4 +346,8 @@ int mipi_dsi_clk_div_config(uint8 bpp, uint8 lanes,
 void update_lane_config(struct msm_panel_info *pinfo);
 #endif
 
+#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
+uint32 mipi_dsi_cmd_bta_sw_trigger_status(void);
+uint32 mipi_dsi_read_power_mode(void);
+#endif
 #endif 
diff --git a/drivers/video/msm/mipi_dsi_host.c b/drivers/video/msm/mipi_dsi_host.c
index a42971d..da4ecae 100644
--- a/drivers/video/msm/mipi_dsi_host.c
+++ b/drivers/video/msm/mipi_dsi_host.c
@@ -64,6 +64,7 @@ enum {
 
 struct dcs_cmd_list	cmdlist;
 
+void mipi_dsi_error(void);
 #ifdef CONFIG_FB_MSM_MDP40
 void mipi_dsi_mdp_stat_inc(int which)
 {
@@ -178,7 +179,7 @@ void mipi_dsi_clk_turn_on(struct msm_panel_info const *pinfo, int target_type)
 		mipi_dsi_clk_enable();
 
 		dsi_clk_on_aux = 1;
-		dsi_clk_cnt = 0;
+		dsi_clk_cnt = 1;
 	}
 
 	mutex_unlock(&clk_mutex);
@@ -219,16 +220,14 @@ void mipi_dsi_clk_cfg(int on)
 		}
 		dsi_clk_cnt++;
 	} else {
-		if (dsi_clk_cnt || dsi_clk_on_aux) {
-			if (dsi_clk_cnt)
-				dsi_clk_cnt--;
-			if (dsi_clk_cnt == 0) {
-				mipi_dsi_clk_disable();
-				mipi_dsi_ahb_ctrl(0);
-				mipi_dsi_unprepare_clocks();
-			}
-			dsi_clk_on_aux = 0;
+		if (dsi_clk_cnt)
+			dsi_clk_cnt--;
+		if (dsi_clk_cnt == 0) {
+			mipi_dsi_clk_disable();
+			mipi_dsi_ahb_ctrl(0);
+			mipi_dsi_unprepare_clocks();
 		}
+		dsi_clk_on_aux = 0;
 	}
 	pr_debug("%s: on=%d clk_cnt=%d pid=%d\n", __func__,
 				on, dsi_clk_cnt, current->pid);
@@ -1090,7 +1089,56 @@ void mipi_dsi_set_tear_off(struct msm_fb_data_type *mfd)
 
 	mipi_dsi_cmdlist_put(&cmdreq);
 }
+#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
+uint32 mipi_dsi_cmd_bta_sw_trigger_status(void)
+{
+        uint32 data, status;
+        int cnt = 0;
+
+        MIPI_OUTP(MIPI_DSI_BASE + 0x094, 0x01); 
+        wmb();
+
+        while (cnt < 100000) {
+                data = MIPI_INP(MIPI_DSI_BASE + 0x0004);
+                if ((data & 0x0010) == 0)
+                        break;
+                cnt++;
+        }
+
+        status = MIPI_INP(MIPI_DSI_BASE + 0x0064);
+
+        if (status) {
+                pr_err("%s: status=%x\n", __func__, status);
+        }
+
+        pr_info("%s: BTA done, cnt=%d\n", __func__, cnt);
+
+	return status;
+}
+
+static char read_power_mode[2] = {0x0A, 0x00};
+static struct dsi_cmd_desc power_mode_cmd = {
+        DTYPE_DCS_READ, 1, 0, 0, 0, sizeof(read_power_mode), read_power_mode};
+uint32 pwr_mode;
 
+static void mipi_read_power_mode_cb(u32 data)
+{
+	pwr_mode = data & 0xff;
+	pr_info("%s: power_mode=%x\n", __func__, pwr_mode);
+}
+
+uint32 mipi_dsi_read_power_mode(void)
+{
+	cmdreq.cmds = &power_mode_cmd;
+	cmdreq.cmds_cnt = 1;
+	cmdreq.flags = CMD_REQ_RX | CMD_REQ_COMMIT;
+	cmdreq.rlen = 1;
+	cmdreq.cb = mipi_read_power_mode_cb;
+	mipi_dsi_cmdlist_put(&cmdreq);
+
+	return pwr_mode;
+}
+#endif
 int mipi_dsi_cmd_reg_tx(uint32 data)
 {
 #ifdef DSI_HOST_DEBUG
@@ -1141,7 +1189,7 @@ int mipi_dsi_cmds_tx(struct dsi_buf *tp, struct dsi_cmd_desc *cmds, int cnt)
 		mipi_dsi_cmd_dma_add(tp, cm);
 		mipi_dsi_cmd_dma_tx(tp);
 		if (cm->wait)
-			msleep(cm->wait);
+			hr_msleep(cm->wait);
 		cm++;
 	}
 
@@ -1383,6 +1431,10 @@ int mipi_dsi_cmd_dma_tx(struct dsi_buf *tp)
 		if (ret <= 0) {
 			pr_info("%s: wait for dsi_dma complete timeout (ret=%d, busy=%d, stat=0x%x)\n",
 			    __func__, ret, dsi_cmd_dma_need_wait, MIPI_INP(MIPI_DSI_BASE + 0x0004));
+			if (dsi_cmd_dma_need_wait > 5) {
+				mipi_dsi_error();
+				mipi_dsi_sw_reset();
+			}
 		}
 	}
 
@@ -1604,7 +1656,7 @@ void mipi_dsi_ack_err_status(void)
 
 	if (status) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0064, status);
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_info("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1615,7 +1667,7 @@ void mipi_dsi_timeout_status(void)
 	status = MIPI_INP(MIPI_DSI_BASE + 0x00bc);
 	if (status & 0x0111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00bc, status);
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_info("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1627,7 +1679,7 @@ void mipi_dsi_dln0_phy_err(void)
 
 	if (status & 0x011111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00b0, status);
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_info("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1639,7 +1691,7 @@ void mipi_dsi_fifo_status(void)
 
 	if (status & 0x44444489) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0008, status);
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_info("%s: status=%x\n", __func__, status);
 	}
 }
 
@@ -1651,7 +1703,7 @@ void mipi_dsi_status(void)
 
 	if (status & 0x80000000) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0004, status);
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_info("%s: status=%x\n", __func__, status);
 	}
 }
 
diff --git a/drivers/video/msm/msm_fb.c b/drivers/video/msm/msm_fb.c
index 99bb17d..deb9c6a 100644
--- a/drivers/video/msm/msm_fb.c
+++ b/drivers/video/msm/msm_fb.c
@@ -41,6 +41,9 @@
 #include <linux/android_pmem.h>
 #include <linux/leds.h>
 #include <linux/pm_runtime.h>
+#include <linux/sync.h>
+#include <linux/sw_sync.h>
+#include <linux/file.h>
 #include <linux/pm_qos.h>
 #include <mach/perflock.h>
 
@@ -129,6 +132,8 @@ static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 void msm_fb_shutdown(struct platform_device *pdev);
 static int mdp_bl_scale_config(struct msm_fb_data_type *mfd,
 						struct mdp_bl_scale_data *data);
+static void msm_fb_commit_wq_handler(struct work_struct *work);
+static int msm_fb_pan_idle(struct msm_fb_data_type *mfd);
 static void msm_fb_scale_bl(__u32 *bl_lvl);
 
 #ifdef CONFIG_MSM_MULTIMEDIA_USE_ION
@@ -167,6 +172,10 @@ char *get_fb_addr(void)
 #define MSM_FB_MAX_DBGFS 1024
 #define MAX_BACKLIGHT_BRIGHTNESS 255
 
+#define WAIT_FENCE_TIMEOUT 800
+#define WAIT_DISP_OP_TIMEOUT 900
+#define MAX_TIMELINE_NAME_LEN 16
+
 int msm_fb_debugfs_file_index;
 struct dentry *msm_fb_debugfs_root;
 struct dentry *msm_fb_debugfs_file[MSM_FB_MAX_DBGFS];
@@ -273,6 +282,57 @@ static int color_enhance_switch(int on)
 	return count;
 }
 
+unsigned long sre_status = 0;
+unsigned long sre_status_old = 0;
+
+static int sre_ctl_switch(int level)
+{
+   if (level == sre_status)
+       return 1;
+
+   sre_status = level;
+   
+
+   return 0;
+}
+
+static ssize_t
+sre_ctl_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t
+sre_ctl_store(struct device *dev, struct device_attribute *attr,
+       const char *buf, size_t count);
+#define SRE_CTL_ATTR(name) __ATTR(name, 0644, sre_ctl_show, sre_ctl_store)
+
+static struct device_attribute sre_ctl_attr = SRE_CTL_ATTR(sre_status_ctl);
+static ssize_t
+sre_ctl_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+   int i = 0;
+
+   i += scnprintf(buf + i, PAGE_SIZE - 1, "%lu\n", sre_status);
+   return i;
+}
+
+static ssize_t
+sre_ctl_store(struct device *dev, struct device_attribute *attr,
+   const char *buf, size_t count)
+{
+   int rc;
+   unsigned long res;
+
+   rc = strict_strtoul(buf, 10, &res);
+   if (rc) {
+       PR_DISP_INFO("invalid parameter, %s %d\n", buf, rc);
+       count = -EINVAL;
+       goto err_out;
+   }
+   if (sre_ctl_switch(res))
+       count = -EIO;
+
+err_out:
+   return count;
+}
+
 static int lcd_backlight_registered;
 
 static void msm_fb_set_bl_brightness(struct led_classdev *led_cdev,
@@ -300,6 +360,67 @@ static void msm_fb_set_bl_brightness(struct led_classdev *led_cdev,
 };
 #endif
 
+#ifdef CONFIG_MSM_ACL_ENABLE
+unsigned long auto_bkl_status = 8;
+static int cabc_updated = 0;
+#define CABC_STATE_DCR 1
+
+static int cabc_switch(int on)
+{
+	if (test_bit(CABC_STATE_DCR, &auto_bkl_status) == on)
+		return 1;
+
+	if (on) {
+		PR_DISP_INFO("turn on DCR\n");
+		set_bit(CABC_STATE_DCR, &auto_bkl_status);
+	} else {
+		PR_DISP_INFO("turn off DCR\n");
+		clear_bit(CABC_STATE_DCR, &auto_bkl_status);
+	}
+	cabc_updated = 0;
+
+	return 1;
+}
+
+static ssize_t
+auto_backlight_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t
+auto_backlight_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count);
+#define CABC_ATTR(name) __ATTR(name, 0644, auto_backlight_show, auto_backlight_store)
+
+static struct device_attribute auto_attr = CABC_ATTR(auto);
+static ssize_t
+auto_backlight_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i = 0;
+
+	i += scnprintf(buf + i, PAGE_SIZE - 1, "%d\n",
+				test_bit(CABC_STATE_DCR, &auto_bkl_status));
+	return i;
+}
+
+static ssize_t
+auto_backlight_store(struct device *dev, struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	int rc;
+	unsigned long res;
+
+	rc = strict_strtoul(buf, 10, &res);
+	if (rc) {
+		PR_DISP_INFO("invalid parameter, %s %d\n", buf, rc);
+		count = -EINVAL;
+		goto err_out;
+	}
+	if (cabc_switch(!!res))
+		count = -EIO;
+
+err_out:
+	return count;
+}
+#endif
+
 static const char *cameratitle = "BL_CAM_MIN=";
 static unsigned backlightvalue = 0;
 
@@ -484,6 +605,49 @@ static void msm_fb_remove_sysfs(struct platform_device *pdev)
 	sysfs_remove_group(&mfd->fbi->dev->kobj, &msm_fb_attr_group);
 }
 
+static void dimming_do_work(struct work_struct *work)
+{
+	struct msm_fb_data_type *mfd = container_of(
+			work, struct msm_fb_data_type, dimming_work);
+	struct msm_fb_panel_data *pdata;
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+
+	if ((pdata) && (pdata->dimming_on)) {
+		pdata->dimming_on(mfd);
+	}
+}
+
+static void dimming_update(unsigned long data)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)data;
+	queue_work(mfd->dimming_wq, &mfd->dimming_work);
+}
+
+static void sre_do_work(struct work_struct *work)
+{
+   struct msm_fb_data_type *mfd = container_of(
+           work, struct msm_fb_data_type, sre_work);
+   struct msm_fb_panel_data *pdata;
+   pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+
+   if ((pdata) && (pdata->sre_ctrl)) {
+       //pdata->sre_ctrl(mfd, get_lightsensoradc());
+       mod_timer(&mfd->sre_update_timer, jiffies + msecs_to_jiffies(1000));
+   }
+}
+
+static void sre_update(unsigned long data)
+{
+   struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)data;
+
+   if (!mfd->panel_power_on) {
+	PR_DISP_INFO("%s: skip sre_work\n", __func__);
+	return;
+   }
+
+   queue_work(mfd->sre_wq, &mfd->sre_work);
+}
+
 static int msm_fb_update_perflock_locked(int newlock)
 {
 	if (perflock_pan.lock_stat == newlock)
@@ -529,6 +693,7 @@ static void msm_fb_perflock_reaper(struct work_struct *work)
 static int msm_fb_probe(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct msm_fb_panel_data *pdata;
 	int rc;
 	int err = 0;
 
@@ -619,9 +784,39 @@ static int msm_fb_probe(struct platform_device *pdev)
 			lcd_backlight_registered = 1;
 			if (device_create_file(backlight_led.dev, &color_enhance_attr))
 				printk("attr creation failed\n");
+#ifdef CONFIG_MSM_ACL_ENABLE
+			if(device_create_file(backlight_led.dev, &auto_attr))
+				PR_DISP_INFO("attr creation failed\n");
+#endif
+
+#ifdef CONFIG_FB_MSM_CABC_LEVEL_CONTROL
+			if (device_create_file(backlight_led.dev, &cabc_level_ctl_attr))
+				PR_DISP_INFO("attr creation failed\n");
+#endif
+			if (device_create_file(backlight_led.dev, &sre_ctl_attr))
+				PR_DISP_INFO("attr creation failed for sre_ctl_attr\n");
+
 		}
 	}
 #endif
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+	if ((pdata) && (pdata->dimming_on)) {
+		INIT_WORK(&mfd->dimming_work, dimming_do_work);
+		mfd->dimming_wq = create_workqueue("dimming_wq");
+		if (!mfd->dimming_wq)
+			printk(KERN_ERR "%s: can't create workqueue for dimming_wq\n", __func__);
+		else
+			setup_timer(&mfd->dimming_update_timer, dimming_update, (unsigned long)mfd);
+	}
+
+	if ((pdata) && (pdata->sre_ctrl)) {
+		INIT_WORK(&mfd->sre_work, sre_do_work);
+		mfd->sre_wq= create_workqueue("sre_wq");
+		if (!mfd->sre_wq)
+			printk(KERN_ERR "%s: can't create workqueue for sre_wq\n", __func__);
+		else
+			setup_timer(&mfd->sre_update_timer, sre_update, (unsigned long)mfd);
+	}
 
 	if (mfd->panel_info.pdest == DISPLAY_1) {
 		err = device_create_file(backlight_led.dev, &app_attr);
@@ -631,6 +826,23 @@ static int msm_fb_probe(struct platform_device *pdev)
 
 	pdev_list[pdev_list_cnt++] = pdev;
 	msm_fb_create_sysfs(pdev);
+
+
+	if (mfd->timeline == NULL) {
+		char timeline_name[MAX_TIMELINE_NAME_LEN];
+		snprintf(timeline_name, sizeof(timeline_name),
+			"mdp_fb_%d", mfd->index);
+		mfd->timeline = sw_sync_timeline_create(timeline_name);
+		if (mfd->timeline == NULL) {
+			pr_err("%s: cannot create time line", __func__);
+			return -ENOMEM;
+		} else {
+			mfd->timeline_value = 0;
+	}
+	}
+
+
+
 	mutex_init(&msm_fb_blank_mutex);
 	return 0;
 }
@@ -772,6 +984,7 @@ static int msm_fb_suspend_sub(struct msm_fb_data_type *mfd)
 	mfd->suspend.sw_refreshing_enable = mfd->sw_refreshing_enable;
 	mfd->suspend.op_enable = mfd->op_enable;
 	mfd->suspend.panel_power_on = mfd->panel_power_on;
+	mfd->suspend.op_suspend = true;
 
 	if (mfd->op_enable) {
 		ret =
@@ -829,6 +1042,7 @@ static int msm_fb_resume_sub(struct msm_fb_data_type *mfd)
 		if (ret)
 			MSM_FB_INFO("msm_fb_resume: can't turn on display!\n");
 	}
+	mfd->suspend.op_suspend = false;
 
 	return ret;
 }
@@ -1062,12 +1276,21 @@ void msm_fb_set_backlight(struct msm_fb_data_type *mfd, __u32 bkl_lvl)
 {
 	struct msm_fb_panel_data *pdata;
 	__u32 temp = bkl_lvl;
-	if (!mfd->panel_power_on || !bl_updated) {
+
+	down(&mfd->sem);
+	if (mfd->panel_power_on && !bl_updated && !mfd->request_display_on) {
+		PR_DISP_INFO("%s: bl_level_old = %d bkl_lvl = %d\n", __func__, bl_level_old, bkl_lvl);
+		unset_bl_level = 0;
+		bl_updated = 1;
+		bl_level_old = 0;	
+	} else if (!mfd->panel_power_on || !bl_updated) {
 		unset_bl_level = bkl_lvl;
+		up(&mfd->sem);
 		return;
 	} else {
 		unset_bl_level = 0;
 	}
+	up(&mfd->sem);
 
 	msm_fb_scale_bl(&temp);
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
@@ -1096,6 +1319,12 @@ void msm_fb_display_on(struct msm_fb_data_type *mfd)
                 pdata->display_on(mfd);
                 up(&mfd->sem);
         }
+	if ((pdata) && (pdata->sre_ctrl)) {
+		mod_timer(&mfd->sre_update_timer, jiffies + msecs_to_jiffies(50));
+	}
+	if ((pdata) && (pdata->dimming_on)) {
+		mod_timer(&mfd->dimming_update_timer, jiffies + msecs_to_jiffies(1000));
+	}
 }
 
 void msm_fb_display_off(struct msm_fb_data_type *mfd)
@@ -1147,10 +1376,20 @@ static int msm_fb_blank_sub(int blank_mode, struct fb_info *info,
 			int curr_pwr_state;
 
 			mutex_lock(&msm_fb_blank_mutex);
+
+			
+			if ((pdata) && (pdata->dimming_on))
+				del_timer_sync(&mfd->dimming_update_timer);
+
+			if ((pdata) && (pdata->sre_ctrl)) {
+				del_timer_sync(&mfd->sre_update_timer);
+			}
 			mfd->op_enable = FALSE;
 			curr_pwr_state = mfd->panel_power_on;
 			mfd->panel_power_on = FALSE;
+			down(&mfd->sem);
 			bl_updated = 0;
+			up(&mfd->sem);
 
 			down(&msm_fb_pan_sem);
 			cancel_delayed_work(&perflock_pan.worker);
@@ -1163,6 +1402,7 @@ static int msm_fb_blank_sub(int blank_mode, struct fb_info *info,
 			if (ret)
 				mfd->panel_power_on = curr_pwr_state;
 
+			msm_fb_release_timeline(mfd);
 			mfd->op_enable = TRUE;
 			mutex_unlock(&msm_fb_blank_mutex);
 		}
@@ -1205,6 +1445,7 @@ static void msm_fb_fillrect(struct fb_info *info,
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
+	msm_fb_pan_idle(mfd);
 	cfb_fillrect(info, rect);
 	if (!mfd->hw_refresh && (info->var.yoffset == 0) &&
 		!mfd->sw_currently_refreshing) {
@@ -1225,6 +1466,7 @@ static void msm_fb_copyarea(struct fb_info *info,
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
+	msm_fb_pan_idle(mfd);
 	cfb_copyarea(info, area);
 	if (!mfd->hw_refresh && (info->var.yoffset == 0) &&
 		!mfd->sw_currently_refreshing) {
@@ -1244,6 +1486,7 @@ static void msm_fb_imageblit(struct fb_info *info, const struct fb_image *image)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
+	msm_fb_pan_idle(mfd);
 	cfb_imageblit(info, image);
 	if (!mfd->hw_refresh && (info->var.yoffset == 0) &&
 		!mfd->sw_currently_refreshing) {
@@ -1262,6 +1505,7 @@ static void msm_fb_imageblit(struct fb_info *info, const struct fb_image *image)
 static int msm_fb_blank(int blank_mode, struct fb_info *info)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	msm_fb_pan_idle(mfd);
 	return msm_fb_blank_sub(blank_mode, info, mfd->op_enable);
 }
 
@@ -1283,22 +1527,20 @@ static int msm_fb_mmap(struct fb_info *info, struct vm_area_struct * vma)
 	u32 len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
 	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-	if (off >= len) {
-		
-		off -= len;
-		if (info->var.accel_flags) {
-			mutex_unlock(&info->lock);
-			return -EINVAL;
-		}
-		start = info->fix.mmio_start;
-		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
-	}
+
+	if ((vma->vm_end <= vma->vm_start) ||
+		(off >= len) ||
+		((vma->vm_end - vma->vm_start) > (len - off)))
+                return -EINVAL;
+
+	msm_fb_pan_idle(mfd);
 
 	
 	start &= PAGE_MASK;
-	if ((vma->vm_end - vma->vm_start + off) > len)
-		return -EINVAL;
 	off += start;
+	if (off < start)
+		return -EINVAL;
+
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 	
 	vma->vm_flags |= VM_IO | VM_RESERVED;
@@ -1547,6 +1789,7 @@ static int msm_fb_register(struct msm_fb_data_type *mfd)
 	var->yres_virtual = panel_info->yres * mfd->fb_page +
 		((PAGE_SIZE - remainder)/fix->line_length) * mfd->fb_page;
 	var->bits_per_pixel = bpp * 8;	
+	var->reserved[3] =  mdp_get_panel_framerate(mfd);
 	if (mfd->dest == DISPLAY_LCD) {
 		if (panel_info->type == MDDI_PANEL && panel_info->mddi.is_type1) {
 			var->reserved[3] = panel_info->lcd.refx100 / (100 * 2);
@@ -1700,6 +1943,16 @@ static int msm_fb_register(struct msm_fb_data_type *mfd)
 		return -EPERM;
 	}
 
+	init_completion(&mfd->commit_comp);
+	mutex_init(&mfd->sync_mutex);
+	INIT_WORK(&mfd->commit_work, msm_fb_commit_wq_handler);
+	mfd->msm_fb_backup = kzalloc(sizeof(struct msm_fb_backup_type),
+		GFP_KERNEL);
+	if (mfd->msm_fb_backup == 0) {
+		pr_err("error: not enough memory!\n");
+		return -ENOMEM;
+	}
+
 	fbram += fix->smem_len;
 	fbram_phys += fix->smem_len;
 	fbram_size -= fix->smem_len;
@@ -1909,6 +2162,13 @@ static int msm_fb_release(struct fb_info *info, int user)
 	mfd->ref_cnt--;
 
 	if (!mfd->ref_cnt) {
+		if (mfd->suspend.op_suspend) {
+			
+			mfd->sw_refreshing_enable = mfd->suspend.sw_refreshing_enable;
+			mfd->op_enable = mfd->suspend.op_enable;
+			mfd->panel_power_on = mfd->suspend.panel_power_on;
+			mfd->suspend.op_suspend = false;
+		}
 		if ((ret =
 		     msm_fb_blank_sub(FB_BLANK_POWERDOWN, info,
 				      mfd->op_enable)) != 0) {
@@ -1921,10 +2181,145 @@ static int msm_fb_release(struct fb_info *info, int user)
 	return ret;
 }
 
+void msm_fb_wait_for_fence(struct msm_fb_data_type *mfd)
+{
+#ifdef CONFIG_SW_SYNC
+	int i, ret = 0;
+	
+	for (i = 0; i < mfd->acq_fen_cnt; i++) {
+		ret = sync_fence_wait(mfd->acq_fen[i], WAIT_FENCE_TIMEOUT);
+		sync_fence_put(mfd->acq_fen[i]);
+		if (ret < 0) {
+			pr_err("%s: sync_fence_wait failed! ret = %x\n",
+				__func__, ret);
+			break;
+		}
+	}
+	mfd->acq_fen_cnt = 0;
+#endif
+}
+
+int msm_fb_signal_timeline(struct msm_fb_data_type *mfd)
+{
+#ifdef CONFIG_SW_SYNC
+	mutex_lock(&mfd->sync_mutex);
+	if (mfd->timeline) {
+		sw_sync_timeline_inc(mfd->timeline, 1);
+		mfd->timeline_value++;
+	}
+	mfd->last_rel_fence = mfd->cur_rel_fence;
+	mfd->cur_rel_fence = 0;
+	mutex_unlock(&mfd->sync_mutex);
+#endif
+	return 0;
+}
+
+void msm_fb_release_timeline(struct msm_fb_data_type *mfd)
+{
+#ifdef CONFIG_SW_SYNC
+	if (mfd->timeline) {
+		sw_sync_timeline_inc(mfd->timeline, 2);
+		mfd->timeline_value += 2;
+	}
+	mfd->last_rel_fence = 0;
+	mfd->cur_rel_fence = 0;
+#endif
+}
+
+static int msm_fb_pan_idle(struct msm_fb_data_type *mfd)
+{
+	int ret = 0;
+
+	mutex_lock(&mfd->sync_mutex);
+	if (mfd->is_committing) {
+		mutex_unlock(&mfd->sync_mutex);
+		ret = wait_for_completion_timeout(&mfd->commit_comp,
+			msecs_to_jiffies(WAIT_FENCE_TIMEOUT));
+		if (ret <= 0)
+			pr_err("%s wait for commit_comp timeout %d %d",
+				__func__, ret, mfd->is_committing);
+	} else {
+		mutex_unlock(&mfd->sync_mutex);
+	}
+	return ret;
+}
+static int msm_fb_pan_display_ex(struct fb_var_screeninfo *var,
+			      struct fb_info *info, u32 wait_for_finish)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msm_fb_backup_type *fb_backup;
+	int ret = 0;
+
+	if (bf_supported && info->node == 2) {
+		pr_err("%s: no pan display for fb%d!",
+		       __func__, info->node);
+		ret = -EPERM;
+		goto do_release_timeline;
+	}
+
+	if (info->node != 0 || mfd->cont_splash_done)	
+		if ((!mfd->op_enable) || (!mfd->panel_power_on)) {
+			ret = -EPERM;
+			PR_DISP_INFO("%s: mfd->op_enable:%d mfd->panel_power_on:%d\n",
+				__func__, mfd->op_enable, mfd->panel_power_on);
+			goto do_release_timeline;
+		}
+
+	if (var->xoffset > (info->var.xres_virtual - info->var.xres)) {
+		PR_DISP_INFO("%s: var->xoffset:%d info->var.xres_virtual:%d info->var.xres:%d\n",
+			__func__, var->xoffset, info->var.xres_virtual, info->var.xres);
+		ret =  -EINVAL;
+		goto do_release_timeline;
+	}
+
+	if (var->yoffset > (info->var.yres_virtual - info->var.yres)) {
+		PR_DISP_INFO("%s: var->yoffset:%d info->var.yres_virtual:%d info->var.yres:%d\n",
+			__func__, var->yoffset, info->var.yres_virtual, info->var.yres);
+		ret =  -EINVAL;
+		goto do_release_timeline;
+	}
+
+	msm_fb_pan_idle(mfd);
+
+	mutex_lock(&mfd->sync_mutex);
+
+	if (info->fix.xpanstep)
+		info->var.xoffset =
+		    (var->xoffset / info->fix.xpanstep) * info->fix.xpanstep;
+
+	if (info->fix.ypanstep)
+		info->var.yoffset =
+		    (var->yoffset / info->fix.ypanstep) * info->fix.ypanstep;
+
+	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
+	memcpy(&fb_backup->info, info, sizeof(struct fb_info));
+	memcpy(&fb_backup->var, var, sizeof(struct fb_var_screeninfo));
+	mfd->is_committing = 1;
+	INIT_COMPLETION(mfd->commit_comp);
+	schedule_work(&mfd->commit_work);
+	mutex_unlock(&mfd->sync_mutex);
+	if (wait_for_finish)
+		msm_fb_pan_idle(mfd);
+
+do_release_timeline:
+	if (ret) {
+		PR_DISP_INFO("%s: timeline=%d, ret=%d, do release timeline\n",
+			__func__, mfd->timeline_value, ret);
+		msm_fb_release_timeline(mfd);
+	}
+
+	return ret;
+}
 
 static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 			      struct fb_info *info)
 {
+	return msm_fb_pan_display_ex(var, info, FALSE);
+}
+
+static int msm_fb_pan_display_sub(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
 	struct mdp_dirty_region dirty;
 	struct mdp_dirty_region *dirtyPtr = NULL;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
@@ -1935,8 +2330,12 @@ static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 
 	mutex_lock(&msm_fb_blank_mutex);
 	if (bf_supported && info->node == 2) {
-		pr_err("%s: no pan display for fb%d!",
-		       __func__, info->node);
+		static unsigned int panfb2cnt = 0; 
+		if ((panfb2cnt & 0x3f)==0) { 
+			pr_info("%s: skip pan display for fb%d! (cnt: %u)\n",
+				__func__, info->node, panfb2cnt);
+		}
+		panfb2cnt++;
 		ret = -EPERM;
 		goto done;
 	}
@@ -2022,11 +2421,15 @@ static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 	mutex_unlock(&msm_fb_notify_update_sem);
 
 	down(&msm_fb_pan_sem);
-
+	msm_fb_wait_for_fence(mfd);
 	if (info->node == 0 && !(mfd->cont_splash_done)) { 
 		mdp_set_dma_pan_info(info, NULL, TRUE);
 		if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable)) {
 			pr_err("%s: can't turn on display!\n", __func__);
+			up(&msm_fb_pan_sem);
+			msm_fb_release_timeline(mfd);
+
+			ret = -EINVAL;
 			goto done;
 		}
 	}
@@ -2046,6 +2449,7 @@ static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 		mdp_dma_pan_update(info);
 	}
 
+	msm_fb_signal_timeline(mfd);
 	up(&msm_fb_pan_sem);
 	if (mfd->request_display_on) {
 		msm_fb_display_on(mfd);
@@ -2056,8 +2460,10 @@ static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 				unset_bl_level = DEFAULT_BRIGHTNESS;
 			ignore_bkl_zero = true;
 		}
+		down(&mfd->sem);
 		mfd->request_display_on = 0;
 		bl_updated = 0;
+		up(&mfd->sem);
 	}
 	if (unset_bl_level && !bl_updated) {
 		pdata = (struct msm_fb_panel_data *)mfd->pdev->
@@ -2067,25 +2473,64 @@ static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 			mfd->bl_level = unset_bl_level;
 			pdata->set_backlight(mfd);
 			bl_level_old = unset_bl_level;
-			up(&mfd->sem);
 			bl_updated = 1;
+			up(&mfd->sem);
 		}
 	}
 	mutex_unlock(&msm_fb_blank_mutex);
 
+#ifdef CONFIG_MSM_ACL_ENABLE
+	if (!cabc_updated) {
+		pdata = (struct msm_fb_panel_data *)mfd->pdev->
+			dev.platform_data;
+		if ((pdata) && (pdata->acl_enable)) {
+			down(&mfd->sem);
+			pdata->acl_enable(auto_bkl_status, mfd);
+			cabc_updated = 1;
+			up(&mfd->sem);
+		}
+	}
+#endif
+
+
 	++mfd->panel_info.frame_count;
 	return 0;
 
 done:
+	if (ret) {
+		pr_info("%s: timeline=%d, ret=%d, do release timeline\n",
+		    __func__, mfd->timeline_value, ret);
+		msm_fb_release_timeline(mfd);
+	}
 	mutex_unlock(&msm_fb_blank_mutex);
 
 	return ret;
 }
 
+static void msm_fb_commit_wq_handler(struct work_struct *work)
+{
+	struct msm_fb_data_type *mfd;
+	struct fb_var_screeninfo *var;
+	struct fb_info *info;
+	struct msm_fb_backup_type *fb_backup;
+
+	mfd = container_of(work, struct msm_fb_data_type, commit_work);
+	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
+	var = &fb_backup->var;
+	info = &fb_backup->info;
+	msm_fb_pan_display_sub(var, info);
+	mutex_lock(&mfd->sync_mutex);
+	mfd->is_committing = 0;
+	complete_all(&mfd->commit_comp);
+	mutex_unlock(&mfd->sync_mutex);
+
+}
+
 static int msm_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
+	msm_fb_pan_idle(mfd);
 	if (var->rotate != FB_ROTATE_UR)
 		return -EINVAL;
 	if (var->grayscale != info->var.grayscale)
@@ -2215,6 +2660,7 @@ static int msm_fb_set_par(struct fb_info *info)
 	int old_imgType;
 	int blank = 0;
 
+	msm_fb_pan_idle(mfd);
 	old_imgType = mfd->fb_imgType;
 	switch (var->bits_per_pixel) {
 	case 16:
@@ -2963,7 +3409,7 @@ static int msmfb_blit(struct fb_info *info, void __user *p)
 	int count, i, req_list_count;
 	if (bf_supported &&
 		(info->node == 1 || info->node == 2)) {
-		pr_err("%s: no pan display for fb%d.",
+		pr_err("%s: no pan display for fb%d.\n",
 		       __func__, info->node);
 		return -EPERM;
 	}
@@ -3133,7 +3579,9 @@ static int msmfb_overlay_play(struct fb_info *info, unsigned long *argp)
 	int	ret;
 	struct msmfb_overlay_data req;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-
+#ifdef CONFIG_MSM_ACL_ENABLE
+	struct msm_fb_panel_data *pdata;
+#endif
 	if (mfd->overlay_play_enable == 0)	
 		return 0;
 
@@ -3164,6 +3612,19 @@ static int msmfb_overlay_play(struct fb_info *info, unsigned long *argp)
 
 	ret = mdp4_overlay_play(info, &req);
 
+#ifdef CONFIG_MSM_ACL_ENABLE
+	if (!cabc_updated) {
+		pdata = (struct msm_fb_panel_data *)mfd->pdev->
+			dev.platform_data;
+		if ((pdata) && (pdata->acl_enable)) {
+			down(&mfd->sem);
+			pdata->acl_enable(auto_bkl_status, mfd);
+			cabc_updated = 1;
+			up(&mfd->sem);
+		}
+	}
+#endif
+
 	return ret;
 }
 
@@ -3486,6 +3947,124 @@ static int msmfb_handle_pp_ioctl(struct msm_fb_data_type *mfd,
 	return ret;
 }
 
+static int msmfb_handle_buf_sync_ioctl(struct msm_fb_data_type *mfd,
+						struct mdp_buf_sync *buf_sync)
+{
+	int ret = 0;
+#ifdef CONFIG_SW_SYNC
+	int i, fence_cnt = 0;
+	int acq_fen_fd[MDP_MAX_FENCE_FD];
+	struct sync_fence *fence;
+
+	if ((buf_sync->acq_fen_fd_cnt > MDP_MAX_FENCE_FD) ||
+		(mfd->timeline == NULL))
+		return -EINVAL;
+
+	if (buf_sync->acq_fen_fd_cnt)
+		ret = copy_from_user(acq_fen_fd, buf_sync->acq_fen_fd,
+				buf_sync->acq_fen_fd_cnt * sizeof(int));
+	if (ret) {
+		pr_err("%s:copy_from_user failed", __func__);
+		return ret;
+	}
+	mutex_lock(&mfd->sync_mutex);
+	for (i = 0; i < buf_sync->acq_fen_fd_cnt; i++) {
+		fence = sync_fence_fdget(acq_fen_fd[i]);
+		if (fence == NULL) {
+			pr_info("%s: null fence! i=%d fd=%d\n", __func__, i,
+				acq_fen_fd[i]);
+			ret = -EINVAL;
+			break;
+		}
+		mfd->acq_fen[i] = fence;
+	}
+	fence_cnt = i;
+	if (ret)
+		goto buf_sync_err_1;
+	mfd->acq_fen_cnt = fence_cnt;
+	if (buf_sync->flags & MDP_BUF_SYNC_FLAG_WAIT) {
+		msm_fb_wait_for_fence(mfd);
+	}
+	mfd->cur_rel_sync_pt = sw_sync_pt_create(mfd->timeline,
+			mfd->timeline_value + 2);
+	if (mfd->cur_rel_sync_pt == NULL) {
+		pr_err("%s: cannot create sync point", __func__);
+		ret = -ENOMEM;
+		goto buf_sync_err_1;
+	}
+	
+	mfd->cur_rel_fence = sync_fence_create("mdp-fence",
+			mfd->cur_rel_sync_pt);
+	if (mfd->cur_rel_fence == NULL) {
+		sync_pt_free(mfd->cur_rel_sync_pt);
+		mfd->cur_rel_sync_pt = NULL;
+		pr_err("%s: cannot create fence", __func__);
+		ret = -ENOMEM;
+		goto buf_sync_err_1;
+	}
+	
+	mfd->cur_rel_fen_fd = get_unused_fd_flags(0);
+	sync_fence_install(mfd->cur_rel_fence, mfd->cur_rel_fen_fd);
+	ret = copy_to_user(buf_sync->rel_fen_fd,
+		&mfd->cur_rel_fen_fd, sizeof(int));
+	if (ret) {
+		pr_err("%s:copy_to_user failed", __func__);
+		goto buf_sync_err_2;
+	}
+
+	mutex_unlock(&mfd->sync_mutex);
+	return ret;
+
+buf_sync_err_2:
+	sync_fence_put(mfd->cur_rel_fence);
+	put_unused_fd(mfd->cur_rel_fen_fd);
+	mfd->cur_rel_fence = NULL;
+	mfd->cur_rel_fen_fd = 0;
+buf_sync_err_1:
+	for (i = 0; i < fence_cnt; i++)
+		sync_fence_put(mfd->acq_fen[i]);
+	mfd->acq_fen_cnt = 0;
+	mutex_unlock(&mfd->sync_mutex);
+#endif 
+
+	return ret;
+}
+
+static int msmfb_display_commit(struct fb_info *info,
+						unsigned long *argp)
+{
+	int ret;
+	struct mdp_display_commit disp_commit;
+	ret = copy_from_user(&disp_commit, argp,
+			sizeof(disp_commit));
+	if (ret) {
+		pr_err("%s:copy_from_user failed", __func__);
+		return ret;
+	}
+
+	ret = msm_fb_pan_display_ex(&disp_commit.var, info, disp_commit.wait_for_finish);
+
+	return ret;
+}
+
+static int msmfb_get_metadata(struct msm_fb_data_type *mfd,
+				struct msmfb_metadata *metadata_ptr)
+{
+	int ret = 0;
+	switch (metadata_ptr->op) {
+	case metadata_op_frame_rate:
+		metadata_ptr->data.panel_frame_rate =
+			mdp_get_panel_framerate(mfd);
+		break;
+	default:
+		pr_warn("Unsupported request to MDP META IOCTL.\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
 static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg)
 {
@@ -3503,12 +4082,14 @@ static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 #endif
 	struct mdp_page_protection fb_page_protection;
 	struct msmfb_mdp_pp mdp_pp;
+	struct mdp_buf_sync buf_sync;
+	struct msmfb_metadata mdp_metadata;
 	int ret = 0;
 
 
 	struct msmfb_usb_projector_info tmp_info;
 
-
+	msm_fb_pan_idle(mfd);
 	switch (cmd) {
 #ifdef CONFIG_FB_MSM_OVERLAY
 	case FBIO_WAITFORVSYNC:
@@ -3782,6 +4363,28 @@ static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 
 		ret = msmfb_handle_pp_ioctl(mfd, &mdp_pp);
 		break;
+	case MSMFB_BUFFER_SYNC:
+		ret = copy_from_user(&buf_sync, argp, sizeof(buf_sync));
+		if (ret)
+			return ret;
+
+		ret = msmfb_handle_buf_sync_ioctl(mfd, &buf_sync);
+
+		if (!ret)
+			ret = copy_to_user(argp, &buf_sync, sizeof(buf_sync));
+		break;
+	case MSMFB_DISPLAY_COMMIT:
+		ret = msmfb_display_commit(info, argp);
+
+	case MSMFB_METADATA_GET:
+		ret = copy_from_user(&mdp_metadata, argp, sizeof(mdp_metadata));
+		if (ret)
+			return ret;
+		ret = msmfb_get_metadata(mfd, &mdp_metadata);
+		if (!ret)
+			ret = copy_to_user(argp, &mdp_metadata,
+				sizeof(mdp_metadata));
+		break;
 
 	case MSMFB_GET_USB_PROJECTOR_INFO:
 		ret = copy_to_user(argp, &usb_pjt_info, sizeof(usb_pjt_info));
@@ -4026,7 +4629,7 @@ int get_fb_phys_info(unsigned long *start, unsigned long *len, int fb_num,
 	struct fb_info *info;
 	struct msm_fb_data_type *mfd;
 
-	if (fb_num > MAX_FBI_LIST ||
+	if (fb_num >= MAX_FBI_LIST ||
 		(subsys_id != DISPLAY_SUBSYSTEM_ID &&
 		 subsys_id != ROTATOR_SUBSYSTEM_ID)) {
 		pr_err("%s(): Invalid parameters\n", __func__);
diff --git a/drivers/video/msm/msm_fb.h b/drivers/video/msm/msm_fb.h
index 80398cb..6084aec 100644
--- a/drivers/video/msm/msm_fb.h
+++ b/drivers/video/msm/msm_fb.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2013, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -54,6 +54,7 @@ struct disp_info_type_suspend {
 	boolean op_enable;
 	boolean sw_refreshing_enable;
 	boolean panel_power_on;
+	boolean op_suspend;
 };
 
 struct msmfb_writeback_data_list {
@@ -127,6 +128,7 @@ struct msm_fb_data_type {
 	__u32 channel_irq;
 
 	struct mdp_dma_data *dma;
+	struct device_attribute dev_attr;
 	void (*dma_fnc) (struct msm_fb_data_type *mfd);
 	int (*cursor_update) (struct fb_info *info,
 			      struct fb_cursor *cursor);
@@ -136,6 +138,8 @@ struct msm_fb_data_type {
 			      struct mdp_histogram_data *hist);
 	int (*start_histogram) (struct mdp_histogram_start_req *req);
 	int (*stop_histogram) (struct fb_info *info, uint32_t block);
+	void (*vsync_init) (int cndx);
+	void *vsync_show;
 	void *cursor_buf;
 	void *cursor_buf_phys;
 
@@ -157,6 +161,12 @@ struct msm_fb_data_type {
 #endif 
 	__u32 var_frame_rate;
 
+	
+	int ovr_src_height;
+	int ovr_src_width;
+	int ovr_dst_height;
+	int ovr_dst_width;
+
 #ifdef MSM_FB_ENABLE_DBGFS
 	struct dentry *sub_dir;
 #endif
@@ -195,8 +205,39 @@ struct msm_fb_data_type {
 	u32 writeback_state;
 	bool writeback_active_cnt;
 	int cont_splash_done;
+
+	u32 acq_fen_cnt;
+	struct sync_fence *acq_fen[MDP_MAX_FENCE_FD];
+	int cur_rel_fen_fd;
+	struct sync_pt *cur_rel_sync_pt;
+	struct sync_fence *cur_rel_fence;
+	struct sync_fence *last_rel_fence;
+	struct sw_sync_timeline *timeline;
+	int timeline_value;
+	int vsync_sysfs_created;
+	u32 last_acq_fen_cnt;
+	struct sync_fence *last_acq_fen[MDP_MAX_FENCE_FD];
+	struct mutex sync_mutex;
+	struct completion commit_comp;
+	u32 is_committing;
+	struct work_struct commit_work;
+	void *msm_fb_backup;
+	
+	struct workqueue_struct *dimming_wq;
+	struct work_struct dimming_work;
+	struct timer_list dimming_update_timer;
+	struct workqueue_struct *sre_wq;
+	struct work_struct sre_work;
+	struct timer_list sre_update_timer;
 };
 
+struct msm_fb_backup_type {
+	struct fb_info info;
+	struct fb_var_screeninfo var;
+	struct msm_fb_data_type mfd;
+};
+
+
 struct dentry *msm_fb_get_debugfs_root(void);
 void msm_fb_debugfs_file_create(struct dentry *root, const char *name,
 				u32 *var);
@@ -214,8 +255,11 @@ int msm_fb_writeback_dequeue_buffer(struct fb_info *info,
 int msm_fb_writeback_terminate(struct fb_info *info);
 int msm_fb_detect_client(const char *name);
 int calc_fb_offset(struct msm_fb_data_type *mfd, struct fb_info *fbi, int bpp);
-void mdp_color_enhancement(const struct mdp_reg *reg_seq, int size);
+void msm_fb_wait_for_fence(struct msm_fb_data_type *mfd);
+int msm_fb_signal_timeline(struct msm_fb_data_type *mfd);
+void msm_fb_release_timeline(struct msm_fb_data_type *mfd);
 
+void mdp_color_enhancement(const struct mdp_reg *reg_seq, int size);
 #ifdef CONFIG_FB_BACKLIGHT
 void msm_fb_config_backlight(struct msm_fb_data_type *mfd);
 #endif
diff --git a/drivers/video/msm/msm_fb_panel.h b/drivers/video/msm/msm_fb_panel.h
index 7d86890..ea101f4 100644
--- a/drivers/video/msm/msm_fb_panel.h
+++ b/drivers/video/msm/msm_fb_panel.h
@@ -78,6 +78,9 @@ struct lcdc_panel_info {
 	
 	uint32 yres_pad;
 	boolean is_sync_active_high;
+	
+	__u32 no_set_tear;
+
 };
 
 struct mddi_panel_info {
@@ -131,6 +134,11 @@ struct mipi_panel_info {
 	char no_max_pkt_size;
 	
 	char force_clk_lane_hs;
+	
+	struct mipi_dsi_reg_set *dsi_reg_db;
+	uint32 dsi_reg_db_size;
+	
+	char force_leave_ulps;
 };
 
 enum lvds_mode {
@@ -166,6 +174,7 @@ struct msm_panel_info {
 	__u32 width;
 	__u32 height;
 	__u32 camera_backlight;
+	__u32 read_pointer;
 
 	struct mddi_panel_info mddi;
 	struct lcd_panel_info lcd;
@@ -195,17 +204,30 @@ struct msm_fb_panel_data {
 	int (*power_ctrl) (boolean enable);
 	struct platform_device *next;
 	int (*clk_func) (int enable);
+int (*fps_level_change) (struct platform_device *pdev,
+					u32 fps_level);
 #ifdef CONFIG_FB_MSM_CABC
 	int (*autobl_enable) (int on, struct msm_fb_data_type *);
 	void (*enable_cabc) (int, bool, struct msm_fb_data_type *);
 #endif
 	void (*color_enhance) (struct msm_fb_data_type *, int on);
+	void (*dimming_on) (struct msm_fb_data_type *);
+	void (*acl_enable) (int on, struct msm_fb_data_type *);
+	void (*set_cabc) (struct msm_fb_data_type *, int mode);
+	void (*sre_ctrl) (struct msm_fb_data_type *, unsigned long);
+#ifdef CONFIG_FB_MSM_ESD_WORKAROUND
+	int esd_workaround;
+#endif
 };
 
 struct platform_device *msm_fb_device_alloc(struct msm_fb_panel_data *pdata,
 						u32 type, u32 id);
 int panel_next_on(struct platform_device *pdev);
 int panel_next_off(struct platform_device *pdev);
+int panel_next_fps_level_change(struct platform_device *pdev,
+					u32 fps_level);
+int panel_next_late_init(struct platform_device *pdev);
+int panel_next_early_off(struct platform_device *pdev);
 
 int lcdc_device_register(struct msm_panel_info *pinfo);
 
@@ -213,3 +235,4 @@ int mddi_toshiba_device_register(struct msm_panel_info *pinfo,
 					u32 channel, u32 panel);
 
 #endif 
+
diff --git a/include/linux/msm_mdp.h b/include/linux/msm_mdp.h
index e209388..b0538d0 100644
--- a/include/linux/msm_mdp.h
+++ b/include/linux/msm_mdp.h
@@ -1,7 +1,7 @@
 /* include/linux/msm_mdp.h
  *
  * Copyright (C) 2007 Google Incorporated
- * Copyright (c) 2012 Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2013 The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -68,11 +68,17 @@
 #define MSMFB_WRITEBACK_TERMINATE _IO(MSMFB_IOCTL_MAGIC, 155)
 #define MSMFB_MDP_PP _IOWR(MSMFB_IOCTL_MAGIC, 156, struct msmfb_mdp_pp)
 
-#define MSMFB_OVERLAY_VSYNC_CTRL  _IOW(MSMFB_IOCTL_MAGIC, 160, unsigned int)
+#define MSMFB_OVERLAY_VSYNC_CTRL _IOW(MSMFB_IOCTL_MAGIC, 160, unsigned int)
+#define MSMFB_VSYNC_CTRL  _IOW(MSMFB_IOCTL_MAGIC, 161, unsigned int)
+#define MSMFB_BUFFER_SYNC  _IOW(MSMFB_IOCTL_MAGIC, 162, struct mdp_buf_sync)
 
+#define MSMFB_DISPLAY_COMMIT      _IOW(MSMFB_IOCTL_MAGIC, 164, \
+						struct mdp_display_commit)
+#define MSMFB_METADATA_GET  _IOW(MSMFB_IOCTL_MAGIC, 166, struct msmfb_metadata)
 
 #define MSMFB_GET_USB_PROJECTOR_INFO _IOR(MSMFB_IOCTL_MAGIC, 301, struct msmfb_usb_projector_info)
 #define MSMFB_SET_USB_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 302, struct msmfb_usb_projector_info)
+#define MSMFB_SET_DISP_PROJECTOR_INFO _IOW(MSMFB_IOCTL_MAGIC, 303, struct msmfb_disp_projector_info)
 
 
 #define FB_TYPE_3D_PANEL 0x10101010
@@ -85,6 +91,12 @@ struct msmfb_usb_projector_info {
 	int latest_offset;
 };
 
+struct msmfb_disp_projector_info {
+	int client_width;
+	int client_height;
+	int device_width;
+	int device_height;
+};
 
 enum {
 	NOTIFY_UPDATE_START,
@@ -460,6 +472,50 @@ struct msmfb_mdp_pp {
 	} data;
 };
 
+#define MDP_MAX_FENCE_FD	10
+#define MDP_BUF_SYNC_FLAG_WAIT	1
+
+struct mdp_buf_sync {
+	uint32_t flags;
+	uint32_t acq_fen_fd_cnt;
+	int *acq_fen_fd;
+	int *rel_fen_fd;
+};
+
+struct mdp_buf_fence {
+	uint32_t flags;
+	uint32_t acq_fen_fd_cnt;
+	int acq_fen_fd[MDP_MAX_FENCE_FD];
+	int rel_fen_fd[MDP_MAX_FENCE_FD];
+};
+
+#define MDP_DISPLAY_COMMIT_OVERLAY 0x00000001
+
+struct mdp_display_commit {
+	uint32_t flags;
+	uint32_t wait_for_finish;
+	struct fb_var_screeninfo var;
+};
+
+enum {
+	metadata_op_none,
+	metadata_op_base_blend,
+	metadata_op_frame_rate,
+	metadata_op_max
+};
+
+struct mdp_blend_cfg {
+	uint32_t is_premultiplied;
+};
+
+struct msmfb_metadata {
+	uint32_t op;
+	uint32_t flags;
+	union {
+		struct mdp_blend_cfg blend_cfg;
+		uint32_t panel_frame_rate;
+	} data;
+};
 
 struct mdp_page_protection {
 	uint32_t page_protection;
-- 
1.8.4

