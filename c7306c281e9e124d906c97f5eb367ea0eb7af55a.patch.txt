From c7306c281e9e124d906c97f5eb367ea0eb7af55a Mon Sep 17 00:00:00 2001
From: bilalliberty <bilal_liberty@live.com>
Date: Wed, 27 Nov 2013 21:49:58 +0300
Subject: [PATCH] ION: CAF

---
 arch/arm/include/asm/device.h                      |    6 +-
 arch/arm/include/asm/dma-iommu.h                   |   34 +
 arch/arm/mach-msm/board-pyramid.c                  |   15 +-
 arch/arm/mach-msm/devices-msm8x60.c                |    2 +-
 arch/arm/mach-msm/include/mach/board.h             |    9 +-
 arch/arm/mach-msm/include/mach/memory.h            |   18 +
 arch/arm/mach-msm/memory.c                         |   21 +
 arch/arm/mach-msm/qdsp6v2/audio_acdb.c             |    2 +-
 arch/arm/mach-msm/qdsp6v2/audio_lpa.c              |    2 +-
 arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c        |    3 +-
 arch/arm/mm/init.c                                 |    4 +-
 drivers/char/msm_rotator.c                         |    2 +-
 drivers/gpu/ion/Kconfig                            |    0
 drivers/gpu/ion/Makefile                           |    1 +
 drivers/gpu/ion/ion.c                              |  293 ++-
 drivers/gpu/ion/ion_carveout_heap.c                |  115 +-
 drivers/gpu/ion/ion_cma_heap.c                     |  358 +++
 drivers/gpu/ion/ion_cp_heap.c                      |   92 +-
 drivers/gpu/ion/ion_heap.c                         |   18 +-
 drivers/gpu/ion/ion_iommu_heap.c                   |  322 ++-
 drivers/gpu/ion/ion_priv.h                         |  143 +-
 drivers/gpu/ion/ion_system_heap.c                  |   43 +-
 drivers/gpu/ion/ion_system_mapper.c                |  114 +
 drivers/gpu/ion/msm/Makefile                       |    0
 drivers/gpu/ion/msm/ion_cp_common.c                |    2 +-
 drivers/gpu/ion/msm/ion_cp_common.h                |   16 +-
 drivers/gpu/ion/msm/msm_ion.c                      |  342 ++-
 drivers/gpu/ion/tegra/Makefile                     |    0
 drivers/gpu/ion/tegra/tegra_ion.c                  |   96 +
 drivers/gpu/msm/kgsl.h                             |    2 +-
 drivers/gpu/msm/kgsl_sharedmem.c                   |    2 +-
 .../media/video/msm/gemini/msm_gemini_platform.c   |    2 +-
 drivers/media/video/msm/msm_mem.c                  |    2 +-
 drivers/media/video/msm/wfd/Makefile               |    0
 drivers/media/video/msm/wfd/enc-subdev.c           |    6 +-
 drivers/media/video/msm/wfd/enc-subdev.h           |    2 +-
 drivers/media/video/msm/wfd/mdp-subdev.c           |    0
 drivers/media/video/msm/wfd/mdp-subdev.h           |    0
 drivers/media/video/msm/wfd/vsg-subdev.c           |    0
 drivers/media/video/msm/wfd/vsg-subdev.h           |    0
 drivers/media/video/msm/wfd/wfd-ioctl.c            |    4 +-
 drivers/media/video/msm/wfd/wfd-util.c             |    0
 drivers/media/video/msm/wfd/wfd-util.h             |    0
 drivers/media/video/videobuf2-msm-mem.c            |    8 +-
 drivers/staging/android/lowmemorykiller.c          |    2 -
 drivers/video/msm/mdp.h                            |    2 +-
 drivers/video/msm/mdp4_util.c                      |    3 +-
 drivers/video/msm/msm_fb.c                         |    2 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c         |   41 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h         |   74 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_api.h     |    2 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h    |   10 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c  |   19 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c  |  416 ++-
 .../msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c |  153 +-
 .../video/msm/vidc/1080p/ddl/vcd_ddl_metadata.c    |  131 +-
 .../video/msm/vidc/1080p/ddl/vcd_ddl_metadata.h    |    4 +-
 .../video/msm/vidc/1080p/ddl/vcd_ddl_properties.c  |  461 +++-
 .../video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c  |  142 +-
 .../video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h  |   11 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c   |   21 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h   |   16 +-
 drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c    |   95 +-
 drivers/video/msm/vidc/1080p/ddl/vidc.c            |  155 +-
 drivers/video/msm/vidc/1080p/ddl/vidc.h            |   34 +-
 drivers/video/msm/vidc/1080p/ddl/vidc_hwio.h       |   19 +-
 drivers/video/msm/vidc/1080p/ddl/vidc_hwio_reg.h   |   36 +-
 drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c  |    6 +-
 drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.h  |    2 +-
 .../vidc/1080p/resource_tracker/vcd_res_tracker.c  |  136 +-
 .../vidc/1080p/resource_tracker/vcd_res_tracker.h  |   31 +-
 .../1080p/resource_tracker/vcd_res_tracker_api.h   |    4 +-
 drivers/video/msm/vidc/720p/ddl/vcd_ddl.c          |  637 +++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl.h          |  294 +++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_api.h      |   53 +
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_core.h     |   99 +
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_errors.c   |  612 +++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.c |  352 +++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.h |   53 +
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_hal.c      |  971 +++++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_helper.c   |  297 +++
 .../msm/vidc/720p/ddl/vcd_ddl_internal_property.h  |   81 +
 .../msm/vidc/720p/ddl/vcd_ddl_interrupt_handler.c  | 1128 ++++++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.c |  580 +++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.h |   79 +
 .../video/msm/vidc/720p/ddl/vcd_ddl_properties.c   | 1943 ++++++++++++++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c    |  317 +++
 drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h    |   60 +
 drivers/video/msm/vidc/720p/ddl/vidc.c             |  804 ++++++
 drivers/video/msm/vidc/720p/ddl/vidc.h             | 2705 ++++++++++++++++++++
 .../vidc/720p/resource_tracker/vcd_res_tracker.c   |  807 ++++++
 .../vidc/720p/resource_tracker/vcd_res_tracker.h   |   60 +
 .../720p/resource_tracker/vcd_res_tracker_api.h    |   44 +
 drivers/video/msm/vidc/common/dec/vdec.c           |  674 ++++-
 drivers/video/msm/vidc/common/dec/vdec_internal.h  |    2 +-
 drivers/video/msm/vidc/common/enc/venc.c           |  609 ++++-
 drivers/video/msm/vidc/common/enc/venc_internal.c  |  372 ++-
 drivers/video/msm/vidc/common/enc/venc_internal.h  |   25 +-
 drivers/video/msm/vidc/common/init/vidc_init.c     |  160 +-
 .../msm/vidc/common/init/vidc_init_internal.h      |    2 +-
 drivers/video/msm/vidc/common/vcd/vcd.h            |   11 +-
 drivers/video/msm/vidc/common/vcd/vcd_api.c        |   31 +-
 drivers/video/msm/vidc/common/vcd/vcd_client_sm.c  |   50 +-
 drivers/video/msm/vidc/common/vcd/vcd_client_sm.h  |    2 +-
 drivers/video/msm/vidc/common/vcd/vcd_core.h       |    6 +-
 drivers/video/msm/vidc/common/vcd/vcd_device_sm.c  |   14 +-
 drivers/video/msm/vidc/common/vcd/vcd_device_sm.h  |    2 +-
 drivers/video/msm/vidc/common/vcd/vcd_power_sm.c   |   44 +-
 drivers/video/msm/vidc/common/vcd/vcd_power_sm.h   |    2 +-
 drivers/video/msm/vidc/common/vcd/vcd_scheduler.c  |   35 +-
 drivers/video/msm/vidc/common/vcd/vcd_sub.c        |  240 +-
 drivers/video/msm/vidc/common/vcd/vcd_util.c       |  106 +
 drivers/video/msm/vidc/common/vcd/vcd_util.h       |   33 +-
 fs/proc/meminfo.c                                  |   86 +-
 include/asm-generic/dma-coherent.h                 |    9 +
 include/asm-generic/pci-dma-compat.h               |   16 +-
 include/linux/device.h                             |    1 +
 include/linux/dma-attrs.h                          |   27 +-
 include/linux/ion.h                                |  535 ++--
 include/linux/msm_ion.h                            |  320 ++-
 include/linux/msm_vidc_dec.h                       |   79 +-
 include/linux/msm_vidc_enc.h                       |  347 ++-
 include/media/msm/vcd_api.h                        |    9 +-
 include/media/msm/vcd_property.h                   |   71 +-
 include/media/msm/vcd_status.h                     |    3 +-
 include/media/msm/vidc_init.h                      |   16 +-
 include/media/msm/vidc_type.h                      |    2 +-
 mm/oom_kill.c                                      |  246 +-
 sound/soc/msm/qdsp6/q6asm.c                        |   11 +-
 130 files changed, 18861 insertions(+), 1444 deletions(-)
 create mode 100644 arch/arm/include/asm/dma-iommu.h
 mode change 100644 => 100755 drivers/gpu/ion/Kconfig
 mode change 100644 => 100755 drivers/gpu/ion/Makefile
 mode change 100644 => 100755 drivers/gpu/ion/ion.c
 mode change 100644 => 100755 drivers/gpu/ion/ion_carveout_heap.c
 create mode 100755 drivers/gpu/ion/ion_cma_heap.c
 mode change 100644 => 100755 drivers/gpu/ion/ion_cp_heap.c
 mode change 100644 => 100755 drivers/gpu/ion/ion_heap.c
 mode change 100644 => 100755 drivers/gpu/ion/ion_iommu_heap.c
 mode change 100644 => 100755 drivers/gpu/ion/ion_priv.h
 mode change 100644 => 100755 drivers/gpu/ion/ion_system_heap.c
 create mode 100755 drivers/gpu/ion/ion_system_mapper.c
 mode change 100644 => 100755 drivers/gpu/ion/msm/Makefile
 mode change 100644 => 100755 drivers/gpu/ion/msm/ion_cp_common.c
 mode change 100644 => 100755 drivers/gpu/ion/msm/ion_cp_common.h
 mode change 100644 => 100755 drivers/gpu/ion/msm/msm_ion.c
 mode change 100644 => 100755 drivers/gpu/ion/tegra/Makefile
 create mode 100755 drivers/gpu/ion/tegra/tegra_ion.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/Makefile
 mode change 100755 => 100644 drivers/media/video/msm/wfd/enc-subdev.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/enc-subdev.h
 mode change 100755 => 100644 drivers/media/video/msm/wfd/mdp-subdev.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/mdp-subdev.h
 mode change 100755 => 100644 drivers/media/video/msm/wfd/vsg-subdev.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/vsg-subdev.h
 mode change 100755 => 100644 drivers/media/video/msm/wfd/wfd-ioctl.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/wfd-util.c
 mode change 100755 => 100644 drivers/media/video/msm/wfd/wfd-util.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_api.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_core.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_errors.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_hal.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_helper.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_internal_property.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_interrupt_handler.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_properties.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vidc.c
 create mode 100644 drivers/video/msm/vidc/720p/ddl/vidc.h
 create mode 100644 drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c
 create mode 100644 drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.h
 create mode 100644 drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h
 create mode 100644 drivers/video/msm/vidc/common/vcd/vcd_util.c

diff --git a/arch/arm/include/asm/device.h b/arch/arm/include/asm/device.h
index 0f8aacd..b69c0d3 100644
--- a/arch/arm/include/asm/device.h
+++ b/arch/arm/include/asm/device.h
@@ -7,11 +7,15 @@
 #define ASMARM_DEVICE_H
 
 struct dev_archdata {
+	struct dma_map_ops	*dma_ops;
 #ifdef CONFIG_DMABOUNCE
 	struct dmabounce_device_info *dmabounce;
 #endif
 #ifdef CONFIG_IOMMU_API
-	void *iommu; 
+	void *iommu; /* private IOMMU data */
+#endif
+#ifdef CONFIG_ARM_DMA_USE_IOMMU
+	struct dma_iommu_mapping	*mapping;
 #endif
 };
 
diff --git a/arch/arm/include/asm/dma-iommu.h b/arch/arm/include/asm/dma-iommu.h
new file mode 100644
index 0000000..799b094
--- /dev/null
+++ b/arch/arm/include/asm/dma-iommu.h
@@ -0,0 +1,34 @@
+#ifndef ASMARM_DMA_IOMMU_H
+#define ASMARM_DMA_IOMMU_H
+
+#ifdef __KERNEL__
+
+#include <linux/mm_types.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-debug.h>
+#include <linux/kmemcheck.h>
+
+struct dma_iommu_mapping {
+	/* iommu specific data */
+	struct iommu_domain	*domain;
+
+	void			*bitmap;
+	size_t			bits;
+	unsigned int		order;
+	dma_addr_t		base;
+
+	spinlock_t		lock;
+	struct kref		kref;
+};
+
+struct dma_iommu_mapping *
+arm_iommu_create_mapping(struct bus_type *bus, dma_addr_t base, size_t size,
+			 int order);
+
+void arm_iommu_release_mapping(struct dma_iommu_mapping *mapping);
+
+int arm_iommu_attach_device(struct device *dev,
+					struct dma_iommu_mapping *mapping);
+
+#endif /* __KERNEL__ */
+#endif
diff --git a/arch/arm/mach-msm/board-pyramid.c b/arch/arm/mach-msm/board-pyramid.c
index 732a000..99dc76f 100644
--- a/arch/arm/mach-msm/board-pyramid.c
+++ b/arch/arm/mach-msm/board-pyramid.c
@@ -131,7 +131,7 @@
 
 #include <linux/memblock.h>
 #include <linux/clk.h>
-
+#include <linux/msm_ion.h>
 #define PHY_BASE_ADDR1       0x48000000
 #define SIZE_ADDR1           0x28000000
 
@@ -2679,9 +2679,9 @@ static void __init pm8901_vreg_mpp0_init(void)
 	.align = PAGE_SIZE,
 };
 
-static struct ion_platform_data ion_pdata = {
-	.nr = MSM_ION_HEAP_NUM,
-	.heaps = {
+struct ion_platform_heap msm8660_heaps[] = {
+
+
 		{
 			.id	= ION_SYSTEM_HEAP_ID,
 			.type	= ION_HEAP_TYPE_SYSTEM,
@@ -2749,7 +2749,12 @@ static void __init pm8901_vreg_mpp0_init(void)
 			.memory_type = ION_EBI_TYPE,
 			.extra_data = &co_ion_pdata,
 		},
-	}
+	
+};
+
+static struct ion_platform_data ion_pdata = {
+        .nr = MSM_ION_HEAP_NUM,
+        .heaps = msm8660_heaps,
 };
 
 static struct platform_device ion_dev = {
diff --git a/arch/arm/mach-msm/devices-msm8x60.c b/arch/arm/mach-msm/devices-msm8x60.c
index f3b7b1d..a618b28 100644
--- a/arch/arm/mach-msm/devices-msm8x60.c
+++ b/arch/arm/mach-msm/devices-msm8x60.c
@@ -16,7 +16,7 @@
 #include <linux/regulator/machine.h>
 #include <linux/regulator/consumer.h>
 #include <linux/mfd/pmic8058.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <mach/irqs.h>
 #include <mach/dma.h>
 #include <asm/mach/mmc.h>
diff --git a/arch/arm/mach-msm/include/mach/board.h b/arch/arm/mach-msm/include/mach/board.h
index 204a0ac..04ff56d 100644
--- a/arch/arm/mach-msm/include/mach/board.h
+++ b/arch/arm/mach-msm/include/mach/board.h
@@ -313,7 +313,11 @@ enum msm_camera_pixel_order_default {
 	MSM_CAMERA_PIXEL_ORDER_BG,
 	MSM_CAMERA_PIXEL_ORDER_GB,
 };
-
+enum sensor_mount_angle {
+	ANGLE_90,
+	ANGLE_180,
+	ANGLE_270,
+};
 struct msm_camera_sensor_platform_info {
 	int mount_angle;
 	int sensor_reset;
@@ -332,6 +336,8 @@ struct msm_camera_sensor_platform_info {
 	enum msm_camera_pixel_order_default pixel_order_default;	
 	enum sensor_flip_mirror_info mirror_flip;
 	void *privacy_light_info;
+	enum sensor_mount_angle sensor_mount_angle; 
+	bool ews_enable;
 	
 };
 
@@ -691,6 +697,7 @@ struct msm_vidc_platform_data {
 	int disable_fullhd;
 	u32 cp_enabled;
 	u32 secure_wb_heap;
+	u32 enable_sec_metadata;
 #ifdef CONFIG_MSM_BUS_SCALING
 	struct msm_bus_scale_pdata *vidc_bus_client_pdata;
 #endif
diff --git a/arch/arm/mach-msm/include/mach/memory.h b/arch/arm/mach-msm/include/mach/memory.h
index ecf53f8..cafdc9a 100644
--- a/arch/arm/mach-msm/include/mach/memory.h
+++ b/arch/arm/mach-msm/include/mach/memory.h
@@ -67,6 +67,7 @@
 int platform_physical_remove_pages(u64, u64);
 int platform_physical_active_pages(u64, u64);
 int platform_physical_low_power_pages(u64, u64);
+int msm_get_memory_type_from_name(const char *memtype_name);
 
 extern int (*change_memory_power)(u64, u64, int);
 
@@ -107,6 +108,23 @@
 	(virt) - MEMBANK0_PAGE_OFFSET + MEMBANK0_PHYS_OFFSET)
 #endif
 
+/*
+ * Need a temporary unique variable that no one will ever see to
+ * hold the compat string. Line number gives this easily.
+ * Need another layer of indirection to get __LINE__ to expand
+ * properly as opposed to appending and ending up with
+ * __compat___LINE__
+ */
+#define __CONCAT(a, b)	___CONCAT(a, b)
+#define ___CONCAT(a, b)	a ## b
+
+#define EXPORT_COMPAT(com)	\
+static char *__CONCAT(__compat_, __LINE__)  __used \
+	__attribute((__section__(".exportcompat.init"))) = com
+
+extern char *__compat_exports_start[];
+extern char *__compat_exports_end[];
+
 #endif
 
 #if defined CONFIG_ARCH_MSM_SCORPION || defined CONFIG_ARCH_MSM_KRAIT
diff --git a/arch/arm/mach-msm/memory.c b/arch/arm/mach-msm/memory.c
index 45edbc5..45e0d5c 100644
--- a/arch/arm/mach-msm/memory.c
+++ b/arch/arm/mach-msm/memory.c
@@ -353,3 +353,24 @@ int release_fmem_c_region(void *unused)
 {
 	return fmem_set_state(FMEM_T_STATE);
 }
+
+static char * const memtype_names[] = {
+	[MEMTYPE_SMI_KERNEL] = "SMI_KERNEL",
+	[MEMTYPE_SMI]	= "SMI",
+	[MEMTYPE_EBI0] = "EBI0",
+	[MEMTYPE_EBI1] = "EBI1",
+};
+
+int msm_get_memory_type_from_name(const char *memtype_name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(memtype_names); i++) {
+		if (memtype_names[i] &&
+		    strcmp(memtype_name, memtype_names[i]) == 0)
+			return i;
+	}
+
+	pr_err("Could not find memory type %s\n", memtype_name);
+	return -EINVAL;
+}
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_acdb.c b/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
index af077b0..e2d053a 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
@@ -666,7 +666,7 @@ static int register_memory(void)
 	}
 
 	kvptr = ion_map_kernel(acdb_data.ion_client,
-		acdb_data.ion_handle, 0);
+		acdb_data.ion_handle);
 	if (IS_ERR_OR_NULL(kvptr)) {
 		pr_err("%s: Could not get kernel virt addr!!!\n", __func__);
 		result = PTR_ERR(kvptr);
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
index 2fa6164..1dbefef 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
@@ -487,7 +487,7 @@ static int audlpa_ion_add(struct audio *audio,
 		goto flag_error;
 	}
 
-	temp_ptr = ion_map_kernel(audio->client, handle, ionflag);
+	temp_ptr = ion_map_kernel(audio->client, handle);
 	if (IS_ERR_OR_NULL(temp_ptr)) {
 		pr_err("%s: could not get virtual address\n", __func__);
 		goto map_error;
diff --git a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
index 3755036..d7d0765 100644
--- a/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
+++ b/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
@@ -740,7 +740,7 @@ static int audio_aio_ion_add(struct q6audio_aio *audio,
 		goto flag_error;
 	}
 
-	temp_ptr = ion_map_kernel(audio->client, handle, ionflag);
+	temp_ptr = ion_map_kernel(audio->client, handle);
 	if (IS_ERR_OR_NULL(temp_ptr)) {
 		pr_err("%s: could not get virtual address\n", __func__);
 		goto map_error;
@@ -1157,7 +1157,6 @@ long audio_aio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		
 		stats.byte_count = atomic_read(&audio->in_bytes);
 		stats.sample_count = atomic_read(&audio->in_samples);
-		timestamp = q6asm_get_session_time(audio->ac);
 		memcpy(&stats.unused[0], &timestamp, sizeof(timestamp));
 		if (copy_to_user((void *)arg, &stats, sizeof(stats)))
 			rc = -EFAULT;
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index f3fe30d..7aefddf 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -97,8 +97,8 @@ void show_mem(unsigned int filter)
 	int free = 0, total = 0, reserved = 0;
 	int shared = 0, cached = 0, slab = 0, i;
 	struct meminfo * mi = &meminfo;
-	unsigned long kgsl_alloc = kgsl_get_alloc_size(0);
-	int ion_alloc = ion_iommu_heap_dump_size();
+	unsigned long kgsl_alloc = 0;
+	int ion_alloc = 0;
 
 	printk("Mem-info:\n");
 	show_free_areas(filter);
diff --git a/drivers/char/msm_rotator.c b/drivers/char/msm_rotator.c
index 615f003..a287f53 100644
--- a/drivers/char/msm_rotator.c
+++ b/drivers/char/msm_rotator.c
@@ -28,7 +28,7 @@
 #include <linux/file.h>
 #include <linux/major.h>
 #include <linux/regulator/consumer.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #ifdef CONFIG_MSM_BUS_SCALING
 #include <mach/msm_bus.h>
 #include <mach/msm_bus_board.h>
diff --git a/drivers/gpu/ion/Kconfig b/drivers/gpu/ion/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/gpu/ion/Makefile b/drivers/gpu/ion/Makefile
old mode 100644
new mode 100755
index c9e8a94..51349f6
--- a/drivers/gpu/ion/Makefile
+++ b/drivers/gpu/ion/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_ION) +=	ion.o ion_heap.o ion_system_heap.o ion_carveout_heap.o ion_iommu_heap.o ion_cp_heap.o
+obj-$(CONFIG_CMA) += ion_cma_heap.o
 obj-$(CONFIG_ION_TEGRA) += tegra/
 obj-$(CONFIG_ION_MSM) += msm/
diff --git a/drivers/gpu/ion/ion.c b/drivers/gpu/ion/ion.c
old mode 100644
new mode 100755
index e5a6d1d..e9b3bb3
--- a/drivers/gpu/ion/ion.c
+++ b/drivers/gpu/ion/ion.c
@@ -2,7 +2,7 @@
  * drivers/gpu/ion/ion.c
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -39,6 +39,14 @@
 #include "ion_priv.h"
 #define DEBUG
 
+/**
+ * struct ion_device - the metadata of the ion device node
+ * @dev:		the actual misc device
+ * @buffers:	an rb tree of all the existing buffers
+ * @lock:		lock protecting the buffers & heaps trees
+ * @heaps:		list of all the heaps in the system
+ * @user_clients:	list of all the clients created from userspace
+ */
 struct ion_device {
 	struct miscdevice dev;
 	struct rb_root buffers;
@@ -50,6 +58,20 @@ struct ion_device {
 	struct dentry *debug_root;
 };
 
+/**
+ * struct ion_client - a process/hw block local address space
+ * @node:		node in the tree of all clients
+ * @dev:		backpointer to ion device
+ * @handles:		an rb tree of all the handles in this client
+ * @lock:		lock protecting the tree of handles
+ * @heap_mask:		mask of all supported heaps
+ * @name:		used for debugging
+ * @task:		used for debugging
+ *
+ * A client represents a list of buffers this client may access.
+ * The mutex stored here is used to protect both handles tree
+ * as well as the handles themselves, and should be held while modifying either.
+ */
 struct ion_client {
 	struct rb_node node;
 	struct ion_device *dev;
@@ -62,6 +84,18 @@ struct ion_client {
 	struct dentry *debug_root;
 };
 
+/**
+ * ion_handle - a client local reference to a buffer
+ * @ref:		reference count
+ * @client:		back pointer to the client the buffer resides in
+ * @buffer:		pointer to the buffer
+ * @node:		node in the client's handle rbtree
+ * @kmap_cnt:		count of times this client has mapped to kernel
+ * @dmap_cnt:		count of times this client has mapped for dma
+ *
+ * Modifications to node, map_cnt or mapping should be protected by the
+ * lock in the client.  Other fields are never changed after initialization.
+ */
 struct ion_handle {
 	struct kref ref;
 	struct ion_client *client;
@@ -73,24 +107,7 @@ struct ion_handle {
 
 static void ion_iommu_release(struct kref *kref);
 
-static int ion_validate_buffer_flags(struct ion_buffer *buffer,
-					unsigned long flags)
-{
-	if (buffer->kmap_cnt || buffer->dmap_cnt || buffer->umap_cnt ||
-		buffer->iommu_map_cnt) {
-		if (buffer->flags != flags) {
-			pr_err("%s: buffer was already mapped with flags %lx,"
-				" cannot map with flags %lx\n", __func__,
-				buffer->flags, flags);
-			return 1;
-		}
-
-	} else {
-		buffer->flags = flags;
-	}
-	return 0;
-}
-
+/* this function should only be called while dev->lock is held */
 static void ion_buffer_add(struct ion_device *dev,
 			   struct ion_buffer *buffer)
 {
@@ -171,6 +188,7 @@ static struct ion_iommu_map *ion_iommu_lookup(struct ion_buffer *buffer,
 	return NULL;
 }
 
+/* this function should only be called while dev->lock is held */
 static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 				     struct ion_device *dev,
 				     unsigned long len,
@@ -196,6 +214,7 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 
 	buffer->dev = dev;
 	buffer->size = len;
+	buffer->flags = flags;
 
 	table = buffer->heap->ops->map_dma(buffer->heap, buffer);
 	if (IS_ERR_OR_NULL(table)) {
@@ -210,6 +229,10 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 	return buffer;
 }
 
+/**
+ * Check for delayed IOMMU unmapping. Also unmap any outstanding
+ * mappings which would otherwise have been leaked.
+ */
 static void ion_iommu_delayed_unmap(struct ion_buffer *buffer)
 {
 	struct ion_iommu_map *iommu_map;
@@ -230,7 +253,7 @@ static void ion_iommu_delayed_unmap(struct ion_buffer *buffer)
 				__func__, iommu_map->domain_info[DI_DOMAIN_NUM],
 				iommu_map->domain_info[DI_PARTITION_NUM]);
 		}
-		
+		/* set ref count to 1 to force release */
 		kref_init(&iommu_map->ref);
 		kref_put(&iommu_map->ref, ion_iommu_release);
 	}
@@ -249,10 +272,10 @@ static void ion_buffer_destroy(struct kref *kref)
 	buffer->heap->ops->unmap_dma(buffer->heap, buffer);
 
 	ion_iommu_delayed_unmap(buffer);
+	buffer->heap->ops->free(buffer);
 	mutex_lock(&dev->lock);
 	rb_erase(&buffer->node, &dev->buffers);
 	mutex_unlock(&dev->lock);
-	buffer->heap->ops->free(buffer);
 	kfree(buffer);
 }
 
@@ -372,7 +395,8 @@ static void ion_handle_add(struct ion_client *client, struct ion_handle *handle)
 }
 
 struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
-			     size_t align, unsigned int flags)
+			     size_t align, unsigned int heap_mask,
+			     unsigned int flags)
 {
 	struct rb_node *n;
 	struct ion_handle *handle;
@@ -385,6 +409,12 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 
 	dbg_str[0] = '\0';
 
+	/*
+	 * traverse the list of heaps available in this system in priority
+	 * order.  If the heap type is supported by the client, and matches the
+	 * request of the caller allocate from it.  Repeat until allocate has
+	 * succeeded or all heaps have been tried
+	 */
 	if (WARN_ON(!len))
 		return ERR_PTR(-EINVAL);
 
@@ -393,14 +423,15 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 	mutex_lock(&dev->lock);
 	for (n = rb_first(&dev->heaps); n != NULL; n = rb_next(n)) {
 		struct ion_heap *heap = rb_entry(n, struct ion_heap, node);
-		
+		/* if the client doesn't support this heap type */
 		if (!((1 << heap->type) & client->heap_mask))
 			continue;
-		
-		if (!((1 << heap->id) & flags))
+		/* if the caller didn't specify this heap type */
+		if (!((1 << heap->id) & heap_mask))
 			continue;
-		
-		if (secure_allocation && (heap->type != ION_HEAP_TYPE_CP))
+		/* Do not allow un-secure heap if secure is specified */
+		if (secure_allocation &&
+			(heap->type != (enum ion_heap_type) ION_HEAP_TYPE_CP))
 			continue;
 		buffer = ion_buffer_create(heap, dev, len, align, flags);
 		if (!IS_ERR_OR_NULL(buffer))
@@ -410,13 +441,13 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 			int ret_value = snprintf(&dbg_str[dbg_str_idx],
 						len_left, "%s ", heap->name);
 			if (ret_value >= len_left) {
-				
+				/* overflow */
 				dbg_str[MAX_DBG_STR_LEN-1] = '\0';
 				dbg_str_idx = MAX_DBG_STR_LEN;
 			} else if (ret_value >= 0) {
 				dbg_str_idx += ret_value;
 			} else {
-				
+				/* error */
 				dbg_str[MAX_DBG_STR_LEN-1] = '\0';
 			}
 		}
@@ -434,9 +465,12 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 		return ERR_PTR(PTR_ERR(buffer));
 	}
 
-	buffer->creator = client;
 	handle = ion_handle_create(client, buffer);
 
+	/*
+	 * ion_buffer_create will create a buffer with a ref_cnt of 1,
+	 * and ion_handle_create will take a second reference, drop one here
+	 */
 	ion_buffer_put(buffer);
 
 	if (!IS_ERR(handle)) {
@@ -616,6 +650,10 @@ int ion_map_iommu(struct ion_client *client, struct ion_handle *handle,
 		goto out;
 	}
 
+	/*
+	 * If clients don't want a custom iova length, just use whatever
+	 * the buffer size is
+	 */
 	if (!iova_length)
 		iova_length = buffer->size;
 
@@ -718,8 +756,7 @@ void ion_unmap_iommu(struct ion_client *client, struct ion_handle *handle,
 }
 EXPORT_SYMBOL(ion_unmap_iommu);
 
-void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle,
-			unsigned long flags)
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle)
 {
 	struct ion_buffer *buffer;
 	void *vaddr;
@@ -741,11 +778,6 @@ void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle,
 		return ERR_PTR(-ENODEV);
 	}
 
-	if (ion_validate_buffer_flags(buffer, flags)) {
-		mutex_unlock(&client->lock);
-		return ERR_PTR(-EEXIST);
-	}
-
 	mutex_lock(&buffer->lock);
 	vaddr = ion_handle_kmap_get(handle);
 	mutex_unlock(&buffer->lock);
@@ -832,7 +864,7 @@ static int ion_debug_client_show(struct seq_file *s, void *unused)
 
 		if (type == ION_HEAP_TYPE_SYSTEM_CONTIG ||
 			type == ION_HEAP_TYPE_CARVEOUT ||
-			type == ION_HEAP_TYPE_CP)
+			type == (enum ion_heap_type) ION_HEAP_TYPE_CP)
 			seq_printf(s, " : %12lx", handle->buffer->priv_phys);
 		else
 			seq_printf(s, " : %12s", "N/A");
@@ -886,6 +918,8 @@ struct ion_client *ion_client_create(struct ion_device *dev,
 	get_task_struct(current->group_leader);
 	task_lock(current->group_leader);
 	pid = task_pid_nr(current->group_leader);
+	/* don't bother to store task struct for kernel threads,
+	   they can't be killed anyway */
 	if (current->group_leader->flags & PF_KTHREAD) {
 		put_task_struct(current->group_leader);
 		task = NULL;
@@ -938,7 +972,6 @@ struct ion_client *ion_client_create(struct ion_device *dev,
 						 &debug_client_fops);
 	mutex_unlock(&dev->lock);
 
-	pr_info("%s: create ion_client (%s) at %p\n", __func__, client->name, client);
 	return client;
 }
 
@@ -947,13 +980,11 @@ void ion_client_destroy(struct ion_client *client)
 	struct ion_device *dev = client->dev;
 	struct rb_node *n;
 
-	pr_info("%s: destroy ion_client %p (%s)\n", __func__, client, client->name);
+	pr_debug("%s: %d\n", __func__, __LINE__);
 	while ((n = rb_first(&client->handles))) {
 		struct ion_handle *handle = rb_entry(n, struct ion_handle,
 						     node);
-		mutex_lock(&client->lock);
 		ion_handle_destroy(&handle->ref);
-		mutex_unlock(&client->lock);
 	}
 	mutex_lock(&dev->lock);
 	if (client->task)
@@ -1088,7 +1119,7 @@ static int ion_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
 	}
 
 	mutex_lock(&buffer->lock);
-	
+	/* now map it to userspace */
 	ret = buffer->heap->ops->map_user(buffer->heap, buffer, vma);
 
 	if (ret) {
@@ -1100,6 +1131,10 @@ static int ion_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
 		mutex_unlock(&buffer->lock);
 
 		vma->vm_ops = &ion_vm_ops;
+		/*
+		 * move the buffer into the vm_private_data so we can access it
+		 * from vma_open/close
+		 */
 		vma->vm_private_data = buffer;
 	}
 	return ret;
@@ -1176,9 +1211,12 @@ static int ion_share_set_flags(struct ion_client *client,
 {
 	struct ion_buffer *buffer;
 	bool valid_handle;
-	unsigned long ion_flags = ION_SET_CACHE(CACHED);
+	unsigned long ion_flags = 0;
 	if (flags & O_DSYNC)
-		ion_flags = ION_SET_CACHE(UNCACHED);
+		ion_flags = ION_SET_UNCACHED(ion_flags);
+	else
+		ion_flags = ION_SET_CACHED(ion_flags);
+
 
 	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
@@ -1190,12 +1228,6 @@ static int ion_share_set_flags(struct ion_client *client,
 
 	buffer = handle->buffer;
 
-	mutex_lock(&buffer->lock);
-	if (ion_validate_buffer_flags(buffer, ion_flags)) {
-		mutex_unlock(&buffer->lock);
-		return -EEXIST;
-	}
-	mutex_unlock(&buffer->lock);
 	return 0;
 }
 
@@ -1239,7 +1271,7 @@ struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd)
 	dmabuf = dma_buf_get(fd);
 	if (IS_ERR_OR_NULL(dmabuf))
 		return ERR_PTR(PTR_ERR(dmabuf));
-	
+	/* if this memory came from ion */
 
 	if (dmabuf->ops != &dma_buf_ops) {
 		pr_err("%s: can not import dmabuf from another exporter\n",
@@ -1250,7 +1282,7 @@ struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd)
 	buffer = dmabuf->priv;
 
 	mutex_lock(&client->lock);
-	
+	/* if a handle exists for this buffer just take a reference to it */
 	handle = ion_handle_lookup(client, buffer);
 	if (!IS_ERR_OR_NULL(handle)) {
 		ion_handle_get(handle);
@@ -1279,7 +1311,25 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
 			return -EFAULT;
 		data.handle = ion_alloc(client, data.len, data.align,
-					     data.flags);
+					     data.heap_mask, data.flags);
+
+		if (IS_ERR(data.handle))
+			return PTR_ERR(data.handle);
+
+		if (copy_to_user((void __user *)arg, &data, sizeof(data))) {
+			ion_free(client, data.handle);
+			return -EFAULT;
+		}
+		break;
+	}
+	case ION_IOC_ALLOC_COMPAT:
+	{
+		struct ion_allocation_data_compat data;
+
+		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+			return -EFAULT;
+		data.handle = ion_alloc(client, data.len, data.align,
+					     ion_full_heap_mask, 0);
 
 		if (IS_ERR(data.handle))
 			return PTR_ERR(data.handle);
@@ -1326,6 +1376,7 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		break;
 	}
 	case ION_IOC_IMPORT:
+	case ION_IOC_IMPORT_COMPAT:
 	{
 		struct ion_fd_data data;
 		int ret = 0;
@@ -1333,8 +1384,10 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 				   sizeof(struct ion_fd_data)))
 			return -EFAULT;
 		data.handle = ion_import_dma_buf(client, data.fd);
-		if (IS_ERR(data.handle))
+		if (IS_ERR(data.handle)) {
+			ret = PTR_ERR(data.handle);
 			data.handle = NULL;
+		}
 		if (copy_to_user((void __user *)arg, &data,
 				 sizeof(struct ion_fd_data)))
 			return -EFAULT;
@@ -1354,20 +1407,20 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 		return dev->custom_ioctl(client, data.cmd, data.arg);
 	}
-	case ION_IOC_CLEAN_CACHES_OLD:
 	case ION_IOC_CLEAN_CACHES:
+	case ION_IOC_CLEAN_CACHES_COMPAT:
 		return client->dev->custom_ioctl(client,
 						ION_IOC_CLEAN_CACHES, arg);
-	case ION_IOC_INV_CACHES_OLD:
 	case ION_IOC_INV_CACHES:
+	case ION_IOC_INV_CACHES_COMPAT:
 		return client->dev->custom_ioctl(client,
 						ION_IOC_INV_CACHES, arg);
-	case ION_IOC_CLEAN_INV_CACHES_OLD:
 	case ION_IOC_CLEAN_INV_CACHES:
+	case ION_IOC_CLEAN_INV_CACHES_COMPAT:
 		return client->dev->custom_ioctl(client,
 						ION_IOC_CLEAN_INV_CACHES, arg);
-	case ION_IOC_GET_FLAGS_OLD:
 	case ION_IOC_GET_FLAGS:
+	case ION_IOC_GET_FLAGS_COMPAT:
 		return client->dev->custom_ioctl(client,
 						ION_IOC_GET_FLAGS, arg);
 	default:
@@ -1391,15 +1444,9 @@ static int ion_open(struct inode *inode, struct file *file)
 	struct ion_device *dev = container_of(miscdev, struct ion_device, dev);
 	struct ion_client *client;
 	char debug_name[64];
-	char task_comm[TASK_COMM_LEN];
 
 	pr_debug("%s: %d\n", __func__, __LINE__);
-	if (current->group_leader->flags & PF_KTHREAD) {
-		snprintf(debug_name, 64, "%u", task_pid_nr(current->group_leader));
-	} else {
-		strcpy(debug_name, get_task_comm(task_comm, current->group_leader));
-	}
-	
+	snprintf(debug_name, 64, "%u", task_pid_nr(current->group_leader));
 	client = ion_client_create(dev, -1, debug_name);
 	if (IS_ERR_OR_NULL(client))
 		return PTR_ERR(client);
@@ -1421,9 +1468,7 @@ static size_t ion_debug_heap_total(struct ion_client *client,
 	size_t size = 0;
 	struct rb_node *n;
 
-	if (!mutex_trylock(&client->lock))
-		return -1;
-
+	mutex_lock(&client->lock);
 	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
 		struct ion_handle *handle = rb_entry(n,
 						     struct ion_handle,
@@ -1435,29 +1480,34 @@ static size_t ion_debug_heap_total(struct ion_client *client,
 	return size;
 }
 
-static int ion_debug_find_buffer_owner(struct ion_client *client,
+/**
+ * Searches through a clients handles to find if the buffer is owned
+ * by this client. Used for debug output.
+ * @param client pointer to candidate owner of buffer
+ * @param buf pointer to buffer that we are trying to find the owner of
+ * @return 1 if found, 0 otherwise
+ */
+static int ion_debug_find_buffer_owner(const struct ion_client *client,
 				       const struct ion_buffer *buf)
 {
 	struct rb_node *n;
-	int found = 0;
-
-	if (!mutex_trylock(&client->lock))
-		return 0;
 
 	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
 		const struct ion_handle *handle = rb_entry(n,
 						     const struct ion_handle,
 						     node);
-		if (handle->buffer == buf) {
-			found = 1;
-			break;
-		}
+		if (handle->buffer == buf)
+			return 1;
 	}
-
-	mutex_unlock(&client->lock);
-	return found;
+	return 0;
 }
 
+/**
+ * Adds mem_map_data pointer to the tree of mem_map
+ * Used for debug output.
+ * @param mem_map The mem_map tree
+ * @param data The new data to add to the tree
+ */
 static void ion_debug_mem_map_add(struct rb_root *mem_map,
 				  struct mem_map_data *data)
 {
@@ -1482,6 +1532,12 @@ static void ion_debug_mem_map_add(struct rb_root *mem_map,
 	rb_insert_color(&data->node, mem_map);
 }
 
+/**
+ * Search for an owner of a buffer by iterating over all ION clients.
+ * @param dev ion device containing pointers to all the clients.
+ * @param buffer pointer to buffer we are trying to find the owner of.
+ * @return name of owner.
+ */
 const char *ion_debug_locate_owner(const struct ion_device *dev,
 					 const struct ion_buffer *buffer)
 {
@@ -1498,6 +1554,12 @@ const char *ion_debug_locate_owner(const struct ion_device *dev,
 	return client_name;
 }
 
+/**
+ * Create a mem_map of the heap.
+ * @param s seq_file to log error message to.
+ * @param heap The heap to create mem_map for.
+ * @param mem_map The mem map to be created.
+ */
 void ion_debug_mem_map_create(struct seq_file *s, struct ion_heap *heap,
 			      struct rb_root *mem_map)
 {
@@ -1515,32 +1577,19 @@ void ion_debug_mem_map_create(struct seq_file *s, struct ion_heap *heap,
 					   "Part of memory map will not be logged\n");
 				break;
 			}
-			if (heap->id == ION_IOMMU_HEAP_ID) {
-				data->addr = (unsigned long)buffer;
-			} else {
-				data->addr = buffer->priv_phys;
-				data->addr_end = buffer->priv_phys + buffer->size-1;
-			}
+			data->addr = buffer->priv_phys;
+			data->addr_end = buffer->priv_phys + buffer->size-1;
 			data->size = buffer->size;
 			data->client_name = ion_debug_locate_owner(dev, buffer);
-
-			{
-				
-				struct rb_node *p = NULL;
-				struct ion_client *entry = NULL;
-
-				for (p = rb_first(&dev->clients); p && !data->creator_name;
-						p = rb_next(p)) {
-					entry = rb_entry(p, struct ion_client, node);
-					if (entry == buffer->creator)
-						data->creator_name = entry->name;
-				}
-			}
 			ion_debug_mem_map_add(mem_map, data);
 		}
 	}
 }
 
+/**
+ * Free the memory allocated by ion_debug_mem_map_create
+ * @param mem_map The mem map to free.
+ */
 static void ion_debug_mem_map_destroy(struct rb_root *mem_map)
 {
 	if (mem_map) {
@@ -1554,6 +1603,11 @@ static void ion_debug_mem_map_destroy(struct rb_root *mem_map)
 	}
 }
 
+/**
+ * Print heap debug information.
+ * @param s seq_file to log message to.
+ * @param heap pointer to heap that we will print debug information for.
+ */
 static void ion_heap_print_debug(struct seq_file *s, struct ion_heap *heap)
 {
 	if (heap->ops->print_debug) {
@@ -1649,10 +1703,14 @@ int ion_secure_heap(struct ion_device *dev, int heap_id, int version,
 	struct rb_node *n;
 	int ret_val = 0;
 
+	/*
+	 * traverse the list of heaps available in this system
+	 * and find the heap that is specified.
+	 */
 	mutex_lock(&dev->lock);
 	for (n = rb_first(&dev->heaps); n != NULL; n = rb_next(n)) {
 		struct ion_heap *heap = rb_entry(n, struct ion_heap, node);
-		if (heap->type != ION_HEAP_TYPE_CP)
+		if (heap->type != (enum ion_heap_type) ION_HEAP_TYPE_CP)
 			continue;
 		if (ION_HEAP(heap->id) != heap_id)
 			continue;
@@ -1673,10 +1731,14 @@ int ion_unsecure_heap(struct ion_device *dev, int heap_id, int version,
 	struct rb_node *n;
 	int ret_val = 0;
 
+	/*
+	 * traverse the list of heaps available in this system
+	 * and find the heap that is specified.
+	 */
 	mutex_lock(&dev->lock);
 	for (n = rb_first(&dev->heaps); n != NULL; n = rb_next(n)) {
 		struct ion_heap *heap = rb_entry(n, struct ion_heap, node);
-		if (heap->type != ION_HEAP_TYPE_CP)
+		if (heap->type != (enum ion_heap_type) ION_HEAP_TYPE_CP)
 			continue;
 		if (ION_HEAP(heap->id) != heap_id)
 			continue;
@@ -1697,8 +1759,8 @@ static int ion_debug_leak_show(struct seq_file *s, void *unused)
 	struct rb_node *n;
 	struct rb_node *n2;
 
-	
-	seq_printf(s, "%16.s %12.s %16.s %16.s %16.s\n", "buffer", "physical", "heap", "size",
+	/* mark all buffers as 1 */
+	seq_printf(s, "%16.s %16.s %16.s %16.s\n", "buffer", "heap", "size",
 		"ref cnt");
 	mutex_lock(&dev->lock);
 	for (n = rb_first(&dev->buffers); n; n = rb_next(n)) {
@@ -1708,7 +1770,7 @@ static int ion_debug_leak_show(struct seq_file *s, void *unused)
 		buf->marked = 1;
 	}
 
-	
+	/* now see which buffers we can access */
 	for (n = rb_first(&dev->clients); n; n = rb_next(n)) {
 		struct ion_client *client = rb_entry(n, struct ion_client,
 						     node);
@@ -1725,26 +1787,15 @@ static int ion_debug_leak_show(struct seq_file *s, void *unused)
 
 	}
 
-	
+	/* And anyone still marked as a 1 means a leaked handle somewhere */
 	for (n = rb_first(&dev->buffers); n; n = rb_next(n)) {
 		struct ion_buffer *buf = rb_entry(n, struct ion_buffer,
 						     node);
-		enum ion_heap_type type = buf->heap->type;
-
-		if (buf->marked == 1) {
-			seq_printf(s, "%16.x", (int)buf);
 
-			if (type == ION_HEAP_TYPE_SYSTEM_CONTIG ||
-				type == ION_HEAP_TYPE_CARVEOUT ||
-				type == ION_HEAP_TYPE_CP)
-				seq_printf(s, " %12lx", buf->priv_phys);
-			else
-				seq_printf(s, " %12s", "N/A");
-
-			seq_printf(s, " %16.s %16.x %16.d\n",
-				buf->heap->name, buf->size,
+		if (buf->marked == 1)
+			seq_printf(s, "%16.x %16.s %16.x %16.d\n",
+				(int)buf, buf->heap->name, buf->size,
 				atomic_read(&buf->ref.refcount));
-		}
 	}
 	mutex_unlock(&dev->lock);
 	return 0;
@@ -1803,7 +1854,7 @@ struct ion_device *ion_device_create(long (*custom_ioctl)
 void ion_device_destroy(struct ion_device *dev)
 {
 	misc_deregister(&dev->dev);
-	
+	/* XXX need to free the heaps and clients ? */
 	kfree(dev);
 }
 
diff --git a/drivers/gpu/ion/ion_carveout_heap.c b/drivers/gpu/ion/ion_carveout_heap.c
old mode 100644
new mode 100755
index 5f7fe37..256de07
--- a/drivers/gpu/ion/ion_carveout_heap.c
+++ b/drivers/gpu/ion/ion_carveout_heap.c
@@ -2,7 +2,7 @@
  * drivers/gpu/ion/ion_carveout_heap.c
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -23,7 +23,6 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/iommu.h>
 #include <linux/seq_file.h>
 #include "ion_priv.h"
@@ -31,6 +30,7 @@
 #include <mach/iommu_domains.h>
 #include <asm/mach/map.h>
 #include <asm/cacheflush.h>
+#include <linux/msm_ion.h>
 
 struct ion_carveout_heap {
 	struct ion_heap heap;
@@ -240,25 +240,78 @@ int ion_carveout_cache_ops(struct ion_heap *heap, struct ion_buffer *buffer,
 			void *vaddr, unsigned int offset, unsigned int length,
 			unsigned int cmd)
 {
-	void (*outer_cache_op)(phys_addr_t, phys_addr_t);
+	void (*outer_cache_op)(phys_addr_t, phys_addr_t) = NULL;
 	struct ion_carveout_heap *carveout_heap =
 	     container_of(heap, struct  ion_carveout_heap, heap);
-
-	switch (cmd) {
-	case ION_IOC_CLEAN_CACHES:
-		dmac_clean_range(vaddr, vaddr + length);
-		outer_cache_op = outer_clean_range;
-		break;
-	case ION_IOC_INV_CACHES:
-		dmac_inv_range(vaddr, vaddr + length);
-		outer_cache_op = outer_inv_range;
-		break;
-	case ION_IOC_CLEAN_INV_CACHES:
-		dmac_flush_range(vaddr, vaddr + length);
-		outer_cache_op = outer_flush_range;
-		break;
-	default:
-		return -EINVAL;
+	unsigned int size_to_vmap, total_size;
+	int i, j;
+	void *ptr = NULL;
+	ion_phys_addr_t buff_phys = buffer->priv_phys;
+
+	if (!vaddr) {
+		/*
+		 * Split the vmalloc space into smaller regions in
+		 * order to clean and/or invalidate the cache.
+		 */
+		size_to_vmap = ((VMALLOC_END - VMALLOC_START)/8);
+		total_size = buffer->size;
+
+		for (i = 0; i < total_size; i += size_to_vmap) {
+			size_to_vmap = min(size_to_vmap, total_size - i);
+			for (j = 0; j < 10 && size_to_vmap; ++j) {
+				ptr = ioremap(buff_phys, size_to_vmap);
+				if (ptr) {
+					switch (cmd) {
+					case ION_IOC_CLEAN_CACHES:
+						dmac_clean_range(ptr,
+							ptr + size_to_vmap);
+						outer_cache_op =
+							outer_clean_range;
+						break;
+					case ION_IOC_INV_CACHES:
+						dmac_inv_range(ptr,
+							ptr + size_to_vmap);
+						outer_cache_op =
+							outer_inv_range;
+						break;
+					case ION_IOC_CLEAN_INV_CACHES:
+						dmac_flush_range(ptr,
+							ptr + size_to_vmap);
+						outer_cache_op =
+							outer_flush_range;
+						break;
+					default:
+						return -EINVAL;
+					}
+					buff_phys += size_to_vmap;
+					break;
+				} else {
+					size_to_vmap >>= 1;
+				}
+			}
+			if (!ptr) {
+				pr_err("Couldn't io-remap the memory\n");
+				return -EINVAL;
+			}
+			iounmap(ptr);
+		}
+	} else {
+		switch (cmd) {
+		case ION_IOC_CLEAN_CACHES:
+			dmac_clean_range(vaddr, vaddr + length);
+			outer_cache_op = outer_clean_range;
+			break;
+		case ION_IOC_INV_CACHES:
+			dmac_inv_range(vaddr, vaddr + length);
+			outer_cache_op = outer_inv_range;
+			break;
+		case ION_IOC_CLEAN_INV_CACHES:
+			dmac_flush_range(vaddr, vaddr + length);
+			outer_cache_op = outer_flush_range;
+			break;
+		default:
+			return -EINVAL;
+		}
 	}
 
 	if (carveout_heap->has_outer_cache) {
@@ -286,19 +339,18 @@ static int ion_carveout_print_debug(struct ion_heap *heap, struct seq_file *s,
 		struct rb_node *n;
 
 		seq_printf(s, "\nMemory Map\n");
-		seq_printf(s, "%16.s %16.s %14.s %14.s %14.s\n",
-			   "client", "creator", "start address", "end address",
+		seq_printf(s, "%16.s %14.s %14.s %14.s\n",
+			   "client", "start address", "end address",
 			   "size (hex)");
 
 		for (n = rb_first(mem_map); n; n = rb_next(n)) {
 			struct mem_map_data *data =
 					rb_entry(n, struct mem_map_data, node);
 			const char *client_name = "(null)";
-			const char *creator_name = "(null)";
 
 			if (last_end < data->addr) {
-				seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n",
-					   "FREE", "NA", last_end, data->addr-1,
+				seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n",
+					   "FREE", last_end, data->addr-1,
 					   data->addr-last_end,
 					   data->addr-last_end);
 			}
@@ -306,17 +358,14 @@ static int ion_carveout_print_debug(struct ion_heap *heap, struct seq_file *s,
 			if (data->client_name)
 				client_name = data->client_name;
 
-			if (data->creator_name)
-				creator_name = data->creator_name;
-
-			seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n",
-				   client_name, creator_name, data->addr,
+			seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n",
+				   client_name, data->addr,
 				   data->addr_end,
 				   data->size, data->size);
 			last_end = data->addr_end+1;
 		}
 		if (last_end < end) {
-			seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n", "FREE", "NA",
+			seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n", "FREE",
 				last_end, end-1, end-last_end, end-last_end);
 		}
 	}
@@ -361,7 +410,7 @@ int ion_carveout_heap_map_iommu(struct ion_buffer *buffer,
 		goto out1;
 	}
 
-	sglist = vmalloc(sizeof(*sglist));
+	sglist = kmalloc(sizeof(*sglist), GFP_KERNEL);
 	if (!sglist)
 		goto out1;
 
@@ -385,13 +434,13 @@ int ion_carveout_heap_map_iommu(struct ion_buffer *buffer,
 		if (ret)
 			goto out2;
 	}
-	vfree(sglist);
+	kfree(sglist);
 	return ret;
 
 out2:
 	iommu_unmap_range(domain, data->iova_addr, buffer->size);
 out1:
-	vfree(sglist);
+	kfree(sglist);
 	msm_free_iova_address(data->iova_addr, domain_num, partition_num,
 				data->mapped_size);
 
diff --git a/drivers/gpu/ion/ion_cma_heap.c b/drivers/gpu/ion/ion_cma_heap.c
new file mode 100755
index 0000000..722f778
--- /dev/null
+++ b/drivers/gpu/ion/ion_cma_heap.c
@@ -0,0 +1,358 @@
+/*
+ * drivers/gpu/ion/ion_cma_heap.c
+ *
+ * Copyright (C) Linaro 2012
+ * Author: <benjamin.gaignard@linaro.org> for ST-Ericsson.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/ion.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/dma-mapping.h>
+#include <linux/msm_ion.h>
+#include <mach/iommu_domains.h>
+
+#include <asm/cacheflush.h>
+
+/* for ion_heap_ops structure */
+#include "ion_priv.h"
+
+#define ION_CMA_ALLOCATE_FAILED -1
+
+struct ion_cma_buffer_info {
+	void *cpu_addr;
+	dma_addr_t handle;
+	struct sg_table *table;
+	bool is_cached;
+};
+
+static int cma_heap_has_outer_cache;
+/*
+ * Create scatter-list for the already allocated DMA buffer.
+ * This function could be replace by dma_common_get_sgtable
+ * as soon as it will avalaible.
+ */
+int ion_cma_get_sgtable(struct device *dev, struct sg_table *sgt,
+			void *cpu_addr, dma_addr_t handle, size_t size)
+{
+	struct page *page = virt_to_page(cpu_addr);
+	int ret;
+
+	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
+	if (unlikely(ret))
+		return ret;
+
+	sg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);
+	return 0;
+}
+
+/* ION CMA heap operations functions */
+static int ion_cma_allocate(struct ion_heap *heap, struct ion_buffer *buffer,
+			    unsigned long len, unsigned long align,
+			    unsigned long flags)
+{
+	struct device *dev = heap->priv;
+	struct ion_cma_buffer_info *info;
+
+	dev_dbg(dev, "Request buffer allocation len %ld\n", len);
+
+	info = kzalloc(sizeof(struct ion_cma_buffer_info), GFP_KERNEL);
+	if (!info) {
+		dev_err(dev, "Can't allocate buffer info\n");
+		return ION_CMA_ALLOCATE_FAILED;
+	}
+
+	if (!ION_IS_CACHED(flags))
+		info->cpu_addr = dma_alloc_writecombine(dev, len,
+					&(info->handle), 0);
+	else
+		info->cpu_addr = dma_alloc_nonconsistent(dev, len,
+					&(info->handle), 0);
+
+	if (!info->cpu_addr) {
+		dev_err(dev, "Fail to allocate buffer\n");
+		goto err;
+	}
+
+	info->table = kmalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!info->table) {
+		dev_err(dev, "Fail to allocate sg table\n");
+		goto err;
+	}
+
+	info->is_cached = ION_IS_CACHED(flags);
+
+	ion_cma_get_sgtable(dev,
+			info->table, info->cpu_addr, info->handle, len);
+
+	/* keep this for memory release */
+	buffer->priv_virt = info;
+	dev_dbg(dev, "Allocate buffer %p\n", buffer);
+	return 0;
+
+err:
+	kfree(info);
+	return ION_CMA_ALLOCATE_FAILED;
+}
+
+static void ion_cma_free(struct ion_buffer *buffer)
+{
+	struct device *dev = buffer->heap->priv;
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+	dev_dbg(dev, "Release buffer %p\n", buffer);
+	/* release memory */
+	dma_free_coherent(dev, buffer->size, info->cpu_addr, info->handle);
+	sg_free_table(info->table);
+	/* release sg table */
+	kfree(info->table);
+	kfree(info);
+}
+
+/* return physical address in addr */
+static int ion_cma_phys(struct ion_heap *heap, struct ion_buffer *buffer,
+			ion_phys_addr_t *addr, size_t *len)
+{
+	struct device *dev = heap->priv;
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+	dev_dbg(dev, "Return buffer %p physical address 0x%x\n", buffer,
+		info->handle);
+
+	*addr = info->handle;
+	*len = buffer->size;
+
+	return 0;
+}
+
+struct sg_table *ion_cma_heap_map_dma(struct ion_heap *heap,
+					 struct ion_buffer *buffer)
+{
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+	return info->table;
+}
+
+void ion_cma_heap_unmap_dma(struct ion_heap *heap,
+			       struct ion_buffer *buffer)
+{
+	return;
+}
+
+static int ion_cma_mmap(struct ion_heap *mapper, struct ion_buffer *buffer,
+			struct vm_area_struct *vma)
+{
+	struct device *dev = buffer->heap->priv;
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+	if (info->is_cached)
+		return dma_mmap_nonconsistent(dev, vma, info->cpu_addr,
+				info->handle, buffer->size);
+	else
+		return dma_mmap_writecombine(dev, vma, info->cpu_addr,
+				info->handle, buffer->size);
+}
+
+static void *ion_cma_map_kernel(struct ion_heap *heap,
+				struct ion_buffer *buffer)
+{
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+	return info->cpu_addr;
+}
+
+static void ion_cma_unmap_kernel(struct ion_heap *heap,
+				 struct ion_buffer *buffer)
+{
+	return;
+}
+
+int ion_cma_map_iommu(struct ion_buffer *buffer,
+				struct ion_iommu_map *data,
+				unsigned int domain_num,
+				unsigned int partition_num,
+				unsigned long align,
+				unsigned long iova_length,
+				unsigned long flags)
+{
+	int ret = 0;
+	struct iommu_domain *domain;
+	unsigned long extra;
+	unsigned long extra_iova_addr;
+	struct ion_cma_buffer_info *info = buffer->priv_virt;
+	struct sg_table *table = info->table;
+	int prot = IOMMU_WRITE | IOMMU_READ;
+
+	data->mapped_size = iova_length;
+
+	if (!msm_use_iommu()) {
+		data->iova_addr = info->handle;
+		return 0;
+	}
+
+	extra = iova_length - buffer->size;
+
+	ret = msm_allocate_iova_address(domain_num, partition_num,
+						data->mapped_size, align,
+						&data->iova_addr);
+
+	if (ret)
+		goto out;
+
+	domain = msm_get_iommu_domain(domain_num);
+
+	if (!domain) {
+		ret = -EINVAL;
+		goto out1;
+	}
+
+	ret = iommu_map_range(domain, data->iova_addr, table->sgl,
+				buffer->size, prot);
+
+	if (ret) {
+		pr_err("%s: could not map %lx in domain %p\n",
+			__func__, data->iova_addr, domain);
+		goto out1;
+	}
+
+	extra_iova_addr = data->iova_addr + buffer->size;
+	if (extra) {
+		ret = msm_iommu_map_extra(domain, extra_iova_addr, extra, SZ_4K,
+						prot);
+		if (ret)
+			goto out2;
+	}
+	return ret;
+
+out2:
+	iommu_unmap_range(domain, data->iova_addr, buffer->size);
+out1:
+	msm_free_iova_address(data->iova_addr, domain_num, partition_num,
+				data->mapped_size);
+out:
+	return ret;
+}
+
+
+void ion_cma_unmap_iommu(struct ion_iommu_map *data)
+{
+	unsigned int domain_num;
+	unsigned int partition_num;
+	struct iommu_domain *domain;
+
+	if (!msm_use_iommu())
+		return;
+
+	domain_num = iommu_map_domain(data);
+	partition_num = iommu_map_partition(data);
+
+	domain = msm_get_iommu_domain(domain_num);
+
+	if (!domain) {
+		WARN(1, "Could not get domain %d. Corruption?\n", domain_num);
+		return;
+	}
+
+	iommu_unmap_range(domain, data->iova_addr, data->mapped_size);
+	msm_free_iova_address(data->iova_addr, domain_num, partition_num,
+				data->mapped_size);
+
+	return;
+}
+
+int ion_cma_cache_ops(struct ion_heap *heap,
+			struct ion_buffer *buffer, void *vaddr,
+			unsigned int offset, unsigned int length,
+			unsigned int cmd)
+{
+	void (*outer_cache_op)(phys_addr_t, phys_addr_t);
+
+	switch (cmd) {
+	case ION_IOC_CLEAN_CACHES:
+		if (!vaddr)
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+		else
+			dmac_clean_range(vaddr, vaddr + length);
+		outer_cache_op = outer_clean_range;
+		break;
+	case ION_IOC_INV_CACHES:
+		if (!vaddr)
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		else
+			dmac_inv_range(vaddr, vaddr + length);
+		outer_cache_op = outer_inv_range;
+		break;
+	case ION_IOC_CLEAN_INV_CACHES:
+		if (!vaddr) {
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		} else {
+			dmac_flush_range(vaddr, vaddr + length);
+		}
+		outer_cache_op = outer_flush_range;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cma_heap_has_outer_cache) {
+		struct ion_cma_buffer_info *info = buffer->priv_virt;
+
+		outer_cache_op(info->handle, info->handle + length);
+	}
+
+	return 0;
+}
+
+static struct ion_heap_ops ion_cma_ops = {
+	.allocate = ion_cma_allocate,
+	.free = ion_cma_free,
+	.map_dma = ion_cma_heap_map_dma,
+	.unmap_dma = ion_cma_heap_unmap_dma,
+	.phys = ion_cma_phys,
+	.map_user = ion_cma_mmap,
+	.map_kernel = ion_cma_map_kernel,
+	.unmap_kernel = ion_cma_unmap_kernel,
+	.map_iommu = ion_cma_map_iommu,
+	.unmap_iommu = ion_cma_unmap_iommu,
+	.cache_op = ion_cma_cache_ops,
+};
+
+struct ion_heap *ion_cma_heap_create(struct ion_platform_heap *data)
+{
+	struct ion_heap *heap;
+
+	heap = kzalloc(sizeof(struct ion_heap), GFP_KERNEL);
+
+	if (!heap)
+		return ERR_PTR(-ENOMEM);
+
+	heap->ops = &ion_cma_ops;
+	/* set device as private heaps data, later it will be
+	 * used to make the link with reserved CMA memory */
+	heap->priv = data->priv;
+	heap->type = ION_HEAP_TYPE_DMA;
+	cma_heap_has_outer_cache = data->has_outer_cache;
+	return heap;
+}
+
+void ion_cma_heap_destroy(struct ion_heap *heap)
+{
+	kfree(heap);
+}
diff --git a/drivers/gpu/ion/ion_cp_heap.c b/drivers/gpu/ion/ion_cp_heap.c
old mode 100644
new mode 100755
index d0d6a95..2069672
--- a/drivers/gpu/ion/ion_cp_heap.c
+++ b/drivers/gpu/ion/ion_cp_heap.c
@@ -23,7 +23,6 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/memory_alloc.h>
 #include <linux/seq_file.h>
 #include <linux/fmem.h>
@@ -41,6 +40,39 @@
 #include <asm/cacheflush.h>
 
 #include "msm/ion_cp_common.h"
+/**
+ * struct ion_cp_heap - container for the heap and shared heap data
+
+ * @heap:	the heap information structure
+ * @pool:	memory pool to allocate from.
+ * @base:	the base address of the memory pool.
+ * @permission_type:	Identifier for the memory used by SCM for protecting
+ *			and unprotecting memory.
+ * @secure_base:	Base address used when securing a heap that is shared.
+ * @secure_size:	Size used when securing a heap that is shared.
+ * @lock:	mutex to protect shared access.
+ * @heap_protected:	Indicates whether heap has been protected or not.
+ * @allocated_bytes:	the total number of allocated bytes from the pool.
+ * @total_size:	the total size of the memory pool.
+ * @request_region:	function pointer to call when first mapping of memory
+ *			occurs.
+ * @release_region:	function pointer to call when last mapping of memory
+ *			unmapped.
+ * @bus_id: token used with request/release region.
+ * @kmap_cached_count:	the total number of times this heap has been mapped in
+ *			kernel space (cached).
+ * @kmap_uncached_count:the total number of times this heap has been mapped in
+ *			kernel space (un-cached).
+ * @umap_count:	the total number of times this heap has been mapped in
+ *		user space.
+ * @iommu_iova: saved iova when mapping full heap at once.
+ * @iommu_partition: partition used to map full heap.
+ * @reusable: indicates if the memory should be reused via fmem.
+ * @reserved_vrange: reserved virtual address range for use with fmem
+ * @iommu_map_all:	Indicates whether we should map whole heap into IOMMU.
+ * @iommu_2x_map_domain: Indicates the domain to use for overmapping.
+ * @has_outer_cache:    set to 1 if outer cache is used, 0 otherwise.
+*/
 struct ion_cp_heap {
 	struct ion_heap heap;
 	struct gen_pool *pool;
@@ -81,12 +113,21 @@ static int ion_cp_unprotect_mem(unsigned int phy_base, unsigned int size,
 				unsigned int permission_type, int version,
 				void *data);
 
+/**
+ * Get the total number of kernel mappings.
+ * Must be called with heap->lock locked.
+ */
 static unsigned long ion_cp_get_total_kmap_count(
 					const struct ion_cp_heap *cp_heap)
 {
 	return cp_heap->kmap_cached_count + cp_heap->kmap_uncached_count;
 }
 
+/**
+ * Protects memory if heap is unsecured heap. Also ensures that we are in
+ * the correct FMEM state if this heap is a reusable heap.
+ * Must be called with heap->lock locked.
+ */
 static int ion_cp_protect(struct ion_heap *heap, int version, void *data)
 {
 	struct ion_cp_heap *cp_heap =
@@ -94,7 +135,7 @@ static int ion_cp_protect(struct ion_heap *heap, int version, void *data)
 	int ret_value = 0;
 
 	if (atomic_inc_return(&cp_heap->protect_cnt) == 1) {
-		
+		/* Make sure we are in C state when the heap is protected. */
 		if (cp_heap->reusable && !cp_heap->allocated_bytes) {
 			ret_value = fmem_set_state(FMEM_C_STATE);
 			if (ret_value)
@@ -127,6 +168,11 @@ static int ion_cp_protect(struct ion_heap *heap, int version, void *data)
 	return ret_value;
 }
 
+/**
+ * Unprotects memory if heap is secure heap. Also ensures that we are in
+ * the correct FMEM state if this heap is a reusable heap.
+ * Must be called with heap->lock locked.
+ */
 static void ion_cp_unprotect(struct ion_heap *heap, int version, void *data)
 {
 	struct ion_cp_heap *cp_heap =
@@ -185,6 +231,10 @@ ion_phys_addr_t ion_cp_allocate(struct ion_heap *heap,
 		return ION_CP_ALLOCATE_FAIL;
 	}
 
+	/*
+	 * if this is the first reusable allocation, transition
+	 * the heap
+	 */
 	if (cp_heap->reusable && !cp_heap->allocated_bytes) {
 		if (fmem_set_state(FMEM_C_STATE) != 0) {
 			mutex_unlock(&cp_heap->lock);
@@ -267,7 +317,7 @@ void ion_cp_free(struct ion_heap *heap, ion_phys_addr_t addr,
 				__func__);
 	}
 
-	
+	/* Unmap everything if we previously mapped the whole heap at once. */
 	if (!cp_heap->allocated_bytes) {
 		unsigned int i;
 		for (i = 0; i < MAX_DOMAINS; ++i) {
@@ -353,6 +403,9 @@ void ion_cp_heap_unmap_dma(struct ion_heap *heap,
 	buffer->sg_table = 0;
 }
 
+/**
+ * Call request region for SMI memory of this is the first mapping.
+ */
 static int ion_cp_request_region(struct ion_cp_heap *cp_heap)
 {
 	int ret_value = 0;
@@ -362,6 +415,9 @@ static int ion_cp_request_region(struct ion_cp_heap *cp_heap)
 	return ret_value;
 }
 
+/**
+ * Call release region for SMI memory of this is the last un-mapping.
+ */
 static int ion_cp_release_region(struct ion_cp_heap *cp_heap)
 {
 	int ret_value = 0;
@@ -569,19 +625,18 @@ static int ion_cp_print_debug(struct ion_heap *heap, struct seq_file *s,
 		struct rb_node *n;
 
 		seq_printf(s, "\nMemory Map\n");
-		seq_printf(s, "%16.s %16.s %14.s %14.s %14.s\n",
-			   "client", "creator", "start address", "end address",
+		seq_printf(s, "%16.s %14.s %14.s %14.s\n",
+			   "client", "start address", "end address",
 			   "size (hex)");
 
 		for (n = rb_first(mem_map); n; n = rb_next(n)) {
 			struct mem_map_data *data =
 					rb_entry(n, struct mem_map_data, node);
 			const char *client_name = "(null)";
-			const char *creator_name = "(null)";
 
 			if (last_end < data->addr) {
-				seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n",
-					   "FREE", "NA", last_end, data->addr-1,
+				seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n",
+					   "FREE", last_end, data->addr-1,
 					   data->addr-last_end,
 					   data->addr-last_end);
 			}
@@ -589,17 +644,14 @@ static int ion_cp_print_debug(struct ion_heap *heap, struct seq_file *s,
 			if (data->client_name)
 				client_name = data->client_name;
 
-			if (data->creator_name)
-				creator_name = data->creator_name;
-
-			seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n",
-				   client_name, creator_name, data->addr,
+			seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n",
+				   client_name, data->addr,
 				   data->addr_end,
 				   data->size, data->size);
 			last_end = data->addr_end+1;
 		}
 		if (last_end < end) {
-			seq_printf(s, "%16.s %16.s %14lx %14lx %14lu (%lx)\n", "FREE", "NA",
+			seq_printf(s, "%16.s %14lx %14lx %14lu (%lx)\n", "FREE",
 				last_end, end-1, end-last_end, end-last_end);
 		}
 	}
@@ -646,6 +698,9 @@ static int iommu_map_all(unsigned long domain_num, struct ion_cp_heap *cp_heap,
 	unsigned long virt_addr_len = cp_heap->total_size;
 	struct iommu_domain *domain = msm_get_iommu_domain(domain_num);
 
+	/* If we are mapping into the video domain we need to map twice the
+	 * size of the heap to account for prefetch issue in video core.
+	 */
 	if (domain_num == cp_heap->iommu_2x_map_domain)
 		virt_addr_len <<= 1;
 
@@ -728,7 +783,7 @@ static int ion_cp_heap_map_iommu(struct ion_buffer *buffer,
 	}
 
 	if (cp_heap->iommu_iova[domain_num]) {
-		
+		/* Already mapped. */
 		unsigned long offset = buffer->priv_phys - cp_heap->base;
 		data->iova_addr = cp_heap->iommu_iova[domain_num] + offset;
 		return 0;
@@ -740,6 +795,10 @@ static int ion_cp_heap_map_iommu(struct ion_buffer *buffer,
 			data->iova_addr =
 				cp_heap->iommu_iova[domain_num] + offset;
 			cp_heap->iommu_partition[domain_num] = partition_num;
+			/*
+			clear delayed map flag so that we don't interfere
+			with this feature (we are already delaying).
+			*/
 			data->flags &= ~ION_IOMMU_UNMAP_DELAYED;
 			return 0;
 		} else {
@@ -805,6 +864,8 @@ static void ion_cp_heap_unmap_iommu(struct ion_iommu_map *data)
 
 	domain_num = iommu_map_domain(data);
 
+	/* If we are mapping everything we'll wait to unmap until everything
+	   is freed. */
 	if (cp_heap->iommu_iova[domain_num])
 		return;
 
@@ -927,6 +988,7 @@ void ion_cp_heap_get_base(struct ion_heap *heap, unsigned long *base,
 	*size = cp_heap->total_size;
 }
 
+/*  SCM related code for locking down memory for content protection */
 
 #define SCM_CP_LOCK_CMD_ID	0x1
 #define SCM_CP_PROTECT		0x1
diff --git a/drivers/gpu/ion/ion_heap.c b/drivers/gpu/ion/ion_heap.c
old mode 100644
new mode 100755
index 6ea49db..98c1a8c
--- a/drivers/gpu/ion/ion_heap.c
+++ b/drivers/gpu/ion/ion_heap.c
@@ -2,7 +2,7 @@
  * drivers/gpu/ion/ion_heap.c
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -18,12 +18,13 @@
 #include <linux/err.h>
 #include <linux/ion.h>
 #include "ion_priv.h"
+#include <linux/msm_ion.h>
 
 struct ion_heap *ion_heap_create(struct ion_platform_heap *heap_data)
 {
 	struct ion_heap *heap = NULL;
 
-	switch (heap_data->type) {
+	switch ((int) heap_data->type) {
 	case ION_HEAP_TYPE_SYSTEM_CONTIG:
 		heap = ion_system_contig_heap_create(heap_data);
 		break;
@@ -39,6 +40,11 @@ struct ion_heap *ion_heap_create(struct ion_platform_heap *heap_data)
 	case ION_HEAP_TYPE_CP:
 		heap = ion_cp_heap_create(heap_data);
 		break;
+#ifdef CONFIG_CMA
+	case ION_HEAP_TYPE_DMA:
+		heap = ion_cma_heap_create(heap_data);
+		break;
+#endif
 	default:
 		pr_err("%s: Invalid heap type %d\n", __func__,
 		       heap_data->type);
@@ -54,6 +60,7 @@ struct ion_heap *ion_heap_create(struct ion_platform_heap *heap_data)
 
 	heap->name = heap_data->name;
 	heap->id = heap_data->id;
+	heap->priv = heap_data->priv;
 	return heap;
 }
 
@@ -62,7 +69,7 @@ void ion_heap_destroy(struct ion_heap *heap)
 	if (!heap)
 		return;
 
-	switch (heap->type) {
+	switch ((int) heap->type) {
 	case ION_HEAP_TYPE_SYSTEM_CONTIG:
 		ion_system_contig_heap_destroy(heap);
 		break;
@@ -78,6 +85,11 @@ void ion_heap_destroy(struct ion_heap *heap)
 	case ION_HEAP_TYPE_CP:
 		ion_cp_heap_destroy(heap);
 		break;
+#ifdef CONFIG_CMA
+	case ION_HEAP_TYPE_DMA:
+		ion_cma_heap_destroy(heap);
+		break;
+#endif
 	default:
 		pr_err("%s: Invalid heap type %d\n", __func__,
 		       heap->type);
diff --git a/drivers/gpu/ion/ion_iommu_heap.c b/drivers/gpu/ion/ion_iommu_heap.c
old mode 100644
new mode 100755
index 5f6780b..49721fb
--- a/drivers/gpu/ion/ion_iommu_heap.c
+++ b/drivers/gpu/ion/ion_iommu_heap.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,13 +12,15 @@
  */
 #include <linux/err.h>
 #include <linux/io.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/iommu.h>
 #include <linux/pfn.h>
+#include <linux/dma-mapping.h>
 #include "ion_priv.h"
 
 #include <asm/mach/map.h>
@@ -31,40 +33,131 @@ struct ion_iommu_heap {
 	unsigned int has_outer_cache;
 };
 
+/*
+ * We will attempt to allocate high-order pages and store those in an
+ * sg_list. However, some APIs expect an array of struct page * where
+ * each page is of size PAGE_SIZE. We use this extra structure to
+ * carry around an array of such pages (derived from the high-order
+ * pages with nth_page).
+ */
 struct ion_iommu_priv_data {
 	struct page **pages;
+	unsigned int pages_uses_vmalloc;
 	int nrpages;
 	unsigned long size;
 };
 
-atomic_t v = ATOMIC_INIT(0);
+#define MAX_VMAP_RETRIES 10
+
+static const unsigned int orders[] = {8, 4, 0};
+static const int num_orders = ARRAY_SIZE(orders);
+
+struct page_info {
+	struct page *page;
+	unsigned int order;
+	struct list_head list;
+};
+
+static unsigned int order_to_size(int order)
+{
+	return PAGE_SIZE << order;
+}
+
+static struct page_info *alloc_largest_available(unsigned long size,
+						unsigned int max_order)
+{
+	struct page *page;
+	struct page_info *info;
+	int i;
+
+	for (i = 0; i < num_orders; i++) {
+		gfp_t gfp;
+		if (size < order_to_size(orders[i]))
+			continue;
+		if (max_order < orders[i])
+			continue;
+
+		gfp = __GFP_HIGHMEM;
+
+		if (orders[i]) {
+			gfp |= __GFP_COMP | __GFP_NORETRY |
+			       __GFP_NO_KSWAPD | __GFP_NOWARN;
+		} else {
+			gfp |= GFP_KERNEL;
+		}
+		page = alloc_pages(gfp, orders[i]);
+		if (!page)
+			continue;
+
+		info = kmalloc(sizeof(struct page_info), GFP_KERNEL);
+		info->page = page;
+		info->order = orders[i];
+		return info;
+	}
+	return NULL;
+}
 
 static int ion_iommu_heap_allocate(struct ion_heap *heap,
 				      struct ion_buffer *buffer,
 				      unsigned long size, unsigned long align,
 				      unsigned long flags)
 {
-	int ret = 0, i;
+	int ret, i;
+	struct list_head pages_list;
+	struct page_info *info, *tmp_info;
 	struct ion_iommu_priv_data *data = NULL;
-	pgprot_t page_prot = pgprot_writecombine(PAGE_KERNEL);
-	void *ptr = NULL;
 
 	if (msm_use_iommu()) {
 		struct scatterlist *sg;
 		struct sg_table *table;
-		unsigned int i;
+		int j;
+		void *ptr = NULL;
+		unsigned int npages_to_vmap, total_pages, num_large_pages = 0;
+		unsigned long size_remaining = PAGE_ALIGN(size);
+		unsigned int max_order = orders[0];
+		unsigned int page_tbl_size;
 
 		data = kmalloc(sizeof(*data), GFP_KERNEL);
 		if (!data)
 			return -ENOMEM;
 
+		INIT_LIST_HEAD(&pages_list);
+		while (size_remaining > 0) {
+			info = alloc_largest_available(size_remaining,
+						max_order);
+			if (!info) {
+				ret = -ENOMEM;
+				goto err_free_data;
+			}
+			list_add_tail(&info->list, &pages_list);
+			size_remaining -= order_to_size(info->order);
+			max_order = info->order;
+			num_large_pages++;
+		}
+
 		data->size = PFN_ALIGN(size);
 		data->nrpages = data->size >> PAGE_SHIFT;
-		data->pages = kzalloc(sizeof(struct page *)*data->nrpages,
-				GFP_KERNEL);
+		data->pages_uses_vmalloc = 0;
+		page_tbl_size = sizeof(struct page *) * data->nrpages;
+
+		if (page_tbl_size > SZ_8K) {
+			/*
+			 * Do fallback to ensure we have a balance between
+			 * performance and availability.
+			 */
+			data->pages = kmalloc(page_tbl_size,
+					      __GFP_COMP | __GFP_NORETRY |
+					      __GFP_NO_KSWAPD | __GFP_NOWARN);
+			if (!data->pages) {
+				data->pages = vmalloc(page_tbl_size);
+				data->pages_uses_vmalloc = 1;
+			}
+		} else {
+			data->pages = kmalloc(page_tbl_size, GFP_KERNEL);
+		}
 		if (!data->pages) {
 			ret = -ENOMEM;
-			goto err1;
+			goto err_free_data;
 		}
 
 		table = buffer->sg_table =
@@ -74,30 +167,62 @@ static int ion_iommu_heap_allocate(struct ion_heap *heap,
 			ret = -ENOMEM;
 			goto err1;
 		}
-		ret = sg_alloc_table(table, data->nrpages, GFP_KERNEL);
+		ret = sg_alloc_table(table, num_large_pages, GFP_KERNEL);
 		if (ret)
 			goto err2;
 
-		for_each_sg(table->sgl, sg, table->nents, i) {
-			data->pages[i] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
-			if (!data->pages[i])
-				goto err3;
-
-			sg_set_page(sg, data->pages[i], PAGE_SIZE, 0);
+		i = 0;
+		sg = table->sgl;
+		list_for_each_entry_safe(info, tmp_info, &pages_list, list) {
+			struct page *page = info->page;
+			sg_set_page(sg, page, order_to_size(info->order), 0);
+			sg_dma_address(sg) = sg_phys(sg);
+			sg = sg_next(sg);
+			for (j = 0; j < (1 << info->order); ++j)
+				data->pages[i++] = nth_page(page, j);
+			list_del(&info->list);
+			kfree(info);
 		}
 
-		ptr = vmap(data->pages, data->nrpages, VM_IOREMAP, page_prot);
-		if (ptr != NULL) {
-			memset(ptr, 0, data->size);
-			dmac_flush_range(ptr, ptr + data->size);
+		/*
+		 * As an optimization, we omit __GFP_ZERO from
+		 * alloc_page above and manually zero out all of the
+		 * pages in one fell swoop here. To safeguard against
+		 * insufficient vmalloc space, we only vmap
+		 * `npages_to_vmap' at a time, starting with a
+		 * conservative estimate of 1/8 of the total number of
+		 * vmalloc pages available. Note that the `pages'
+		 * array is composed of all 4K pages, irrespective of
+		 * the size of the pages on the sg list.
+		 */
+		npages_to_vmap = ((VMALLOC_END - VMALLOC_START)/8)
+			>> PAGE_SHIFT;
+		total_pages = data->nrpages;
+		for (i = 0; i < total_pages; i += npages_to_vmap) {
+			npages_to_vmap = min(npages_to_vmap, total_pages - i);
+			for (j = 0; j < MAX_VMAP_RETRIES && npages_to_vmap;
+			     ++j) {
+				ptr = vmap(&data->pages[i], npages_to_vmap,
+					VM_IOREMAP, pgprot_kernel);
+				if (ptr)
+					break;
+				else
+					npages_to_vmap >>= 1;
+			}
+			if (!ptr) {
+				pr_err("Couldn't vmap the pages for zeroing\n");
+				ret = -ENOMEM;
+				goto err3;
+			}
+			memset(ptr, 0, npages_to_vmap * PAGE_SIZE);
 			vunmap(ptr);
-		} else
-			pr_err("%s: vmap() failed\n", __func__);
+		}
+
+		if (!ION_IS_CACHED(flags))
+			dma_sync_sg_for_device(NULL, table->sgl, table->nents,
+						DMA_BIDIRECTIONAL);
 
 		buffer->priv_virt = data;
-		
-		atomic_add(data->size, &v);
-		
 		return 0;
 
 	} else {
@@ -110,74 +235,48 @@ static int ion_iommu_heap_allocate(struct ion_heap *heap,
 err2:
 	kfree(buffer->sg_table);
 	buffer->sg_table = 0;
-
-	for (i = 0; i < data->nrpages; i++) {
-		if (data->pages[i])
-			__free_page(data->pages[i]);
-	}
-	kfree(data->pages);
 err1:
+	if (data->pages_uses_vmalloc)
+		vfree(data->pages);
+	else
+		kfree(data->pages);
+err_free_data:
 	kfree(data);
+
+	list_for_each_entry_safe(info, tmp_info, &pages_list, list) {
+		if (info->page)
+			__free_pages(info->page, info->order);
+		list_del(&info->list);
+		kfree(info);
+	}
 	return ret;
 }
 
 static void ion_iommu_heap_free(struct ion_buffer *buffer)
 {
-	struct ion_iommu_priv_data *data = buffer->priv_virt;
 	int i;
+	struct scatterlist *sg;
+	struct sg_table *table = buffer->sg_table;
+	struct ion_iommu_priv_data *data = buffer->priv_virt;
 
+	if (!table)
+		return;
 	if (!data)
 		return;
 
-	for (i = 0; i < data->nrpages; i++)
-		__free_page(data->pages[i]);
-
-	
-	atomic_sub(data->size, &v);
-	
+	for_each_sg(table->sgl, sg, table->nents, i)
+		__free_pages(sg_page(sg), get_order(sg_dma_len(sg)));
 
-	kfree(data->pages);
+	sg_free_table(table);
+	kfree(table);
+	table = 0;
+	if (data->pages_uses_vmalloc)
+		vfree(data->pages);
+	else
+		kfree(data->pages);
 	kfree(data);
 }
 
-int ion_iommu_heap_dump_size(void)
-{
-	int ret = atomic_read(&v);
-	return ret;
-}
-
-static int ion_iommu_print_debug(struct ion_heap *heap, struct seq_file *s,
-				    const struct rb_root *mem_map)
-{
-	seq_printf(s, "Total bytes currently allocated: %d (%x)\n",
-		atomic_read(&v), atomic_read(&v));
-
-	if (mem_map) {
-		struct rb_node *n;
-
-		seq_printf(s, "\nBuffer Info\n");
-		seq_printf(s, "%16.s %16.s %14.s\n",
-			   "client", "creator", "size (hex)");
-
-		for (n = rb_first(mem_map); n; n = rb_next(n)) {
-			struct mem_map_data *data =
-					rb_entry(n, struct mem_map_data, node);
-			const char *client_name = "(null)";
-			const char *creator_name = "(null)";
-
-			if (data->client_name)
-				client_name = data->client_name;
-
-			if (data->creator_name)
-				creator_name = data->creator_name;
-
-			seq_printf(s, "%16.s %16.s %14lu (%lx)\n",
-				   client_name, creator_name, data->size, data->size);
-		}
-	}
-	return 0;
-}
-
 void *ion_iommu_heap_map_kernel(struct ion_heap *heap,
 				struct ion_buffer *buffer)
 {
@@ -188,7 +287,7 @@ void *ion_iommu_heap_map_kernel(struct ion_heap *heap,
 		return NULL;
 
 	if (!ION_IS_CACHED(buffer->flags))
-		page_prot = pgprot_noncached(page_prot);
+		page_prot = pgprot_writecombine(page_prot);
 
 	buffer->vaddr = vmap(data->pages, data->nrpages, VM_IOREMAP, page_prot);
 
@@ -208,21 +307,34 @@ void ion_iommu_heap_unmap_kernel(struct ion_heap *heap,
 int ion_iommu_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
 			       struct vm_area_struct *vma)
 {
-	struct ion_iommu_priv_data *data = buffer->priv_virt;
+	struct sg_table *table = buffer->sg_table;
+	unsigned long addr = vma->vm_start;
+	unsigned long offset = vma->vm_pgoff * PAGE_SIZE;
+	struct scatterlist *sg;
 	int i;
-	unsigned long curr_addr;
-	if (!data)
-		return -EINVAL;
 
 	if (!ION_IS_CACHED(buffer->flags))
 		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
-	curr_addr = vma->vm_start;
-	for (i = 0; i < data->nrpages && curr_addr < vma->vm_end; i++) {
-		if (vm_insert_page(vma, curr_addr, data->pages[i])) {
-			return -EINVAL;
+	for_each_sg(table->sgl, sg, table->nents, i) {
+		struct page *page = sg_page(sg);
+		unsigned long remainder = vma->vm_end - addr;
+		unsigned long len = sg_dma_len(sg);
+
+		if (offset >= sg_dma_len(sg)) {
+			offset -= sg_dma_len(sg);
+			continue;
+		} else if (offset) {
+			page += offset / PAGE_SIZE;
+			len = sg_dma_len(sg) - offset;
+			offset = 0;
 		}
-		curr_addr += PAGE_SIZE;
+		len = min(len, remainder);
+		remap_pfn_range(vma, addr, page_to_pfn(page), len,
+				vma->vm_page_prot);
+		addr += len;
+		if (addr >= vma->vm_end)
+			return 0;
 	}
 	return 0;
 }
@@ -246,6 +358,14 @@ int ion_iommu_heap_map_iommu(struct ion_buffer *buffer,
 	data->mapped_size = iova_length;
 	extra = iova_length - buffer->size;
 
+	/* Use the biggest alignment to allow bigger IOMMU mappings.
+	 * Use the first entry since the first entry will always be the
+	 * biggest entry. To take advantage of bigger mapping sizes both the
+	 * VA and PA addresses have to be aligned to the biggest size.
+	 */
+	if (buffer->sg_table->sgl->length > align)
+		align = buffer->sg_table->sgl->length;
+
 	ret = msm_allocate_iova_address(domain_num, partition_num,
 						data->mapped_size, align,
 						&data->iova_addr);
@@ -324,15 +444,30 @@ static int ion_iommu_cache_ops(struct ion_heap *heap, struct ion_buffer *buffer,
 
 	switch (cmd) {
 	case ION_IOC_CLEAN_CACHES:
-		dmac_clean_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+		else
+			dmac_clean_range(vaddr, vaddr + length);
 		outer_cache_op = outer_clean_range;
 		break;
 	case ION_IOC_INV_CACHES:
-		dmac_inv_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		else
+			dmac_inv_range(vaddr, vaddr + length);
 		outer_cache_op = outer_inv_range;
 		break;
 	case ION_IOC_CLEAN_INV_CACHES:
-		dmac_flush_range(vaddr, vaddr + length);
+		if (!vaddr) {
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		} else {
+			dmac_flush_range(vaddr, vaddr + length);
+		}
 		outer_cache_op = outer_flush_range;
 		break;
 	default:
@@ -363,10 +498,6 @@ static struct sg_table *ion_iommu_heap_map_dma(struct ion_heap *heap,
 static void ion_iommu_heap_unmap_dma(struct ion_heap *heap,
 				 struct ion_buffer *buffer)
 {
-	if (buffer->sg_table)
-		sg_free_table(buffer->sg_table);
-	kfree(buffer->sg_table);
-	buffer->sg_table = 0;
 }
 
 static struct ion_heap_ops iommu_heap_ops = {
@@ -380,7 +511,6 @@ static void ion_iommu_heap_unmap_dma(struct ion_heap *heap,
 	.cache_op = ion_iommu_cache_ops,
 	.map_dma = ion_iommu_heap_map_dma,
 	.unmap_dma = ion_iommu_heap_unmap_dma,
-	.print_debug = ion_iommu_print_debug,
 };
 
 struct ion_heap *ion_iommu_heap_create(struct ion_platform_heap *heap_data)
diff --git a/drivers/gpu/ion/ion_priv.h b/drivers/gpu/ion/ion_priv.h
old mode 100644
new mode 100755
index 31a0d81..d494f7a
--- a/drivers/gpu/ion/ion_priv.h
+++ b/drivers/gpu/ion/ion_priv.h
@@ -2,7 +2,7 @@
  * drivers/gpu/ion/ion_priv.h
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -32,6 +32,23 @@ enum {
 	DI_MAX,
 };
 
+/**
+ * struct ion_iommu_map - represents a mapping of an ion buffer to an iommu
+ * @iova_addr - iommu virtual address
+ * @node - rb node to exist in the buffer's tree of iommu mappings
+ * @domain_info - contains the partition number and domain number
+ *		domain_info[1] = domain number
+ *		domain_info[0] = partition number
+ * @ref - for reference counting this mapping
+ * @mapped_size - size of the iova space mapped
+ *		(may not be the same as the buffer size)
+ * @flags - iommu domain/partition specific flags.
+ *
+ * Represents a mapping of one ion buffer to a particular iommu domain
+ * and address range. There may exist other mappings of this buffer in
+ * different domains or address ranges. All mappings will have the same
+ * cacheability and security.
+ */
 struct ion_iommu_map {
 	unsigned long iova_addr;
 	struct rb_node node;
@@ -47,12 +64,29 @@ struct ion_iommu_map {
 
 struct ion_buffer *ion_handle_buffer(struct ion_handle *handle);
 
+/**
+ * struct ion_buffer - metadata for a particular buffer
+ * @ref:		refernce count
+ * @node:		node in the ion_device buffers tree
+ * @dev:		back pointer to the ion_device
+ * @heap:		back pointer to the heap the buffer came from
+ * @flags:		buffer specific flags
+ * @size:		size of the buffer
+ * @priv_virt:		private data to the buffer representable as
+ *			a void *
+ * @priv_phys:		private data to the buffer representable as
+ *			an ion_phys_addr_t (and someday a phys_addr_t)
+ * @lock:		protects the buffers cnt fields
+ * @kmap_cnt:		number of times the buffer is mapped to the kernel
+ * @vaddr:		the kenrel mapping if kmap_cnt is not zero
+ * @dmap_cnt:		number of times the buffer is mapped for dma
+ * @sg_table:		the sg table for the buffer if dmap_cnt is not zero
+*/
 struct ion_buffer {
 	struct kref ref;
 	struct rb_node node;
 	struct ion_device *dev;
 	struct ion_heap *heap;
-	struct ion_client *creator;
 	unsigned long flags;
 	size_t size;
 	union {
@@ -70,6 +104,19 @@ struct ion_buffer {
 	int marked;
 };
 
+/**
+ * struct ion_heap_ops - ops to operate on a given heap
+ * @allocate:		allocate memory
+ * @free:		free memory
+ * @phys		get physical address of a buffer (only define on
+ *			physically contiguous heaps)
+ * @map_dma		map the memory for dma to a scatterlist
+ * @unmap_dma		unmap the memory for dma
+ * @map_kernel		map memory to the kernel
+ * @unmap_kernel	unmap memory to the kernel
+ * @map_user		map memory to userspace
+ * @unmap_user		unmap memory to userspace
+ */
 struct ion_heap_ops {
 	int (*allocate) (struct ion_heap *heap,
 			 struct ion_buffer *buffer, unsigned long len,
@@ -102,6 +149,23 @@ struct ion_heap_ops {
 	int (*unsecure_heap)(struct ion_heap *heap, int version, void *data);
 };
 
+/**
+ * struct ion_heap - represents a heap in the system
+ * @node:		rb node to put the heap on the device's tree of heaps
+ * @dev:		back pointer to the ion_device
+ * @type:		type of heap
+ * @ops:		ops struct as above
+ * @id:			id of heap, also indicates priority of this heap when
+ *			allocating.  These are specified by platform data and
+ *			MUST be unique
+ * @name:		used for debugging
+ * @priv:		private heap data
+ *
+ * Represents a pool of memory from which buffers can be made.  In some
+ * systems the only heap is regular system memory allocated via vmalloc.
+ * On others, some blocks might require large physically contiguous buffers
+ * that are allocated from a specially reserved heap.
+ */
 struct ion_heap {
 	struct rb_node node;
 	struct ion_device *dev;
@@ -109,29 +173,58 @@ struct ion_heap {
 	struct ion_heap_ops *ops;
 	int id;
 	const char *name;
+	void *priv;
 };
 
+/**
+ * struct mem_map_data - represents information about the memory map for a heap
+ * @node:		rb node used to store in the tree of mem_map_data
+ * @addr:		start address of memory region.
+ * @addr:		end address of memory region.
+ * @size:		size of memory region
+ * @client_name:		name of the client who owns this buffer.
+ *
+ */
 struct mem_map_data {
 	struct rb_node node;
 	unsigned long addr;
 	unsigned long addr_end;
 	unsigned long size;
 	const char *client_name;
-	const char *creator_name;
 };
 
 #define iommu_map_domain(__m)		((__m)->domain_info[1])
 #define iommu_map_partition(__m)	((__m)->domain_info[0])
 
+/**
+ * ion_device_create - allocates and returns an ion device
+ * @custom_ioctl:	arch specific ioctl function if applicable
+ *
+ * returns a valid device or -PTR_ERR
+ */
 struct ion_device *ion_device_create(long (*custom_ioctl)
 				     (struct ion_client *client,
 				      unsigned int cmd,
 				      unsigned long arg));
 
+/**
+ * ion_device_destroy - free and device and it's resource
+ * @dev:		the device
+ */
 void ion_device_destroy(struct ion_device *dev);
 
+/**
+ * ion_device_add_heap - adds a heap to the ion device
+ * @dev:		the device
+ * @heap:		the heap to add
+ */
 void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap);
 
+/**
+ * functions for creating and destroying the built in ion heaps.
+ * architectures can add their own custom architecture specific
+ * heaps as appropriate.
+ */
 
 struct ion_heap *ion_heap_create(struct ion_platform_heap *);
 void ion_heap_destroy(struct ion_heap *);
@@ -154,21 +247,63 @@ struct ion_device *ion_device_create(long (*custom_ioctl)
 struct ion_heap *ion_reusable_heap_create(struct ion_platform_heap *);
 void ion_reusable_heap_destroy(struct ion_heap *);
 
+/**
+ * kernel api to allocate/free from carveout -- used when carveout is
+ * used to back an architecture specific custom heap
+ */
 ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap, unsigned long size,
 				      unsigned long align);
 void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
 		       unsigned long size);
 
+#ifdef CONFIG_CMA
+struct ion_heap *ion_cma_heap_create(struct ion_platform_heap *);
+void ion_cma_heap_destroy(struct ion_heap *);
+#endif
 
 struct ion_heap *msm_get_contiguous_heap(void);
+/**
+ * The carveout/cp heap returns physical addresses, since 0 may be a valid
+ * physical address, this is used to indicate allocation failed
+ */
 #define ION_CARVEOUT_ALLOCATE_FAIL -1
 #define ION_CP_ALLOCATE_FAIL -1
 
+/**
+ * The reserved heap returns physical addresses, since 0 may be a valid
+ * physical address, this is used to indicate allocation failed
+ */
 #define ION_RESERVED_ALLOCATE_FAIL -1
 
+/**
+ * ion_map_fmem_buffer - map fmem allocated memory into the kernel
+ * @buffer - buffer to map
+ * @phys_base - physical base of the heap
+ * @virt_base - virtual base of the heap
+ * @flags - flags for the heap
+ *
+ * Map fmem allocated memory into the kernel address space. This
+ * is designed to be used by other heaps that need fmem behavior.
+ * The virtual range must be pre-allocated.
+ */
 void *ion_map_fmem_buffer(struct ion_buffer *buffer, unsigned long phys_base,
 				void *virt_base, unsigned long flags);
 
+/**
+ * ion_do_cache_op - do cache operations.
+ *
+ * @client - pointer to ION client.
+ * @handle - pointer to buffer handle.
+ * @uaddr -  virtual address to operate on.
+ * @offset - offset from physical address.
+ * @len - Length of data to do cache operation on.
+ * @cmd - Cache operation to perform:
+ *		ION_IOC_CLEAN_CACHES
+ *		ION_IOC_INV_CACHES
+ *		ION_IOC_CLEAN_INV_CACHES
+ *
+ * Returns 0 on success
+ */
 int ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,
 			void *uaddr, unsigned long offset, unsigned long len,
 			unsigned int cmd);
@@ -178,4 +313,4 @@ void ion_cp_heap_get_base(struct ion_heap *heap, unsigned long *base,
 
 void ion_mem_map_show(struct ion_heap *heap);
 
-#endif 
+#endif /* _ION_PRIV_H */
diff --git a/drivers/gpu/ion/ion_system_heap.c b/drivers/gpu/ion/ion_system_heap.c
old mode 100644
new mode 100755
index 299c24c..e94a585
--- a/drivers/gpu/ion/ion_system_heap.c
+++ b/drivers/gpu/ion/ion_system_heap.c
@@ -2,7 +2,7 @@
  * drivers/gpu/ion/ion_system_heap.c
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -27,6 +27,8 @@
 #include "ion_priv.h"
 #include <mach/memory.h>
 #include <asm/cacheflush.h>
+#include <linux/msm_ion.h>
+#include <linux/dma-mapping.h>
 
 static atomic_t system_heap_allocated;
 static atomic_t system_contig_heap_allocated;
@@ -183,15 +185,30 @@ int ion_system_heap_cache_ops(struct ion_heap *heap, struct ion_buffer *buffer,
 
 	switch (cmd) {
 	case ION_IOC_CLEAN_CACHES:
-		dmac_clean_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+		else
+			dmac_clean_range(vaddr, vaddr + length);
 		outer_cache_op = outer_clean_range;
 		break;
 	case ION_IOC_INV_CACHES:
-		dmac_inv_range(vaddr, vaddr + length);
+		if (!vaddr)
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		else
+			dmac_inv_range(vaddr, vaddr + length);
 		outer_cache_op = outer_inv_range;
 		break;
 	case ION_IOC_CLEAN_INV_CACHES:
-		dmac_flush_range(vaddr, vaddr + length);
+		if (!vaddr) {
+			dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_TO_DEVICE);
+			dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				buffer->sg_table->nents, DMA_FROM_DEVICE);
+		} else {
+			dmac_flush_range(vaddr, vaddr + length);
+		}
 		outer_cache_op = outer_flush_range;
 		break;
 	default:
@@ -206,6 +223,10 @@ int ion_system_heap_cache_ops(struct ion_heap *heap, struct ion_buffer *buffer,
 		for_each_sg(table->sgl, sg, table->nents, i) {
 			struct page *page = sg_page(sg);
 			pstart = page_to_phys(page);
+			/*
+			 * If page -> phys is returning NULL, something
+			 * has really gone wrong...
+			 */
 			if (!pstart) {
 				WARN(1, "Could not translate virtual address to physical address\n");
 				return -EINVAL;
@@ -250,6 +271,14 @@ int ion_system_heap_map_iommu(struct ion_buffer *buffer,
 	data->mapped_size = iova_length;
 	extra = iova_length - buffer->size;
 
+	/* Use the biggest alignment to allow bigger IOMMU mappings.
+	 * Use the first entry since the first entry will always be the
+	 * biggest entry. To take advantage of bigger mapping sizes both the
+	 * VA and PA addresses have to be aligned to the biggest size.
+	 */
+	if (table->sgl->length > align)
+		align = table->sgl->length;
+
 	ret = msm_allocate_iova_address(domain_num, partition_num,
 						data->mapped_size, align,
 						&data->iova_addr);
@@ -478,7 +507,7 @@ int ion_system_contig_heap_map_iommu(struct ion_buffer *buffer,
 	}
 	page = virt_to_page(buffer->vaddr);
 
-	sglist = vmalloc(sizeof(*sglist));
+	sglist = kmalloc(sizeof(*sglist), GFP_KERNEL);
 	if (!sglist)
 		goto out1;
 
@@ -500,13 +529,13 @@ int ion_system_contig_heap_map_iommu(struct ion_buffer *buffer,
 		if (ret)
 			goto out2;
 	}
-	vfree(sglist);
+	kfree(sglist);
 	return ret;
 out2:
 	iommu_unmap_range(domain, data->iova_addr, buffer->size);
 
 out1:
-	vfree(sglist);
+	kfree(sglist);
 	msm_free_iova_address(data->iova_addr, domain_num, partition_num,
 						data->mapped_size);
 out:
diff --git a/drivers/gpu/ion/ion_system_mapper.c b/drivers/gpu/ion/ion_system_mapper.c
new file mode 100755
index 0000000..692458e
--- /dev/null
+++ b/drivers/gpu/ion/ion_system_mapper.c
@@ -0,0 +1,114 @@
+/*
+ * drivers/gpu/ion/ion_system_mapper.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/ion.h>
+#include <linux/memory.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include "ion_priv.h"
+/*
+ * This mapper is valid for any heap that allocates memory that already has
+ * a kernel mapping, this includes vmalloc'd memory, kmalloc'd memory,
+ * pages obtained via io_remap, etc.
+ */
+static void *ion_kernel_mapper_map(struct ion_mapper *mapper,
+				   struct ion_buffer *buffer,
+				   struct ion_mapping **mapping)
+{
+	if (!((1 << buffer->heap->type) & mapper->heap_mask)) {
+		pr_err("%s: attempting to map an unsupported heap\n", __func__);
+		return ERR_PTR(-EINVAL);
+	}
+	/* XXX REVISIT ME!!! */
+	*((unsigned long *)mapping) = (unsigned long)buffer->priv;
+	return buffer->priv;
+}
+
+static void ion_kernel_mapper_unmap(struct ion_mapper *mapper,
+				    struct ion_buffer *buffer,
+				    struct ion_mapping *mapping)
+{
+	if (!((1 << buffer->heap->type) & mapper->heap_mask))
+		pr_err("%s: attempting to unmap an unsupported heap\n",
+		       __func__);
+}
+
+static void *ion_kernel_mapper_map_kernel(struct ion_mapper *mapper,
+					struct ion_buffer *buffer,
+					struct ion_mapping *mapping)
+{
+	if (!((1 << buffer->heap->type) & mapper->heap_mask)) {
+		pr_err("%s: attempting to unmap an unsupported heap\n",
+		       __func__);
+		return ERR_PTR(-EINVAL);
+	}
+	return buffer->priv;
+}
+
+static int ion_kernel_mapper_map_user(struct ion_mapper *mapper,
+				      struct ion_buffer *buffer,
+				      struct vm_area_struct *vma,
+				      struct ion_mapping *mapping)
+{
+	int ret;
+
+	switch (buffer->heap->type) {
+	case ION_HEAP_KMALLOC:
+	{
+		unsigned long pfn = __phys_to_pfn(virt_to_phys(buffer->priv));
+		ret = remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,
+				      vma->vm_end - vma->vm_start,
+				      vma->vm_page_prot);
+		break;
+	}
+	case ION_HEAP_VMALLOC:
+		ret = remap_vmalloc_range(vma, buffer->priv, vma->vm_pgoff);
+		break;
+	default:
+		pr_err("%s: attempting to map unsupported heap to userspace\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static struct ion_mapper_ops ops = {
+	.map = ion_kernel_mapper_map,
+	.map_kernel = ion_kernel_mapper_map_kernel,
+	.map_user = ion_kernel_mapper_map_user,
+	.unmap = ion_kernel_mapper_unmap,
+};
+
+struct ion_mapper *ion_system_mapper_create(void)
+{
+	struct ion_mapper *mapper;
+	mapper = kzalloc(sizeof(struct ion_mapper), GFP_KERNEL);
+	if (!mapper)
+		return ERR_PTR(-ENOMEM);
+	mapper->type = ION_SYSTEM_MAPPER;
+	mapper->ops = &ops;
+	mapper->heap_mask = (1 << ION_HEAP_VMALLOC) | (1 << ION_HEAP_KMALLOC);
+	return mapper;
+}
+
+void ion_system_mapper_destroy(struct ion_mapper *mapper)
+{
+	kfree(mapper);
+}
+
diff --git a/drivers/gpu/ion/msm/Makefile b/drivers/gpu/ion/msm/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/gpu/ion/msm/ion_cp_common.c b/drivers/gpu/ion/msm/ion_cp_common.c
old mode 100644
new mode 100755
index b274ba2..41e0a04
--- a/drivers/gpu/ion/msm/ion_cp_common.c
+++ b/drivers/gpu/ion/msm/ion_cp_common.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2011 Google, Inc
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/gpu/ion/msm/ion_cp_common.h b/drivers/gpu/ion/msm/ion_cp_common.h
old mode 100644
new mode 100755
index 950966d..eec66e6
--- a/drivers/gpu/ion/msm/ion_cp_common.h
+++ b/drivers/gpu/ion/msm/ion_cp_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,12 +15,24 @@
 #define ION_CP_COMMON_H
 
 #include <asm-generic/errno-base.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 
 #define ION_CP_V1	1
 #define ION_CP_V2	2
 
 #if defined(CONFIG_ION_MSM)
+/*
+ * ion_cp2_protect_mem - secures memory via trustzone
+ *
+ * @chunks - physical address of the array containing the chunks to
+ *		be locked down
+ * @nchunks - number of entries in the array
+ * @chunk_size - size of each memory chunk
+ * @usage - usage hint
+ * @lock - 1 for lock, 0 for unlock
+ *
+ * return value is the result of the scm call
+ */
 int ion_cp_change_chunks_state(unsigned long chunks, unsigned int nchunks,
 			unsigned int chunk_size, enum cp_mem_usage usage,
 			int lock);
diff --git a/drivers/gpu/ion/msm/msm_ion.c b/drivers/gpu/ion/msm/msm_ion.c
old mode 100644
new mode 100755
index eeed1e1..d8acb39
--- a/drivers/gpu/ion/msm/msm_ion.c
+++ b/drivers/gpu/ion/msm/msm_ion.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,11 +13,12 @@
 
 #include <linux/export.h>
 #include <linux/err.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/memory_alloc.h>
 #include <linux/fmem.h>
+#include <linux/of.h>
 #include <linux/mm.h>
 #include <linux/mm_types.h>
 #include <linux/sched.h>
@@ -28,10 +29,81 @@
 #include "../ion_priv.h"
 #include "ion_cp_common.h"
 
+#define ION_COMPAT_STR	"qcom,msm-ion"
+#define ION_COMPAT_MEM_RESERVE_STR "qcom,msm-ion-reserve"
+
 static struct ion_device *idev;
 static int num_heaps;
 static struct ion_heap **heaps;
 
+struct ion_heap_desc {
+	unsigned int id;
+	enum ion_heap_type type;
+	const char *name;
+	unsigned int permission_type;
+};
+
+
+static struct ion_heap_desc ion_heap_meta[] = {
+	{
+		.id	= ION_SYSTEM_HEAP_ID,
+		.type	= ION_HEAP_TYPE_SYSTEM,
+		.name	= ION_VMALLOC_HEAP_NAME,
+	},
+	{
+		.id	= ION_SYSTEM_CONTIG_HEAP_ID,
+		.type	= ION_HEAP_TYPE_SYSTEM_CONTIG,
+		.name	= ION_KMALLOC_HEAP_NAME,
+	},
+	{
+		.id	= ION_CP_MM_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CP,
+		.name	= ION_MM_HEAP_NAME,
+		.permission_type = IPT_TYPE_MM_CARVEOUT,
+	},
+	{
+		.id	= ION_MM_FIRMWARE_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CARVEOUT,
+		.name	= ION_MM_FIRMWARE_HEAP_NAME,
+	},
+	{
+		.id	= ION_CP_MFC_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CP,
+		.name	= ION_MFC_HEAP_NAME,
+		.permission_type = IPT_TYPE_MFC_SHAREDMEM,
+	},
+	{
+		.id	= ION_SF_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CARVEOUT,
+		.name	= ION_SF_HEAP_NAME,
+	},
+	{
+		.id	= ION_IOMMU_HEAP_ID,
+		.type	= ION_HEAP_TYPE_IOMMU,
+		.name	= ION_IOMMU_HEAP_NAME,
+	},
+	{
+		.id	= ION_QSECOM_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CARVEOUT,
+		.name	= ION_QSECOM_HEAP_NAME,
+	},
+	{
+		.id	= ION_AUDIO_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CARVEOUT,
+		.name	= ION_AUDIO_HEAP_NAME,
+	},
+	{
+		.id	= ION_CP_WB_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CP,
+		.name	= ION_WB_HEAP_NAME,
+	},
+	{
+		.id	= ION_CAMERA_HEAP_ID,
+		.type	= ION_HEAP_TYPE_CARVEOUT,
+		.name	= ION_CAMERA_HEAP_NAME,
+	},
+};
+
 struct ion_client *msm_ion_client_create(unsigned int heap_mask,
 					const char *name)
 {
@@ -169,6 +241,15 @@ static void allocate_co_memory(struct ion_platform_heap *heap,
 	}
 }
 
+/* Fixup heaps in board file to support two heaps being adjacent to each other.
+ * A flag (adjacent_mem_id) in the platform data tells us that the heap phy
+ * memory location must be adjacent to the specified heap. We do this by
+ * carving out memory for both heaps and then splitting up the memory to the
+ * two heaps. The heap specifying the "adjacent_mem_id" get the base of the
+ * memory while heap specified in "adjacent_mem_id" get base+size as its
+ * base address.
+ * Note: Modifies platform data and allocates memory.
+ */
 static void msm_ion_heap_fixup(struct ion_platform_heap heap_data[],
 			       unsigned int nr_heaps)
 {
@@ -188,7 +269,7 @@ static void msm_ion_allocate(struct ion_platform_heap *heap)
 
 	if (!heap->base && heap->extra_data) {
 		unsigned int align = 0;
-		switch (heap->type) {
+		switch ((int) heap->type) {
 		case ION_HEAP_TYPE_CARVEOUT:
 			align =
 			((struct ion_co_heap_pdata *) heap->extra_data)->align;
@@ -265,6 +346,226 @@ static void check_for_heap_overlap(const struct ion_platform_heap heap_list[],
 	}
 }
 
+static int msm_init_extra_data(struct ion_platform_heap *heap,
+			       const struct ion_heap_desc *heap_desc)
+{
+	int ret = 0;
+
+	switch ((int) heap->type) {
+	case ION_HEAP_TYPE_CP:
+	{
+		heap->extra_data = kzalloc(sizeof(struct ion_cp_heap_pdata),
+					   GFP_KERNEL);
+		if (!heap->extra_data) {
+			ret = -ENOMEM;
+		} else {
+			struct ion_cp_heap_pdata *extra = heap->extra_data;
+			extra->permission_type = heap_desc->permission_type;
+		}
+		break;
+	}
+	case ION_HEAP_TYPE_CARVEOUT:
+	{
+		heap->extra_data = kzalloc(sizeof(struct ion_co_heap_pdata),
+					   GFP_KERNEL);
+		if (!heap->extra_data)
+			ret = -ENOMEM;
+		break;
+	}
+	default:
+		heap->extra_data = 0;
+		break;
+	}
+	return ret;
+}
+
+static int msm_ion_populate_heap(struct ion_platform_heap *heap)
+{
+	unsigned int i;
+	int ret = -EINVAL;
+	unsigned int len = ARRAY_SIZE(ion_heap_meta);
+	for (i = 0; i < len; ++i) {
+		if (ion_heap_meta[i].id == heap->id) {
+			heap->name = ion_heap_meta[i].name;
+			heap->type = ion_heap_meta[i].type;
+			ret = msm_init_extra_data(heap, &ion_heap_meta[i]);
+			break;
+		}
+	}
+	if (ret)
+		pr_err("%s: Unable to populate heap, error: %d", __func__, ret);
+	return ret;
+}
+
+static void free_pdata(const struct ion_platform_data *pdata)
+{
+	unsigned int i;
+	for (i = 0; i < pdata->nr; ++i)
+		kfree(pdata->heaps[i].extra_data);
+	kfree(pdata);
+}
+
+static int memtype_to_ion_memtype[] = {
+	[MEMTYPE_SMI_KERNEL] = ION_SMI_TYPE,
+	[MEMTYPE_SMI]	= ION_SMI_TYPE,
+	[MEMTYPE_EBI0] = ION_EBI_TYPE,
+	[MEMTYPE_EBI1] = ION_EBI_TYPE,
+};
+
+static void msm_ion_get_heap_align(struct device_node *node,
+				   struct ion_platform_heap *heap)
+{
+	unsigned int val;
+
+	int ret = of_property_read_u32(node, "qcom,heap-align", &val);
+	if (!ret) {
+		switch ((int) heap->type) {
+		case ION_HEAP_TYPE_CP:
+		{
+			struct ion_cp_heap_pdata *extra =
+						heap->extra_data;
+			extra->align = val;
+			break;
+		}
+		case ION_HEAP_TYPE_CARVEOUT:
+		{
+			struct ion_co_heap_pdata *extra =
+						heap->extra_data;
+			extra->align = val;
+			break;
+		}
+		default:
+			pr_err("ION-heap %s: Cannot specify alignment for this type of heap\n",
+					heap->name);
+			break;
+		}
+	}
+}
+
+static int msm_ion_get_heap_size(struct device_node *node,
+				 struct ion_platform_heap *heap)
+{
+	unsigned int val;
+	int ret = 0;
+	const char *memory_name_prop;
+
+	ret = of_property_read_u32(node, "qcom,memory-reservation-size", &val);
+	if (!ret) {
+		heap->size = val;
+		ret = of_property_read_string(node,
+					      "qcom,memory-reservation-type",
+					      &memory_name_prop);
+
+		if (!ret && memory_name_prop) {
+			val = msm_get_memory_type_from_name(memory_name_prop);
+			if (val < 0) {
+				ret = -EINVAL;
+				goto out;
+			}
+			heap->memory_type = memtype_to_ion_memtype[val];
+		}
+		if (heap->size && (ret || !memory_name_prop)) {
+			pr_err("%s: Need to specify reservation type\n",
+				__func__);
+			ret = -EINVAL;
+		}
+	} else {
+		ret = 0;
+	}
+out:
+	return ret;
+}
+
+
+static void msm_ion_get_heap_adjacent(struct device_node *node,
+				      struct ion_platform_heap *heap)
+{
+	unsigned int val;
+	int ret = of_property_read_u32(node, "qcom,heap-adjacent", &val);
+	if (!ret) {
+		switch (heap->type) {
+		case ION_HEAP_TYPE_CARVEOUT:
+		{
+			struct ion_co_heap_pdata *extra = heap->extra_data;
+			extra->adjacent_mem_id = val;
+			break;
+		}
+		default:
+			pr_err("ION-heap %s: Cannot specify adjcent mem id for this type of heap\n",
+				heap->name);
+			break;
+		}
+	} else {
+		switch (heap->type) {
+		case ION_HEAP_TYPE_CARVEOUT:
+		{
+			struct ion_co_heap_pdata *extra = heap->extra_data;
+			extra->adjacent_mem_id = INVALID_HEAP_ID;
+			break;
+		}
+		default:
+			break;
+		}
+	}
+}
+
+static struct ion_platform_data *msm_ion_parse_dt(
+					const struct device_node *dt_node)
+{
+	struct ion_platform_data *pdata = 0;
+	struct device_node *node;
+	uint32_t val = 0;
+	int ret = 0;
+	uint32_t num_heaps = 0;
+	int idx = 0;
+
+	for_each_child_of_node(dt_node, node)
+		num_heaps++;
+
+	if (!num_heaps)
+		return ERR_PTR(-EINVAL);
+
+	pdata = kzalloc(sizeof(struct ion_platform_data) +
+			num_heaps*sizeof(struct ion_platform_heap), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->nr = num_heaps;
+
+	for_each_child_of_node(dt_node, node) {
+		/**
+		 * TODO: Replace this with of_get_address() when this patch
+		 * gets merged: http://
+		 * permalink.gmane.org/gmane.linux.drivers.devicetree/18614
+		*/
+		ret = of_property_read_u32(node, "reg", &val);
+		if (ret) {
+			pr_err("%s: Unable to find reg key", __func__);
+			goto free_heaps;
+		}
+		pdata->heaps[idx].id = val;
+
+		ret = msm_ion_populate_heap(&pdata->heaps[idx]);
+		if (ret)
+			goto free_heaps;
+
+		msm_ion_get_heap_align(node, &pdata->heaps[idx]);
+
+		ret = msm_ion_get_heap_size(node, &pdata->heaps[idx]);
+		if (ret)
+			goto free_heaps;
+
+		msm_ion_get_heap_adjacent(node, &pdata->heaps[idx]);
+
+		++idx;
+	}
+	return pdata;
+
+free_heaps:
+	free_pdata(pdata);
+	return ERR_PTR(ret);
+}
+
 static int check_vaddr_bounds(unsigned long start, unsigned long end)
 {
 	struct mm_struct *mm = current->active_mm;
@@ -311,7 +612,7 @@ static long msm_ion_custom_ioctl(struct ion_client *client,
 		start = (unsigned long) data.vaddr;
 		end = (unsigned long) data.vaddr + data.length;
 
-		if (check_vaddr_bounds(start, end)) {
+		if (start && check_vaddr_bounds(start, end)) {
 			pr_err("%s: virtual address %p is out of bounds\n",
 				__func__, data.vaddr);
 			return -EINVAL;
@@ -363,9 +664,21 @@ static long msm_ion_custom_ioctl(struct ion_client *client,
 
 static int msm_ion_probe(struct platform_device *pdev)
 {
-	struct ion_platform_data *pdata = pdev->dev.platform_data;
-	int err;
+	struct ion_platform_data *pdata;
+	unsigned int pdata_needs_to_be_freed;
+	int err = -1;
 	int i;
+	if (pdev->dev.of_node) {
+		pdata = msm_ion_parse_dt(pdev->dev.of_node);
+		if (IS_ERR(pdata)) {
+			err = PTR_ERR(pdata);
+			goto out;
+		}
+		pdata_needs_to_be_freed = 1;
+	} else {
+		pdata = pdev->dev.platform_data;
+		pdata_needs_to_be_freed = 0;
+	}
 
 	num_heaps = pdata->nr;
 
@@ -384,7 +697,7 @@ static int msm_ion_probe(struct platform_device *pdev)
 
 	msm_ion_heap_fixup(pdata->heaps, num_heaps);
 
-	
+	/* create the heaps as specified in the board file */
 	for (i = 0; i < num_heaps; i++) {
 		struct ion_platform_heap *heap_data = &pdata->heaps[i];
 		msm_ion_allocate(heap_data);
@@ -407,6 +720,8 @@ static int msm_ion_probe(struct platform_device *pdev)
 
 		ion_device_add_heap(idev, heaps[i]);
 	}
+	if (pdata_needs_to_be_freed)
+		free_pdata(pdata);
 
 	check_for_heap_overlap(pdata->heaps, num_heaps);
 	platform_set_drvdata(pdev, idev);
@@ -414,6 +729,8 @@ static int msm_ion_probe(struct platform_device *pdev)
 
 freeheaps:
 	kfree(heaps);
+	if (pdata_needs_to_be_freed)
+		free_pdata(pdata);
 out:
 	return err;
 }
@@ -431,10 +748,19 @@ static int msm_ion_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct of_device_id msm_ion_match_table[] = {
+	{.compatible = ION_COMPAT_STR},
+	{},
+};
+EXPORT_COMPAT(ION_COMPAT_MEM_RESERVE_STR);
+
 static struct platform_driver msm_ion_driver = {
 	.probe = msm_ion_probe,
 	.remove = msm_ion_remove,
-	.driver = { .name = "ion-msm" }
+	.driver = {
+		.name = "ion-msm",
+		.of_match_table = msm_ion_match_table,
+	},
 };
 
 static int __init msm_ion_init(void)
diff --git a/drivers/gpu/ion/tegra/Makefile b/drivers/gpu/ion/tegra/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/gpu/ion/tegra/tegra_ion.c b/drivers/gpu/ion/tegra/tegra_ion.c
new file mode 100755
index 0000000..7af6e16
--- /dev/null
+++ b/drivers/gpu/ion/tegra/tegra_ion.c
@@ -0,0 +1,96 @@
+/*
+ * drivers/gpu/tegra/tegra_ion.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/ion.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include "../ion_priv.h"
+
+struct ion_device *idev;
+struct ion_mapper *tegra_user_mapper;
+int num_heaps;
+struct ion_heap **heaps;
+
+int tegra_ion_probe(struct platform_device *pdev)
+{
+	struct ion_platform_data *pdata = pdev->dev.platform_data;
+	int err;
+	int i;
+
+	num_heaps = pdata->nr;
+
+	heaps = kzalloc(sizeof(struct ion_heap *) * pdata->nr, GFP_KERNEL);
+
+	idev = ion_device_create(NULL);
+	if (IS_ERR_OR_NULL(idev)) {
+		kfree(heaps);
+		return PTR_ERR(idev);
+	}
+
+	/* create the heaps as specified in the board file */
+	for (i = 0; i < num_heaps; i++) {
+		struct ion_platform_heap *heap_data = &pdata->heaps[i];
+
+		heaps[i] = ion_heap_create(heap_data);
+		if (IS_ERR_OR_NULL(heaps[i])) {
+			err = PTR_ERR(heaps[i]);
+			goto err;
+		}
+		ion_device_add_heap(idev, heaps[i]);
+	}
+	platform_set_drvdata(pdev, idev);
+	return 0;
+err:
+	for (i = 0; i < num_heaps; i++) {
+		if (heaps[i])
+			ion_heap_destroy(heaps[i]);
+	}
+	kfree(heaps);
+	return err;
+}
+
+int tegra_ion_remove(struct platform_device *pdev)
+{
+	struct ion_device *idev = platform_get_drvdata(pdev);
+	int i;
+
+	ion_device_destroy(idev);
+	for (i = 0; i < num_heaps; i++)
+		ion_heap_destroy(heaps[i]);
+	kfree(heaps);
+	return 0;
+}
+
+static struct platform_driver ion_driver = {
+	.probe = tegra_ion_probe,
+	.remove = tegra_ion_remove,
+	.driver = { .name = "ion-tegra" }
+};
+
+static int __init ion_init(void)
+{
+	return platform_driver_register(&ion_driver);
+}
+
+static void __exit ion_exit(void)
+{
+	platform_driver_unregister(&ion_driver);
+}
+
+module_init(ion_init);
+module_exit(ion_exit);
+
diff --git a/drivers/gpu/msm/kgsl.h b/drivers/gpu/msm/kgsl.h
index b1c510a..772696f 100644
--- a/drivers/gpu/msm/kgsl.h
+++ b/drivers/gpu/msm/kgsl.h
@@ -22,7 +22,7 @@
 #include <linux/cdev.h>
 #include <linux/regulator/consumer.h>
 #include <linux/mm.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 
 #include <mach/kgsl.h>
 
diff --git a/drivers/gpu/msm/kgsl_sharedmem.c b/drivers/gpu/msm/kgsl_sharedmem.c
index b53e0c6..bf3973f 100644
--- a/drivers/gpu/msm/kgsl_sharedmem.c
+++ b/drivers/gpu/msm/kgsl_sharedmem.c
@@ -822,7 +822,7 @@ void kgsl_cache_range_op(struct kgsl_memdesc *memdesc, int op)
         goto done;
     }
 
-    handle = ion_alloc(kgsl_client, size, SZ_4K, 0x1 << ION_SF_HEAP_ID);
+    handle = ion_alloc(kgsl_client, size, SZ_4K, 0x1 << ION_SF_HEAP_ID, 0);
     if (IS_ERR_OR_NULL(handle)) {
         ret = -ENOMEM;
         goto done;
diff --git a/drivers/media/video/msm/gemini/msm_gemini_platform.c b/drivers/media/video/msm/gemini/msm_gemini_platform.c
index 31fc5f9..93dbd32 100644
--- a/drivers/media/video/msm/gemini/msm_gemini_platform.c
+++ b/drivers/media/video/msm/gemini/msm_gemini_platform.c
@@ -51,7 +51,7 @@ uint32_t msm_gemini_platform_v2p(int fd, uint32_t len, struct file **file_p,
 		return 0;
 
 	rc = ion_map_iommu(gemini_client, *ionhandle, CAMERA_DOMAIN, GEN_POOL,
-			SZ_4K, 0, &paddr, (unsigned long *)&size, UNCACHED, 0);
+			SZ_4K, 0, &paddr, (unsigned long *)&size, 0, 0);
 #elif CONFIG_ANDROID_PMEM
 	unsigned long kvstart;
 	rc = get_pmem_file(fd, &paddr, &kvstart, &size, file_p);
diff --git a/drivers/media/video/msm/msm_mem.c b/drivers/media/video/msm/msm_mem.c
index 31a7858..d53a368 100644
--- a/drivers/media/video/msm/msm_mem.c
+++ b/drivers/media/video/msm/msm_mem.c
@@ -137,7 +137,7 @@ static int msm_pmem_table_add(struct hlist_head *ptype,
 	if (IS_ERR_OR_NULL(region->handle))
 		goto out1;
 	if (ion_map_iommu(client, region->handle, CAMERA_DOMAIN, GEN_POOL,
-				  SZ_4K, 0, &paddr, &len, UNCACHED, 0) < 0)
+				  SZ_4K, 0, &paddr, &len, 0, 0) < 0)
 		goto out2;
 #elif CONFIG_ANDROID_PMEM
 	rc = get_pmem_file(info->fd, &paddr, &kvstart, &len, &file);
diff --git a/drivers/media/video/msm/wfd/Makefile b/drivers/media/video/msm/wfd/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/enc-subdev.c b/drivers/media/video/msm/wfd/enc-subdev.c
old mode 100755
new mode 100644
index 02b517f..79e3e99
--- a/drivers/media/video/msm/wfd/enc-subdev.c
+++ b/drivers/media/video/msm/wfd/enc-subdev.c
@@ -1406,7 +1406,7 @@ static long venc_set_vui_timing_info(struct video_client_ctx *client_ctx,
 	if (!client_ctx)
 		return -EINVAL;
 	if (inst->framerate_mode == VENC_MODE_VFR) {
-		WFD_MSG_ERR("VUI timing info not suported in VFR mode ");
+		WFD_MSG_INFO("VUI timing info not suported in VFR mode ");
 		return -EINVAL;
 	}
 	vcd_property_hdr.prop_id = VCD_I_ENABLE_VUI_TIMING_INFO;
@@ -2035,11 +2035,11 @@ static long venc_alloc_recon_buffers(struct v4l2_subdev *sd, void *arg)
 			ctrl->user_virtual_addr = (void *)i;
 			client_ctx->recon_buffer_ion_handle[i]
 				= ion_alloc(client_ctx->user_ion_client,
-			control.size, SZ_8K, flags);
+                                            control.size, SZ_8K, flags, 0);
 
 			ctrl->kernel_virtual_addr = ion_map_kernel(
 				client_ctx->user_ion_client,
-				client_ctx->recon_buffer_ion_handle[i],	0);
+				client_ctx->recon_buffer_ion_handle[i]);
 
 			rc = ion_map_iommu(client_ctx->user_ion_client,
 				client_ctx->recon_buffer_ion_handle[i],
diff --git a/drivers/media/video/msm/wfd/enc-subdev.h b/drivers/media/video/msm/wfd/enc-subdev.h
old mode 100755
new mode 100644
index 112a6ed..00a3273
--- a/drivers/media/video/msm/wfd/enc-subdev.h
+++ b/drivers/media/video/msm/wfd/enc-subdev.h
@@ -14,7 +14,7 @@
 #ifndef _WFD_ENC_SUBDEV_
 #define _WFD_ENC_SUBDEV_
 
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <media/v4l2-subdev.h>
 #include <media/videobuf2-core.h>
 #define VENC_MAGIC_IOCTL 'V'
diff --git a/drivers/media/video/msm/wfd/mdp-subdev.c b/drivers/media/video/msm/wfd/mdp-subdev.c
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/mdp-subdev.h b/drivers/media/video/msm/wfd/mdp-subdev.h
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/vsg-subdev.c b/drivers/media/video/msm/wfd/vsg-subdev.c
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/vsg-subdev.h b/drivers/media/video/msm/wfd/vsg-subdev.h
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/wfd-ioctl.c b/drivers/media/video/msm/wfd/wfd-ioctl.c
old mode 100755
new mode 100644
index fb32fec..575d1bc
--- a/drivers/media/video/msm/wfd/wfd-ioctl.c
+++ b/drivers/media/video/msm/wfd/wfd-ioctl.c
@@ -163,7 +163,7 @@ static int wfd_allocate_ion_buffer(struct ion_client *client,
 	alloc_regions |= secure ? ION_SECURE :
 				ION_HEAP(ION_IOMMU_HEAP_ID);
 	handle = ion_alloc(client,
-			mregion->size, SZ_4K, alloc_regions);
+                           mregion->size, SZ_4K, alloc_regions, ION_FLAG_CACHED);
 
 	if (IS_ERR_OR_NULL(handle)) {
 		WFD_MSG_ERR("Failed to allocate input buffer\n");
@@ -171,7 +171,7 @@ static int wfd_allocate_ion_buffer(struct ion_client *client,
 		goto alloc_fail;
 	}
 
-	kvaddr = ion_map_kernel(client,	handle,	CACHED);
+	kvaddr = ion_map_kernel(client,	handle);
 
 	if (IS_ERR_OR_NULL(kvaddr)) {
 		WFD_MSG_ERR("Failed to get virtual addr\n");
diff --git a/drivers/media/video/msm/wfd/wfd-util.c b/drivers/media/video/msm/wfd/wfd-util.c
old mode 100755
new mode 100644
diff --git a/drivers/media/video/msm/wfd/wfd-util.h b/drivers/media/video/msm/wfd/wfd-util.h
old mode 100755
new mode 100644
diff --git a/drivers/media/video/videobuf2-msm-mem.c b/drivers/media/video/videobuf2-msm-mem.c
index 56abec8..90a0abc 100644
--- a/drivers/media/video/videobuf2-msm-mem.c
+++ b/drivers/media/video/videobuf2-msm-mem.c
@@ -30,7 +30,7 @@
 #include <media/msm_camera.h>
 #include <mach/memory.h>
 #include <mach/msm_subsystem_map.h>
-
+#include<linux/msm_ion.h>
 #include <media/videobuf2-core.h>
 
 #define MAGIC_PMEM 0x0733ac64
@@ -57,7 +57,7 @@ static unsigned long msm_mem_allocate(struct videobuf2_contig_pmem *mem)
 		goto client_failed;
 	}
 	mem->ion_handle = ion_alloc(mem->client, mem->size, SZ_4K,
-		(0x1 << ION_CP_MM_HEAP_ID | 0x1 << ION_IOMMU_HEAP_ID));
+                                    (0x1 << ION_CP_MM_HEAP_ID | 0x1 << ION_IOMMU_HEAP_ID), 0);
 	if (IS_ERR((void *)mem->ion_handle)) {
 		pr_err("%s Could not allocate\n", __func__);
 		goto alloc_failed;
@@ -65,7 +65,7 @@ static unsigned long msm_mem_allocate(struct videobuf2_contig_pmem *mem)
 	rc = ion_map_iommu(mem->client, mem->ion_handle,
 			CAMERA_DOMAIN, GEN_POOL, SZ_4K, 0,
 			(unsigned long *)&phyaddr,
-			(unsigned long *)&len, UNCACHED, 0);
+			(unsigned long *)&len, 0, 0);
 	if (rc < 0) {
 		pr_err("%s Could not get physical address\n", __func__);
 		goto phys_failed;
@@ -182,7 +182,7 @@ int videobuf2_pmem_contig_user_get(struct videobuf2_contig_pmem *mem,
 		return PTR_ERR(mem->ion_handle);
 	}
 	rc = ion_map_iommu(client, mem->ion_handle, CAMERA_DOMAIN, GEN_POOL,
-		SZ_4K, 0, (unsigned long *)&mem->phyaddr, &len, UNCACHED, 0);
+		SZ_4K, 0, (unsigned long *)&mem->phyaddr, &len, 0, 0);
 	if (rc < 0)
 		ion_free(client, mem->ion_handle);
 #elif CONFIG_ANDROID_PMEM
diff --git a/drivers/staging/android/lowmemorykiller.c b/drivers/staging/android/lowmemorykiller.c
index 1b09007..f8d6d20 100644
--- a/drivers/staging/android/lowmemorykiller.c
+++ b/drivers/staging/android/lowmemorykiller.c
@@ -38,7 +38,6 @@
 #include <linux/rcupdate.h>
 #include <linux/notifier.h>
 
-extern void show_meminfo(void);
 static uint32_t lowmem_debug_level = 2;
 static int lowmem_adj[6] = {
 	0,
@@ -235,7 +234,6 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 		lowmem_deathpending_timeout = jiffies + HZ;
 		if (selected_oom_adj < 7)
 		{
-			show_meminfo();
 			dump_tasks();
 		}
 		send_sig(SIGKILL, selected, 0);
diff --git a/drivers/video/msm/mdp.h b/drivers/video/msm/mdp.h
index 6cef732..9093bca 100644
--- a/drivers/video/msm/mdp.h
+++ b/drivers/video/msm/mdp.h
@@ -24,7 +24,7 @@
 #include <linux/msm_mdp.h>
 #include <linux/memory_alloc.h>
 #include <mach/hardware.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 
 #ifdef CONFIG_MSM_BUS_SCALING
 #include <mach/msm_bus.h>
diff --git a/drivers/video/msm/mdp4_util.c b/drivers/video/msm/mdp4_util.c
index fb27499..e389927 100644
--- a/drivers/video/msm/mdp4_util.c
+++ b/drivers/video/msm/mdp4_util.c
@@ -25,6 +25,7 @@
 #include <linux/semaphore.h>
 #include <linux/uaccess.h>
 #include <linux/msm_mdp.h>
+#include <linux/msm_ion.h>
 #include <asm/system.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
@@ -2544,7 +2545,7 @@ u32 mdp4_allocate_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num)
 		pr_info("%s:%d ion based allocation mfd->mem_hid 0x%x\n",
 			__func__, __LINE__, mfd->mem_hid);
 		buf->ihdl = ion_alloc(mfd->iclient, buffer_size, SZ_4K,
-			mfd->mem_hid);
+			mfd->mem_hid, 0);
 		if (!IS_ERR_OR_NULL(buf->ihdl)) {
 			if (mdp_iommu_split_domain) {
 				if (ion_map_iommu(mfd->iclient, buf->ihdl,
diff --git a/drivers/video/msm/msm_fb.c b/drivers/video/msm/msm_fb.c
index deb9c6a..af7c1c2 100644
--- a/drivers/video/msm/msm_fb.c
+++ b/drivers/video/msm/msm_fb.c
@@ -4456,7 +4456,7 @@ static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 						usb_pjt_client, usb_pjt_handle[i], tmp_info.latest_offset);
 					break;
 				}
-				virt_addr[i] = ion_map_kernel(usb_pjt_client, usb_pjt_handle[i], ionflag);
+				virt_addr[i] = ion_map_kernel(usb_pjt_client, usb_pjt_handle[i]);
 				mem_fd[i] = tmp_info.latest_offset;
 				usb_pjt_info.latest_offset = tmp_info.latest_offset;
 				MSM_FB_INFO("%s: fd = %d, virt %p\n", __func__, mem_fd[i], virt_addr[i]);
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
index 0277a56..4127eeb 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -88,7 +88,13 @@ u32 ddl_device_init(struct ddl_init_config *ddl_init_config,
 			ddl_context->dram_base_a.align_virtual_addr;
 	}
 	if (!status) {
-		ddl_context->metadata_shared_input.mem_type = DDL_FW_MEM;
+		if (res_trk_get_enable_sec_metadata()) {
+			ddl_context->metadata_shared_input.mem_type =
+				DDL_CMD_MEM;
+		} else {
+			ddl_context->metadata_shared_input.mem_type =
+				DDL_FW_MEM;
+		}
 		ptr = ddl_pmem_alloc(&ddl_context->metadata_shared_input,
 			DDL_METADATA_TOTAL_INPUTBUFSIZE,
 			DDL_LINEAR_BUFFER_ALIGN_BYTES);
@@ -198,7 +204,9 @@ u32 ddl_open(u32 **ddl_handle, u32 decoding)
 		ddl->client_state = DDL_CLIENT_OPEN;
 		ddl->codec_data.hdr.decoding = decoding;
 		ddl->decoding = decoding;
-		ddl_set_default_meta_data_hdr(ddl);
+		if (!res_trk_check_for_sec_session() ||
+				res_trk_get_enable_sec_metadata())
+			ddl_set_default_meta_data_hdr(ddl);
 		ddl_set_initial_default_values(ddl);
 		*ddl_handle	= (u32 *) ddl;
 	} else {
@@ -279,6 +287,25 @@ u32 ddl_encode_start(u32 *ddl_handle, void *client_data)
 		return VCD_ERR_ILLEGAL_OP;
 	}
 	encoder = &ddl->codec_data.encoder;
+	if (DDL_IS_LTR_ENABLED(encoder)) {
+		DDL_MSG_HIGH("LTR enabled, mode %u count %u",
+			(u32)encoder->ltr_control.ltrmode.ltr_mode,
+			(u32)encoder->ltr_control.ltr_count);
+		status = ddl_allocate_ltr_list(&encoder->ltr_control);
+		if (status) {
+			DDL_MSG_ERROR("%s: allocate ltr list failed",
+				__func__);
+			return status;
+		} else {
+			ddl_clear_ltr_list(&encoder->ltr_control, false);
+		}
+		encoder->num_references_for_p_frame = 2;
+		encoder->ltr_control.callback_reqd = false;
+		encoder->ltr_control.curr_ltr_id = (u32)DDL_LTR_FRAME_START_ID;
+		DDL_MSG_HIGH("num_ref_for_p_frames %u, curr_ltr_id = %u",
+			(u32)encoder->num_references_for_p_frame,
+			(u32)encoder->ltr_control.curr_ltr_id);
+	}
 	status = ddl_allocate_enc_hw_buffers(ddl);
 	if (status)
 		return status;
@@ -471,14 +498,6 @@ u32 ddl_encode_frame(u32 *ddl_handle,
 	struct ddl_encoder_data *encoder =
 		&ddl->codec_data.encoder;
 	u32 vcd_status = VCD_S_SUCCESS;
-	struct vcd_transc *transc;
-	
-	if (!ddl) {
-		DDL_MSG_ERROR("ddl_enc_frame:Bad_handle");
-		return VCD_ERR_BAD_HANDLE;
-	}
-	
-	transc = (struct vcd_transc *)(ddl->client_data);
 	DDL_MSG_LOW("%s: transc = 0x%x", __func__, (u32)ddl->client_data);
 	if (encoder->slice_delivery_info.enable) {
 		return ddl_encode_frame_batch(ddl_handle,
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h
index 400a3a7..30e3c52 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -52,6 +52,19 @@
 #define DDLCLIENT_STATE_IS(ddl, state) \
 	(state == (ddl)->client_state)
 
+#define DDL_IS_LTR_ENABLED(encoder) \
+	((encoder->ltr_control.ltrmode.ltr_mode == \
+		VCD_LTR_MODE_AUTO || \
+	encoder->ltr_control.ltrmode.ltr_mode == \
+		VCD_LTR_MODE_MANUAL) && \
+	(encoder->ltr_control.ltr_count > 0))
+
+#define DDL_IS_LTR_IN_AUTO_MODE(encoder) \
+	((encoder->ltr_control.ltrmode.ltr_mode == \
+		VCD_LTR_MODE_AUTO) && \
+	(encoder->ltr_control.ltr_count > 0) && \
+	(encoder->ltr_control.ltr_period > 0))
+
 #define DDL_DPB_OP_INIT       1
 #define DDL_DPB_OP_MARK_FREE  2
 #define DDL_DPB_OP_MARK_BUSY  3
@@ -72,6 +85,7 @@
 #define DDL_ENC_CHANGE_BITRATE    0x04
 #define DDL_ENC_CHANGE_FRAMERATE  0x08
 #define DDL_ENC_CHANGE_CIR        0x10
+#define DDL_ENC_LTR_USE_FRAME     0x20
 
 #define DDL_DEC_REQ_OUTPUT_FLUSH  0x1
 
@@ -86,6 +100,9 @@
 
 #define MDP_MIN_TILE_HEIGHT			96
 
+#define DDL_MAX_NUM_LTR_FRAMES      2
+#define DDL_LTR_FRAME_START_ID      1
+
 enum ddl_mem_area {
 	DDL_FW_MEM	= 0x0,
 	DDL_MM_MEM	= 0x1,
@@ -188,6 +205,7 @@ struct ddl_dec_buffers{
 	struct ddl_buf_addr h264_nb_ip;
 	struct ddl_buf_addr context;
 	struct ddl_buf_addr extnuserdata;
+	struct ddl_buf_addr meta_hdr[DDL_MAX_BUFFER_COUNT];
 };
 struct ddl_enc_buffer_size{
 	u32  sz_cur_y;
@@ -242,6 +260,39 @@ struct ddl_mp2_datadumpenabletype {
 	u32 seqdisp_extdump_enable;
 	u32 seq_extdump_enable;
 };
+struct ddl_ltrlist {
+	bool ltr_in_use;
+	u32 ltr_id;
+};
+struct ddl_ltr_encoding_type {
+	struct vcd_property_ltrmode_type ltrmode;
+	struct vcd_property_ltruse_type failed_use_cmd;
+	struct ddl_ltrlist *ltr_list;
+	u32 ltr_count;
+	u32 ltr_period;
+	u32 ltr_use_frames;
+	u32 curr_ltr_id;
+	u32 storing_idx;
+	u32 out_frame_cnt_to_use_this_ltr;
+	u32 out_frame_cnt_before_next_idr;
+	bool storing;
+	bool callback_reqd;
+	bool meta_data_reqd;
+	bool using;
+	bool first_ltr_use_arvd;
+	bool use_ltr_reqd;
+	bool store_for_intraframe_insertion;
+	bool pending_chg_ltr_useframes; /* True if
+		* corresponding driver context of
+		* out_frame_cnt_to_use_this_ltr
+		* is pending to be changed with
+		* client settings
+		*/
+	bool store_ltr0;
+	bool store_ltr1;
+	bool use_ltr0;
+	bool use_ltr1;
+};
 struct ddl_encoder_data{
 	struct ddl_codec_data_hdr   hdr;
 	struct vcd_property_codec   codec;
@@ -275,6 +326,7 @@ struct ddl_encoder_data{
 	struct ddl_enc_buffers  hw_bufs;
 	struct ddl_yuv_buffer_size  input_buf_size;
 	struct vidc_1080p_enc_frame_info enc_frame_info;
+	struct ddl_ltr_encoding_type ltr_control;
 	u32  meta_data_enable_flag;
 	u32  suffix;
 	u32  meta_data_offset;
@@ -290,8 +342,12 @@ struct ddl_encoder_data{
 	u32  num_references_for_p_frame;
 	u32  closed_gop;
 	u32  num_slices_comp;
+	bool intra_period_changed;
 	struct vcd_property_slice_delivery_info slice_delivery_info;
 	struct ddl_batch_frame_data batch_frame;
+	u32 avc_delimiter_enable;
+	u32 vui_timinginfo_enable;
+	u32 bitstream_restrict_enable;
 };
 struct ddl_decoder_data {
 	struct ddl_codec_data_hdr  hdr;
@@ -507,4 +563,20 @@ void ddl_get_fw_info(const unsigned char **fw_array_addr,
 void ddl_vidc_decode_reset_avg_time(struct ddl_client_context *ddl);
 void ddl_calc_core_proc_time(const char *func_name, u32 index,
 		struct ddl_client_context *ddl);
+s32 ddl_encoder_ltr_control(struct ddl_client_context *ddl);
+void ddl_encoder_use_ltr_fail_callback(
+	struct ddl_client_context *ddl);
+void ddl_handle_ltr_in_framedone(struct ddl_client_context *ddl);
+s32 ddl_clear_ltr_list(struct ddl_ltr_encoding_type *ltr_control,
+	bool only_use_flag);
+s32 ddl_find_oldest_ltr_not_in_use(
+	struct ddl_ltr_encoding_type *ltr_control);
+s32 ddl_find_ltr_in_use(struct ddl_ltr_encoding_type *ltr_control);
+s32 ddl_find_ltr_from_list(struct ddl_ltr_encoding_type *ltr_control,
+	u32 ltr_id);
+s32 ddl_use_ltr_from_list(struct ddl_ltr_encoding_type *ltr_control,
+	u32 ltr_idx);
+s32 ddl_allocate_ltr_list(struct ddl_ltr_encoding_type *ltr_control);
+s32 ddl_free_ltr_list(struct ddl_ltr_encoding_type *ltr_control);
+void ddl_print_ltr_list(struct ddl_ltr_encoding_type *ltr_control);
 #endif
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_api.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_api.h
index 5c1ee21..3a7e443 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_api.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_api.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h
index 3278ede..5685009 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -55,7 +55,7 @@
 #define VCD_FRAME_COMMAND_DEPTH          VCD_SINGLE_FRAME_COMMAND_CHANNEL
 #define VCD_GENEVIDC_COMMAND_DEPTH        1
 #define VCD_COMMAND_EXCLUSIVE            true
-#define DDL_HW_TIMEOUT_IN_MS             5000
+#define DDL_HW_TIMEOUT_IN_MS             1000
 #define DDL_STREAMBUF_ALIGN_GUARD_BYTES  0x7FF
 
 #define DDL_VIDC_1080P_48MHZ			(48000000)
@@ -154,4 +154,10 @@
 #define VIDC_SM_ERR_CONCEALMENT_INTER_SLICE_MB_COPY		2
 #define VIDC_SM_ERR_CONCEALMENT_INTRA_SLICE_COLOR_CONCEALMENT	1
 
+#define DDL_MAX_P_FRAMES_IN_INTRA_INTERVAL 0xffff
+
+#define DDL_SATURATE_P_FRAMES_IN_INTRA_INTERVAL(p_rames) \
+	(((p_rames) > (DDL_MAX_P_FRAMES_IN_INTRA_INTERVAL - 1)) ? \
+	(DDL_MAX_P_FRAMES_IN_INTRA_INTERVAL) : (p_rames))
+
 #endif
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c
index 3620f1a..75aa031 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -70,7 +70,6 @@ static u32 ddl_handle_hw_fatal_errors(struct ddl_client_context *ddl)
 	case VIDC_1080P_ERROR_MEM_ALLOCATION_FAILED:
 	case VIDC_1080P_ERROR_INSUFFICIENT_CONTEXT_SIZE:
 	case VIDC_1080P_ERROR_DIVIDE_BY_ZERO:
-	case VIDC_1080P_ERROR_DESCRIPTOR_BUFFER_EMPTY:
 	case VIDC_1080P_ERROR_DMA_TX_NOT_COMPLETE:
 	case VIDC_1080P_ERROR_VSP_NOT_READY:
 	case VIDC_1080P_ERROR_BUFFER_FULL_STATE:
@@ -219,6 +218,7 @@ static u32 ddl_handle_core_recoverable_errors(
 			}
 			break;
 		}
+	case VIDC_1080P_ERROR_NON_IDR_FRAME_TYPE:
 	case VIDC_1080P_ERROR_BIT_STREAM_BUF_EXHAUST:
 	case VIDC_1080P_ERROR_DESCRIPTOR_TABLE_ENTRY_INVALID:
 	case VIDC_1080P_ERROR_MB_COEFF_NOT_DONE:
@@ -235,24 +235,29 @@ static u32 ddl_handle_core_recoverable_errors(
 	case VIDC_1080P_ERROR_MV_RANGE_ERR:
 	case VIDC_1080P_ERROR_PICTURE_STRUCTURE_ERR:
 	case VIDC_1080P_ERROR_SLICE_ADDR_INVALID:
-	case VIDC_1080P_ERROR_NON_FRAME_DATA_RECEIVED:
 	case VIDC_1080P_ERROR_NALU_HEADER_ERROR:
 	case VIDC_1080P_ERROR_SPS_PARSE_ERROR:
 	case VIDC_1080P_ERROR_PPS_PARSE_ERROR:
 	case VIDC_1080P_ERROR_HEADER_NOT_FOUND:
 	case VIDC_1080P_ERROR_SLICE_PARSE_ERROR:
 	case VIDC_1080P_ERROR_NON_PAIRED_FIELD_NOT_SUPPORTED:
+	case VIDC_1080P_ERROR_DESCRIPTOR_BUFFER_EMPTY:
 		vcd_status = VCD_ERR_BITSTREAM_ERR;
-		DDL_MSG_ERROR("VIDC_BIT_STREAM_ERR");
+		DDL_MSG_ERROR("VIDC_BIT_STREAM_ERR (%u)",
+			(u32)ddl_context->cmd_err_status);
 		break;
 	case VIDC_1080P_ERROR_B_FRAME_NOT_SUPPORTED:
 	case VIDC_1080P_ERROR_UNSUPPORTED_FEATURE_IN_PROFILE:
 	case VIDC_1080P_ERROR_RESOLUTION_NOT_SUPPORTED:
 		if (ddl->decoding) {
 			vcd_status = VCD_ERR_BITSTREAM_ERR;
-			DDL_MSG_ERROR("VIDC_BIT_STREAM_ERR");
+			DDL_MSG_ERROR("VIDC_BIT_STREAM_ERR (%u)",
+				(u32)ddl_context->cmd_err_status);
 		}
 		break;
+	case VIDC_1080P_ERROR_NON_FRAME_DATA_RECEIVED:
+		vcd_status = VCD_ERR_BITSTREAM_ERR;
+		break;
 	default:
 		break;
 	}
@@ -364,7 +369,7 @@ u32 ddl_handle_core_errors(struct ddl_context *ddl_context)
 	disp_status = ddl_handle_core_warnings(
 		ddl_context->disp_pic_err_status);
 	if (!status && !disp_status) {
-		DDL_MSG_ERROR("ddl_warning:Unknown");
+		DDL_MSG_HIGH("ddl_warning:Unknown");
 		status = ddl_handle_hw_fatal_errors(ddl);
 		if (!status)
 			status = ddl_handle_core_recoverable_errors(ddl);
@@ -394,7 +399,7 @@ static u32 ddl_handle_dec_seq_hdr_fail_error(struct ddl_client_context *ddl)
 
 	if ((ddl->cmd_state != DDL_CMD_HEADER_PARSE) ||
 		(ddl->client_state != DDL_CLIENT_WAIT_FOR_INITCODECDONE)) {
-		DDL_MSG_ERROR("STATE-CRITICAL-HDDONE");
+		DDL_MSG_HIGH("STATE-CRITICAL-HDDONE");
 		return false;
 	}
 
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
index 00addbe..f5fb24f 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -10,7 +10,7 @@
  * GNU General Public License for more details.
  *
  */
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <mach/msm_memtypes.h>
 #include "vcd_ddl.h"
 #include "vcd_ddl_shared_mem.h"
@@ -172,22 +172,16 @@ u32 ddl_decoder_dpb_transact(struct ddl_decoder_data *decoder,
 				    (in_out_frame->vcd_frm.buff_ion_handle)) {
 					struct ddl_context *ddl_context =
 						ddl_get_context();
-					unsigned long *vaddr =
-						(unsigned long *)((u32)
-						in_out_frame->vcd_frm.virtual +
-						decoder->meta_data_offset);
-					DDL_MSG_LOW("%s: Cache clean: vaddr"\
-						" (%p), offset %u, size %u",
-						__func__,
-						in_out_frame->vcd_frm.virtual,
-						decoder->meta_data_offset,
-						decoder->suffix);
+					DDL_MSG_LOW("%s: Cache clean: size %u",
+						__func__, in_out_frame->vcd_frm.
+						alloc_len);
 					msm_ion_do_cache_op(
 						ddl_context->video_ion_client,
 						in_out_frame->vcd_frm.\
 						buff_ion_handle,
-						vaddr,
-						(unsigned long)decoder->suffix,
+						NULL,
+						(unsigned long)in_out_frame->
+						vcd_frm.alloc_len,
 						ION_IOC_CLEAN_CACHES);
 				}
 			}
@@ -258,46 +252,60 @@ u32 ddl_decoder_dpb_init(struct ddl_client_context *ddl)
 	struct ddl_context *ddl_context = ddl->ddl_context;
 	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
 	struct ddl_dec_buffers *dec_buffers = &decoder->hw_bufs;
-	struct ddl_frame_data_tag *frame;
+	struct vcd_frame_data *vcd_frm;
 	u32 luma[DDL_MAX_BUFFER_COUNT], chroma[DDL_MAX_BUFFER_COUNT];
 	u32 mv[DDL_MAX_BUFFER_COUNT], luma_size, i, dpb;
-	frame = &decoder->dp_buf.dec_pic_buffers[0];
 	luma_size = ddl_get_yuv_buf_size(decoder->frame_size.width,
 			decoder->frame_size.height, DDL_YUV_BUF_TYPE_TILE);
 	dpb = decoder->dp_buf.no_of_dec_pic_buf;
-	DDL_MSG_LOW("%s Decoder num DPB buffers = %u Luma Size = %u"
+	DDL_MSG_LOW("%s: Decoder num DPB buffers = %u Luma Size = %u",
 				 __func__, dpb, luma_size);
 	if (dpb > DDL_MAX_BUFFER_COUNT)
 		dpb = DDL_MAX_BUFFER_COUNT;
 	for (i = 0; i < dpb; i++) {
-		if (!(res_trk_check_for_sec_session()) &&
-			frame[i].vcd_frm.virtual) {
-			if (luma_size <= frame[i].vcd_frm.alloc_len) {
-				memset(frame[i].vcd_frm.virtual,
-					 0x10101010, luma_size);
-				memset(frame[i].vcd_frm.virtual + luma_size,
-					 0x80808080,
-					frame[i].vcd_frm.alloc_len - luma_size);
-				if (frame[i].vcd_frm.ion_flag == CACHED) {
-					msm_ion_do_cache_op(
-					ddl_context->video_ion_client,
-					frame[i].vcd_frm.buff_ion_handle,
-					(unsigned long *)frame[i].
-					vcd_frm.virtual,
-					(unsigned long)frame[i].
-					vcd_frm.alloc_len,
-					ION_IOC_CLEAN_INV_CACHES);
+		vcd_frm = &decoder->dp_buf.dec_pic_buffers[i].vcd_frm;
+		if (!res_trk_check_for_sec_session()) {
+			u8 *kernel_vaddr = NULL;
+			if (luma_size <= vcd_frm->alloc_len) {
+				kernel_vaddr = (u8 *)ion_map_kernel(
+						ddl_context->video_ion_client,
+						vcd_frm->buff_ion_handle);
+				if (IS_ERR_OR_NULL(kernel_vaddr)) {
+					DDL_MSG_ERROR("%s(): ION_MAP for "\
+					"DPB[%u] failed\n", __func__, i);
+				} else {
+					memset(kernel_vaddr, 0x10101010,
+						luma_size);
+					memset(kernel_vaddr + luma_size,
+						0x80808080,
+						vcd_frm->alloc_len - luma_size);
+					if (vcd_frm->ion_flag ==
+						ION_FLAG_CACHED) {
+						msm_ion_do_cache_op(
+						ddl_context->video_ion_client,
+						vcd_frm->buff_ion_handle,
+						(unsigned long *)kernel_vaddr,
+						(unsigned long)vcd_frm->
+						alloc_len,
+						ION_IOC_CLEAN_INV_CACHES);
+					}
+					ion_unmap_kernel(
+						ddl_context->video_ion_client,
+						vcd_frm->buff_ion_handle);
+					kernel_vaddr = NULL;
 				}
 			} else {
-				DDL_MSG_ERROR("luma size error");
+				DDL_MSG_ERROR("%s: err: luma_size (%u), "\
+					"alloc_len (%u)", __func__,
+					luma_size, vcd_frm->alloc_len);
 				return VCD_ERR_FAIL;
 			}
 		}
 
 		luma[i] = DDL_OFFSET(ddl_context->dram_base_a.
-			align_physical_addr, frame[i].vcd_frm.physical);
+			align_physical_addr, vcd_frm->physical);
 		chroma[i] = luma[i] + luma_size;
-		DDL_MSG_LOW("%s Decoder Luma address = %x Chroma address = %x"
+		DDL_MSG_LOW("%s: Decoder Luma address = %x Chroma address = %x",
 					__func__, luma[i], chroma[i]);
 	}
 	switch (decoder->codec.codec) {
@@ -402,9 +410,8 @@ void ddl_release_client_internal_buffers(struct ddl_client_context *ddl)
 		ddl_vidc_encode_dynamic_property(ddl, false);
 		encoder->dynamic_prop_change = 0;
 		ddl_free_enc_hw_buffers(ddl);
+		ddl_free_ltr_list(&encoder->ltr_control);
 	}
-	ddl_pmem_free(&ddl->shared_mem[0]);
-	ddl_pmem_free(&ddl->shared_mem[1]);
 }
 
 u32 ddl_codec_type_transact(struct ddl_client_context *ddl,
@@ -504,6 +511,8 @@ u32 ddl_get_yuv_buf_size(u32 width, u32 height, u32 format)
 
 	width_round_up  = width;
 	height_round_up = height;
+	align = SZ_4K;
+
 	if (format == DDL_YUV_BUF_TYPE_TILE) {
 		width_round_up  = DDL_ALIGN(width, DDL_TILE_ALIGN_WIDTH);
 		height_round_up = DDL_ALIGN(height, DDL_TILE_ALIGN_HEIGHT);
@@ -617,17 +626,23 @@ void ddl_calc_dec_hw_buffers_size(enum vcd_codec codec, u32 width,
 			(codec == VCD_CODEC_DIVX_6) ||
 			(codec == VCD_CODEC_XVID) ||
 			(codec == VCD_CODEC_H263)) {
+			u32 val = DDL_MAX(DDL_MAX_FRAME_WIDTH,
+				DDL_MAX_FRAME_HEIGHT);
+			sz_sub_anchor_mv = DDL_ALIGN(((val >> 4) * 128 * 2 * 8),
+				DDL_LINEAR_BUFFER_ALIGN_BYTES);
 			sz_nb_dcac = DDL_KILO_BYTE(16);
 			sz_upnb_mv = DDL_KILO_BYTE(68);
-			sz_sub_anchor_mv = DDL_KILO_BYTE(136);
 			sz_overlap_xform = DDL_KILO_BYTE(32);
 			if (codec != VCD_CODEC_H263)
 				sz_stx_parser = DDL_KILO_BYTE(68);
 		} else if ((codec == VCD_CODEC_VC1) ||
 			(codec == VCD_CODEC_VC1_RCV)) {
+			u32 val = DDL_MAX(DDL_MAX_FRAME_WIDTH,
+				DDL_MAX_FRAME_HEIGHT);
+			sz_sub_anchor_mv = DDL_ALIGN(((val >> 4) * 128 * 2 * 8),
+				DDL_LINEAR_BUFFER_ALIGN_BYTES);
 			sz_nb_dcac = DDL_KILO_BYTE(16);
 			sz_upnb_mv = DDL_KILO_BYTE(68);
-			sz_sub_anchor_mv = DDL_KILO_BYTE(136);
 			sz_overlap_xform = DDL_KILO_BYTE(32);
 			sz_bit_plane3 = DDL_KILO_BYTE(2);
 			sz_bit_plane2 = DDL_KILO_BYTE(2);
@@ -779,7 +794,7 @@ u32 ddl_allocate_dec_hw_buffers(struct ddl_client_context *ddl)
 		}
 	}
 	if (buf_size.sz_extnuserdata > 0) {
-		dec_bufs->extnuserdata.mem_type = DDL_FW_MEM;
+		dec_bufs->extnuserdata.mem_type = DDL_CMD_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->extnuserdata,
 				buf_size.sz_extnuserdata, DDL_KILO_BYTE(2));
 		if (!ptr)
@@ -811,13 +826,13 @@ u32 ddl_calc_enc_hw_buffers_size(enum vcd_codec codec, u32 width,
 		height, DDL_YUV_BUF_TYPE_TILE);
 	sz_dpb_c = ddl_get_yuv_buf_size(width, height>>1,
 		DDL_YUV_BUF_TYPE_TILE);
-	if (input_format ==
-		VCD_BUFFER_FORMAT_NV12_16M2KA) {
+	if ((input_format == VCD_BUFFER_FORMAT_NV12_16M2KA) ||
+		(input_format == VCD_BUFFER_FORMAT_NV21_16M2KA)) {
 		sz_cur_y = ddl_get_yuv_buf_size(width, height,
 			DDL_YUV_BUF_TYPE_LINEAR);
 		sz_cur_c = ddl_get_yuv_buf_size(width, height>>1,
 			DDL_YUV_BUF_TYPE_LINEAR);
-	} else if (VCD_BUFFER_FORMAT_TILE_4x2 == input_format) {
+	} else if (input_format == VCD_BUFFER_FORMAT_TILE_4x2) {
 		sz_cur_y = sz_dpb_y;
 		sz_cur_c = sz_dpb_c;
 	} else
@@ -998,7 +1013,7 @@ void ddl_decoder_chroma_dpb_change(struct ddl_client_context *ddl)
 	u32 luma_size, i, dpb;
 	luma_size = decoder->dpb_buf_size.size_y;
 	dpb = decoder->dp_buf.no_of_dec_pic_buf;
-	DDL_MSG_HIGH("%s Decoder num DPB buffers = %u Luma Size = %u"
+	DDL_MSG_HIGH("%s Decoder num DPB buffers = %u Luma Size = %u",
 			 __func__, dpb, luma_size);
 	if (dpb > DDL_MAX_BUFFER_COUNT)
 		dpb = DDL_MAX_BUFFER_COUNT;
@@ -1053,6 +1068,23 @@ u32 ddl_check_reconfig(struct ddl_client_context *ddl)
 			decoder->progressive_only)
 				need_reconfig = false;
 	}
+	DDL_MSG_HIGH("%s(): need_reconfig = %u, cont_mode = %u\n"\
+	"Actual: WxH = %ux%u, SxSH = %ux%u, sz = %u, min = %u, act = %u\n"\
+	"Client: WxH = %ux%u, SxSH = %ux%u, sz = %u, min = %u, act = %u\n",
+	__func__, need_reconfig, decoder->cont_mode,
+	decoder->frame_size.width, decoder->frame_size.height,
+	decoder->frame_size.stride, decoder->frame_size.scan_lines,
+	decoder->actual_output_buf_req.sz,
+	decoder->actual_output_buf_req.min_count,
+	decoder->actual_output_buf_req.actual_count,
+	decoder->client_frame_size.width,
+	decoder->client_frame_size.height,
+	decoder->client_frame_size.stride,
+	decoder->client_frame_size.scan_lines,
+	decoder->client_output_buf_req.sz,
+	decoder->client_output_buf_req.min_count,
+	decoder->client_output_buf_req.actual_count);
+
 	return need_reconfig;
 }
 
@@ -1141,3 +1173,295 @@ void ddl_set_vidc_timeout(struct ddl_client_context *ddl)
 	vidc_sm_set_video_core_timeout_value(
 		&ddl->shared_mem[ddl->command_channel], vidc_time_out);
 }
+
+void ddl_handle_ltr_in_framedone(struct ddl_client_context *ddl)
+{
+	struct ddl_ltr_encoding_type *ltr_control =
+		&ddl->codec_data.encoder.ltr_control;
+	DDL_MSG_LOW("%s:", __func__);
+	if (ltr_control->storing) {
+		ltr_control->ltr_list[ltr_control->storing_idx].ltr_id =
+			ltr_control->curr_ltr_id;
+		DDL_MSG_LOW("Encoder output stores LTR ID %d into entry %d",
+			ltr_control->curr_ltr_id, ltr_control->storing_idx);
+		ltr_control->meta_data_reqd = true;
+		ltr_control->storing = false;
+	}
+	ltr_control->out_frame_cnt_before_next_idr++;
+	if (ltr_control->out_frame_cnt_to_use_this_ltr) {
+		ltr_control->out_frame_cnt_to_use_this_ltr--;
+		if (!ltr_control->out_frame_cnt_to_use_this_ltr)
+			ddl_clear_ltr_list(ltr_control, true);
+	}
+}
+
+s32 ddl_encoder_ltr_control(struct ddl_client_context *ddl)
+{
+	s32 vcd_status = VCD_S_SUCCESS;
+	struct ddl_encoder_data *encoder = &ddl->codec_data.encoder;
+	struct ddl_ltr_encoding_type *ltr_ctrl = &encoder->ltr_control;
+	bool intra_period_reached = false;
+
+	DDL_MSG_LOW("%s:", __func__);
+	ddl_print_ltr_list(ltr_ctrl);
+
+	if (DDL_IS_LTR_IN_AUTO_MODE(encoder)) {
+		bool finite_i_period, infinite_i_period;
+		DDL_MSG_LOW("%s: before LTR encoding: output "\
+			"count before next IDR %d", __func__,
+			ltr_ctrl->out_frame_cnt_before_next_idr);
+		finite_i_period =
+			(DDL_MAX_P_FRAMES_IN_INTRA_INTERVAL !=
+			encoder->i_period.p_frames) &&
+			(!(ltr_ctrl->out_frame_cnt_before_next_idr %
+			(encoder->i_period.p_frames + 1)));
+		infinite_i_period =
+			((DDL_MAX_P_FRAMES_IN_INTRA_INTERVAL ==
+			encoder->i_period.p_frames) &&
+			(!ltr_ctrl->out_frame_cnt_before_next_idr));
+		if (finite_i_period || infinite_i_period) {
+			DDL_MSG_LOW("%s: Intra period reached. "\
+				"finite_i_period (%u), infinite_i_period (%u)",
+				__func__, (u32)finite_i_period,
+				(u32)infinite_i_period);
+			intra_period_reached = true;
+		}
+		if (intra_period_reached ||
+			ltr_ctrl->store_for_intraframe_insertion ||
+			encoder->intra_period_changed) {
+			ddl_clear_ltr_list(ltr_ctrl, false);
+			ltr_ctrl->out_frame_cnt_before_next_idr = 0;
+			ltr_ctrl->first_ltr_use_arvd = false;
+			ltr_ctrl->store_for_intraframe_insertion = false;
+		} else {
+			if (ltr_ctrl->first_ltr_use_arvd == false) {
+				ddl_use_ltr_from_list(ltr_ctrl, 0);
+				ltr_ctrl->out_frame_cnt_to_use_this_ltr =
+					0xFFFFFFFF;
+				ltr_ctrl->use_ltr_reqd = true;
+			}
+		}
+		if (!(ltr_ctrl->out_frame_cnt_before_next_idr %
+			ltr_ctrl->ltr_period)) {
+			s32 idx;
+			DDL_MSG_LOW("%s: reached LTR period "\
+				"out_frame_cnt_before_next_idr %d",
+				__func__, ltr_ctrl->\
+				out_frame_cnt_before_next_idr);
+			idx = ddl_find_oldest_ltr_not_in_use(
+				ltr_ctrl);
+			if (idx >= 0) {
+				ltr_ctrl->storing = true;
+				ltr_ctrl->storing_idx = idx;
+				if (idx == 0)
+					ltr_ctrl->store_ltr0 = true;
+				else if (idx == 1)
+					ltr_ctrl->store_ltr1 = true;
+			}
+		}
+	}
+	if (encoder->intra_frame_insertion) {
+		DDL_MSG_LOW("%s: I-frame insertion requested, "\
+			"delay LTR store for one frame", __func__);
+			ltr_ctrl->store_for_intraframe_insertion = true;
+	}
+	if (ltr_ctrl->pending_chg_ltr_useframes) {
+		ltr_ctrl->out_frame_cnt_to_use_this_ltr =
+			ltr_ctrl->ltr_use_frames;
+		ltr_ctrl->pending_chg_ltr_useframes = false;
+	}
+	if (ltr_ctrl->out_frame_cnt_to_use_this_ltr)
+		ltr_ctrl->use_ltr_reqd = true;
+	if (ltr_ctrl->use_ltr_reqd) {
+		s32 idx;
+		idx = ddl_find_ltr_in_use(ltr_ctrl);
+		if (idx == 0)
+			ltr_ctrl->use_ltr0 = true;
+		else if (idx == 1)
+			ltr_ctrl->use_ltr1 = true;
+		ltr_ctrl->using = true;
+		ltr_ctrl->use_ltr_reqd = false;
+	} else {
+		DDL_MSG_LOW("%s: use_ltr_reqd skipped", __func__);
+	}
+
+	return vcd_status;
+}
+
+s32 ddl_allocate_ltr_list(struct ddl_ltr_encoding_type *ltr_control)
+{
+	s32 vcd_status = VCD_S_SUCCESS;
+
+	DDL_MSG_LOW("%s: ltr_cout = %u", __func__, ltr_control->ltr_count);
+	if (!ltr_control->ltr_list) {
+		if (ltr_control->ltr_count) {
+			ltr_control->ltr_list = (struct ddl_ltrlist *)
+				kmalloc(sizeof(struct ddl_ltrlist)*
+				ltr_control->ltr_count, GFP_KERNEL);
+			if (!ltr_control->ltr_list) {
+				DDL_MSG_LOW("ddl_allocate_ltr_list failed");
+				vcd_status = VCD_ERR_ALLOC_FAIL;
+			}
+		} else {
+			DDL_MSG_LOW("%s: failed, zero LTR count", __func__);
+			vcd_status = VCD_ERR_FAIL;
+		}
+	} else {
+		DDL_MSG_LOW("WARN: ltr_list already allocated");
+	}
+
+	return vcd_status;
+}
+
+s32 ddl_free_ltr_list(struct ddl_ltr_encoding_type *ltr_control)
+{
+	s32 vcd_status = VCD_S_SUCCESS;
+
+	DDL_MSG_LOW("%s:", __func__);
+	kfree(ltr_control->ltr_list);
+	ltr_control->ltr_list = NULL;
+
+	return vcd_status;
+}
+
+s32 ddl_clear_ltr_list(struct ddl_ltr_encoding_type *ltr_control,
+	bool only_use_flag)
+{
+	s32 vcd_status = VCD_S_SUCCESS;
+	u32 i;
+
+	DDL_MSG_LOW("%s:", __func__);
+	for (i = 0; i < ltr_control->ltr_count; i++) {
+		ltr_control->ltr_list[i].ltr_in_use = false;
+		if (!only_use_flag)
+			ltr_control->ltr_list[i].ltr_id = 0;
+	}
+
+	return vcd_status;
+}
+
+s32 ddl_find_oldest_ltr_not_in_use(struct ddl_ltr_encoding_type *ltr_control)
+{
+	s32 found_idx = -1;
+	u32 i;
+
+	DDL_MSG_LOW("%s:", __func__);
+
+	if (ltr_control->ltr_list) {
+		if (ltr_control->ltr_count == 1)
+			found_idx = 0;
+		else {
+			for (i = 0; i < ltr_control->ltr_count; i++) {
+				if ((ltr_control->ltr_list[i].ltr_in_use ==
+					false) && (found_idx < 0)) {
+					found_idx = i;
+				}
+				if ((found_idx >= 0) &&
+					(ltr_control->ltr_list[i].\
+					ltr_in_use == false) &&
+					(ltr_control->ltr_list[i].ltr_id <
+					ltr_control->ltr_list[found_idx].\
+					ltr_id)) {
+					found_idx = i;
+				}
+			}
+		}
+	}
+
+	DDL_MSG_LOW("%s: found_idx = %d", __func__, found_idx);
+	return found_idx;
+}
+
+s32 ddl_find_ltr_in_use(struct ddl_ltr_encoding_type *ltr_control)
+{
+	s32 found_idx = -1;
+	u32 i;
+
+	DDL_MSG_LOW("%s:", __func__);
+
+	if (ltr_control->ltr_list) {
+		for (i = 0; i < ltr_control->ltr_count; i++) {
+			if (ltr_control->ltr_list[i].ltr_in_use == true)
+				found_idx = i;
+		}
+	}
+
+	DDL_MSG_LOW("%s: found_idx = %d", __func__, found_idx);
+	return found_idx;
+}
+
+s32 ddl_find_ltr_from_list(struct ddl_ltr_encoding_type *ltr_control,
+	u32 ltr_id)
+{
+	s32 found_idx = -1;
+	u32 i;
+
+	DDL_MSG_LOW("%s:", __func__);
+
+	if (ltr_control->ltr_list) {
+		for (i = 0; i < ltr_control->ltr_count; i++) {
+			if (ltr_control->ltr_list[i].ltr_id == ltr_id) {
+				found_idx = i;
+				break;
+			}
+		}
+	} else {
+		DDL_MSG_LOW("%s: ltr_list is NULL", __func__);
+	}
+
+	DDL_MSG_ERROR("%s: found_idx = %d", __func__, found_idx);
+	return found_idx;
+}
+
+s32 ddl_use_ltr_from_list(struct ddl_ltr_encoding_type *ltr_control,
+	u32 ltr_idx)
+{
+	s32 vcd_status = VCD_S_SUCCESS;
+	u32 i;
+
+	DDL_MSG_LOW("%s: ltr_idx = %u", __func__, ltr_idx);
+	if (ltr_idx > ltr_control->ltr_count) {
+		DDL_MSG_LOW("%s: fail, idx %d larger than "\
+			"the list array count %d", __func__,
+			ltr_idx, ltr_control->ltr_count);
+		vcd_status = VCD_ERR_FAIL;
+	} else {
+		for (i = 0; i < ltr_control->ltr_count; i++) {
+			if (i == ltr_idx)
+				ltr_control->ltr_list[ltr_idx].ltr_in_use =
+					true;
+			else
+				ltr_control->ltr_list[i].ltr_in_use = false;
+		}
+	}
+
+	return vcd_status;
+}
+
+void ddl_encoder_use_ltr_fail_callback(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	struct ddl_context *ddl_context = ddl->ddl_context;
+
+	DDL_MSG_LOW("%s: LTR use failed, callback "\
+		"requested with LTR ID %d", __func__,
+		encoder->ltr_control.failed_use_cmd.ltr_id);
+
+	ddl_context->ddl_callback(VCD_EVT_IND_INFO_LTRUSE_FAILED,
+		VCD_ERR_ILLEGAL_PARM,
+		&(encoder->ltr_control.failed_use_cmd),
+		sizeof(struct vcd_property_ltruse_type),
+		(u32 *)ddl,
+		ddl->client_data);
+}
+
+void ddl_print_ltr_list(struct ddl_ltr_encoding_type *ltr_control)
+{
+	u32 i;
+
+	for (i = 0; i < ltr_control->ltr_count; i++) {
+		DDL_MSG_LOW("%s: ltr_id: %d, ltr_in_use: %d",
+			__func__, ltr_control->ltr_list[i].ltr_id,
+			ltr_control->ltr_list[i].ltr_in_use);
+	}
+}
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
index 7de4731..2fc8f86 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -274,8 +274,8 @@ static u32 ddl_decoder_seq_done_callback(struct ddl_context *ddl_context,
 		}
 		vidc_sm_get_profile_info(&ddl->shared_mem
 			[ddl->command_channel], &disp_profile_info);
-		disp_profile_info.pic_profile = seq_hdr_info.profile;
-		disp_profile_info.pic_level = seq_hdr_info.level;
+		seq_hdr_info.profile = disp_profile_info.pic_profile;
+		seq_hdr_info.level = disp_profile_info.pic_level;
 		ddl_get_dec_profile_level(decoder, seq_hdr_info.profile,
 			seq_hdr_info.level);
 		switch (decoder->codec.codec) {
@@ -340,7 +340,7 @@ static u32 ddl_decoder_seq_done_callback(struct ddl_context *ddl_context,
 		parse_hdr_crop_data(ddl, &seq_hdr_info);
 		if (decoder->codec.codec == VCD_CODEC_H264 &&
 			seq_hdr_info.level > VIDC_1080P_H264_LEVEL4) {
-			DDL_MSG_HIGH("Warning: H264 LEVEL(%d) > LEVEL4",
+			DDL_MSG_ERROR("WARNING: H264MaxLevelExceeded : %d",
 				seq_hdr_info.level);
 		}
 		ddl_set_default_decoder_buffer_req(decoder, false);
@@ -364,7 +364,7 @@ static u32 ddl_decoder_seq_done_callback(struct ddl_context *ddl_context,
 				ddl->command_channel);
 		} else {
 			u32 seq_hdr_only_frame = false;
-			u32 need_reconfig = false;
+			u32 need_reconfig = false, eos_present = 0;
 			struct vcd_frame_data *input_vcd_frm =
 				&ddl->input_frame.vcd_frm;
 			need_reconfig = ddl_check_reconfig(ddl);
@@ -377,18 +377,28 @@ static u32 ddl_decoder_seq_done_callback(struct ddl_context *ddl_context,
 				input_vcd_frm->data_len <=
 				seq_hdr_info.dec_frm_size) {
 				seq_hdr_only_frame = true;
-				input_vcd_frm->offset +=
-					seq_hdr_info.dec_frm_size;
-				input_vcd_frm->data_len = 0;
-				input_vcd_frm->flags |=
-					VCD_FRAME_FLAG_CODECCONFIG;
-				ddl->input_frame.frm_trans_end =
-					!need_reconfig;
-				ddl_context->ddl_callback(
+				eos_present =
+				input_vcd_frm->flags & VCD_FRAME_FLAG_EOS;
+				if (!eos_present) {
+					input_vcd_frm->data_len = 0;
+					input_vcd_frm->offset +=
+						seq_hdr_info.dec_frm_size;
+					input_vcd_frm->flags |=
+						VCD_FRAME_FLAG_CODECCONFIG;
+					ddl->input_frame.frm_trans_end =
+						!need_reconfig;
+					ddl_context->ddl_callback(
 					VCD_EVT_RESP_INPUT_DONE,
 					VCD_S_SUCCESS, &ddl->input_frame,
 					sizeof(struct ddl_frame_data_tag),
 					(u32 *) ddl, ddl->client_data);
+				} else {
+					input_vcd_frm->flags &=
+					~(VCD_FRAME_FLAG_CODECCONFIG);
+					seq_hdr_only_frame = false;
+					pr_err("%s() Codec config buffer with eos\n",
+						__func__);
+				}
 			} else {
 				if (decoder->codec.codec ==
 					VCD_CODEC_VC1_RCV) {
@@ -398,6 +408,10 @@ static u32 ddl_decoder_seq_done_callback(struct ddl_context *ddl_context,
 						seq_hdr_info.dec_frm_size);
 				}
 			}
+			DDL_MSG_INFO("profile %u level %u progressive %u",
+					decoder->profile.profile,
+					decoder->level.level,
+					decoder->progressive_only);
 			if (need_reconfig) {
 				struct ddl_frame_data_tag *payload =
 					&ddl->input_frame;
@@ -870,7 +884,7 @@ static void ddl_edfu_callback(struct ddl_context *ddl_context)
 	struct ddl_client_context *ddl;
 	u32 channel_inst_id;
 
-	DDL_MSG_MED("ddl_edfu_callback");
+	DDL_MSG_ERROR("ddl_edfu_callback");
 	vidc_1080p_get_returned_channel_inst_id(&channel_inst_id);
 	vidc_1080p_clear_returned_channel_inst_id();
 	ddl = ddl_get_current_ddl_client_for_channel_id(ddl_context,
@@ -950,6 +964,39 @@ static u32 ddl_slice_done_callback(struct ddl_context *ddl_context)
 	return return_status;
 }
 
+
+static u32 ddl_handle_mgen2axi_error(struct ddl_context *ddl_context)
+{
+	u32 axi_error_info_a;
+	u32 axi_error_info_b;
+	struct vidc_1080P_axi_status axi_a_status;
+	struct vidc_1080P_axi_status axi_b_status;
+	struct vidc_1080P_axi_ctrl axi_ctrl;
+	u32 status = false;
+
+	vidc_1080p_get_mgenaxi_error_info(&axi_error_info_a,
+		&axi_error_info_b);
+	vidc_1080p_get_mgen2axi_status(&axi_a_status,
+		&axi_b_status);
+	if (axi_a_status.axi_error_interrupt ||
+		axi_a_status.axi_watchdog_error_interrupt ||
+		axi_b_status.axi_error_interrupt ||
+		axi_b_status.axi_watchdog_error_interrupt) {
+		vidc_1080p_get_mgen2maxi_ctrl(&axi_ctrl);
+		axi_ctrl.axi_interrupt_clr = 1;
+		vidc_1080p_set_mgen2maxi_ctrl(&axi_ctrl);
+		DDL_MSG_HIGH("%s: Wait for 20ms to clear mgen2axi intr",
+			__func__);
+		usleep(20*1000);
+		axi_ctrl.axi_interrupt_clr = 0;
+		vidc_1080p_set_mgen2maxi_ctrl(&axi_ctrl);
+		vidc_1080p_get_mgen2axi_status(&axi_a_status,
+			&axi_b_status);
+		status = true;
+	}
+	return status;
+}
+
 static u32 ddl_process_intr_status(struct ddl_context *ddl_context,
 	u32 intr_status)
 {
@@ -985,7 +1032,7 @@ static u32 ddl_process_intr_status(struct ddl_context *ddl_context,
 		ddl_encoder_eos_done(ddl_context);
 	break;
 	case VIDC_1080P_RISC2HOST_CMD_ERROR_RET:
-		DDL_MSG_ERROR("CMD_ERROR_INTR");
+		DDL_MSG_HIGH("CMD_ERROR_INTR");
 		return_status = ddl_handle_core_errors(ddl_context);
 	break;
 	case VIDC_1080P_RISC2HOST_CMD_INIT_BUFFERS_RET:
@@ -993,7 +1040,12 @@ static u32 ddl_process_intr_status(struct ddl_context *ddl_context,
 			ddl_dpb_buffers_set_done_callback(ddl_context);
 	break;
 	default:
-		DDL_MSG_LOW("UNKWN_INTR");
+		return_status = ddl_handle_mgen2axi_error(ddl_context);
+		if (return_status) {
+			return_status = false;
+			DDL_MSG_ERROR("Cleared Mgen2axi interrupt");
+		} else
+			DDL_MSG_ERROR("UNKWN_INTR");
 	break;
 	}
 	return return_status;
@@ -1175,20 +1227,29 @@ static u32 ddl_decoder_output_done_callback(
 		&(decoder->dec_disp_info);
 	struct ddl_frame_data_tag *output_frame = &(ddl->output_frame);
 	struct vcd_frame_data *output_vcd_frm = &(output_frame->vcd_frm);
+	enum vidc_1080p_decode_frame frame_type = 0;
 	u32 vcd_status, free_luma_dpb = 0, disp_pict = 0, is_interlaced;
+	u32 idr_frame = 0, coded_frame = 0;
+	u32 seq_end_code_present = 0;
 	get_dec_op_done_data(dec_disp_info, decoder->output_order,
 		&output_vcd_frm->physical, &is_interlaced);
 	decoder->progressive_only = !(is_interlaced);
 	output_vcd_frm->frame = VCD_FRAME_YUV;
+	vidc_sm_get_displayed_picture_frame(&ddl->shared_mem
+		[ddl->command_channel], &disp_pict);
+	coded_frame = (disp_pict & 0x03);
+	idr_frame = (disp_pict & 0x20) >> 5;
+	if (idr_frame)
+		frame_type = VIDC_1080P_DECODE_FRAMETYPE_IDR;
+	else
+		frame_type = (disp_pict & 0x1c) >> 2;
 	if (decoder->codec.codec == VCD_CODEC_MPEG4 ||
 		decoder->codec.codec == VCD_CODEC_VC1 ||
 		decoder->codec.codec == VCD_CODEC_VC1_RCV ||
 		(decoder->codec.codec >= VCD_CODEC_DIVX_3 &&
 		decoder->codec.codec <= VCD_CODEC_XVID)) {
-		vidc_sm_get_displayed_picture_frame(&ddl->shared_mem
-		[ddl->command_channel], &disp_pict);
 		if (decoder->output_order == VCD_DEC_ORDER_DISPLAY) {
-			if (!disp_pict) {
+			if (!coded_frame) {
 				output_vcd_frm->frame = VCD_FRAME_NOTCODED;
 				vidc_sm_get_available_luma_dpb_address(
 					&ddl->shared_mem[ddl->command_channel],
@@ -1213,6 +1274,7 @@ static u32 ddl_decoder_output_done_callback(
 		DDL_MSG_ERROR("CORRUPTED_OUTPUT_BUFFER_ADDRESS");
 		ddl_hw_fatal_cb(ddl);
 	} else {
+		ddl_get_decoded_frame(output_vcd_frm, frame_type);
 		vidc_sm_get_metadata_status(&ddl->shared_mem
 			[ddl->command_channel],
 			&decoder->meta_data_exists);
@@ -1239,6 +1301,19 @@ static u32 ddl_decoder_output_done_callback(
 				output_vcd_frm->flags |=
 					VCD_FRAME_FLAG_DATACORRUPT;
 		}
+		if (decoder->codec.codec != VCD_CODEC_H264 &&
+			decoder->codec.codec != VCD_CODEC_MPEG2 &&
+			decoder->codec.codec != VCD_CODEC_VC1)
+			output_vcd_frm->flags &= ~VCD_FRAME_FLAG_DATACORRUPT;
+		if (decoder->codec.codec == VCD_CODEC_MPEG2) {
+			vidc_sm_get_mp2common_status(&ddl->shared_mem
+				[ddl->command_channel],
+				&seq_end_code_present);
+			if (seq_end_code_present)
+				output_vcd_frm->flags |= VCD_FRAME_FLAG_EOSEQ;
+			else
+				output_vcd_frm->flags &= ~VCD_FRAME_FLAG_EOSEQ;
+		}
 		output_vcd_frm->ip_frm_tag = dec_disp_info->tag_top;
 		vidc_sm_get_picture_times(&ddl->shared_mem
 			[ddl->command_channel],
@@ -1290,6 +1365,7 @@ static u32 ddl_decoder_output_done_callback(
 			DDL_MSG_LOW("%s y_cb_cr_size = %u "
 				"actual_output_buf_req.sz = %u"
 				"min_output_buf_req.sz = %u\n",
+				__func__,
 				decoder->y_cb_cr_size,
 				decoder->actual_output_buf_req.sz,
 				decoder->min_output_buf_req.sz);
@@ -1347,6 +1423,10 @@ static u32 ddl_get_decoded_frame(struct vcd_frame_data  *frame,
 	case VIDC_1080P_DECODE_FRAMETYPE_OTHERS:
 		frame->frame = VCD_FRAME_YUV;
 	break;
+	case VIDC_1080P_DECODE_FRAMETYPE_IDR:
+		frame->flags |= VCD_FRAME_FLAG_SYNCFRAME;
+		frame->frame = VCD_FRAME_IDR;
+	break;
 	case VIDC_1080P_DECODE_FRAMETYPE_32BIT:
 	default:
 		DDL_MSG_ERROR("UNKNOWN-FRAMETYPE");
@@ -1733,11 +1813,20 @@ static void ddl_handle_enc_frame_done(struct ddl_client_context *ddl,
 	if (!IS_ERR_OR_NULL(output_frame->buff_ion_handle)) {
 		msm_ion_do_cache_op(ddl_context->video_ion_client,
 			output_frame->buff_ion_handle,
-			(unsigned long *) output_frame->virtual,
+			(unsigned long *)NULL,
 			(unsigned long) output_frame->alloc_len,
 			ION_IOC_INV_CACHES);
 	}
-	ddl_process_encoder_metadata(ddl);
+	if ((VIDC_1080P_ENCODE_FRAMETYPE_SKIPPED !=
+		encoder->enc_frame_info.enc_frame) &&
+		(VIDC_1080P_ENCODE_FRAMETYPE_NOT_CODED !=
+		encoder->enc_frame_info.enc_frame)) {
+		if (DDL_IS_LTR_ENABLED(encoder))
+			ddl_handle_ltr_in_framedone(ddl);
+		ddl_process_encoder_metadata(ddl);
+		encoder->ltr_control.meta_data_reqd = false;
+	}
+	encoder->ltr_control.using = false;
 	ddl_vidc_encode_dynamic_property(ddl, false);
 	ddl->input_frame.frm_trans_end = false;
 	input_buffer_address = ddl_context->dram_base_a.align_physical_addr +
@@ -1774,8 +1863,10 @@ static void ddl_handle_slice_done_slice_batch(struct ddl_client_context *ddl)
 	slice_output = (struct vidc_1080p_enc_slice_batch_out_param *)
 		(encoder->batch_frame.slice_batch_out.align_virtual_addr);
 	DDL_MSG_LOW(" after get no of slices = %d\n", num_slices_comp);
-	if (slice_output == NULL)
+	if (slice_output == NULL) {
 		DDL_MSG_ERROR(" slice_output is NULL\n");
+		return; /* Bail out */
+	}
 	encoder->slice_delivery_info.num_slices_enc += num_slices_comp;
 	if (vidc_msg_timing) {
 		ddl_calc_core_proc_time_cnt(__func__, ENC_SLICE_OP_TIME,
@@ -1799,11 +1890,11 @@ static void ddl_handle_slice_done_slice_batch(struct ddl_client_context *ddl)
 			stream_buffer_size);
 		output_frame = &(
 			encoder->batch_frame.output_frame[actual_idx].vcd_frm);
-		DDL_MSG_LOW("OutBfr: vcd_frm 0x%x frmbfr(virtual) 0x%x"
+		DDL_MSG_LOW("OutBfr: vcd_frm %p frmbfr(virtual) 0x%x"
 			"frmbfr(physical) 0x%x\n",
-			&output_frame,
-			output_frame.virtual_base_addr,
-			output_frame.physical_base_addr);
+			output_frame,
+			(u32)output_frame->virtual,
+			(u32)output_frame->physical);
 		vidc_1080p_get_encode_frame_info(&encoder->enc_frame_info);
 		vidc_sm_get_frame_tags(&ddl->shared_mem
 			[ddl->command_channel],
@@ -1884,14 +1975,14 @@ static u32 ddl_handle_enc_frame_done_slice_mode(
 		DDL_MSG_LOW("Slice Info: OutBfrIndex %d SliceSize %d",
 			actual_idx,
 			slice_output->slice_info[start_bfr_idx+index]. \
-			stream_buffer_size, 0);
+			stream_buffer_size);
 		output_frame =
 		&(encoder->batch_frame.output_frame[actual_idx].vcd_frm);
-		DDL_MSG_LOW("OutBfr: vcd_frm 0x%x frmbfr(virtual) 0x%x"
+		DDL_MSG_LOW("OutBfr: vcd_frm %p frmbfr(virtual) 0x%x"
 				"frmbfr(physical) 0x%x",
-				&output_frame,
-				output_frame.virtual_base_addr,
-				output_frame.physical_base_addr);
+				output_frame,
+				(u32)output_frame->virtual,
+				(u32)output_frame->physical);
 		vidc_1080p_get_encode_frame_info(
 			&encoder->enc_frame_info);
 		vidc_sm_get_frame_tags(&ddl->shared_mem
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.c
index f70c47c..c2e01a1 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -14,6 +14,7 @@
 #include "vcd_ddl.h"
 #include "vcd_ddl_shared_mem.h"
 #include "vcd_ddl_metadata.h"
+#include "vcd_res_tracker_api.h"
 
 static u32 *ddl_metadata_hdr_entry(struct ddl_client_context *ddl,
 	u32 meta_data)
@@ -75,6 +76,9 @@ static u32 *ddl_metadata_hdr_entry(struct ddl_client_context *ddl,
 		case VCD_METADATA_QCOMFILLER:
 			skip_words = 6;
 		break;
+		case VCD_METADATA_LTR_INFO:
+			skip_words = 9;
+		break;
 		}
 	}
 	buffer += skip_words;
@@ -146,19 +150,23 @@ void ddl_set_default_meta_data_hdr(struct ddl_client_context *ddl)
 		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
 		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
 		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_ENC_SLICE;
+		hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_LTR_INFO);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_LTR_INFO;
 	}
 }
 
 static u32 ddl_supported_metadata_flag(struct ddl_client_context *ddl)
 {
 	u32 flag = 0;
+	enum vcd_codec codec =
+		ddl->codec_data.decoder.codec.codec;
 
 	if (ddl->decoding) {
-		enum vcd_codec codec =
-			ddl->codec_data.decoder.codec.codec;
-
 		flag |= (VCD_METADATA_CONCEALMB | VCD_METADATA_PASSTHROUGH |
-				VCD_METADATA_QPARRAY);
+				VCD_METADATA_QPARRAY |
+				VCD_METADATA_SEPARATE_BUF);
 		if (codec == VCD_CODEC_H264)
 			flag |= (VCD_METADATA_SEI | VCD_METADATA_VUI);
 		else if (codec == VCD_CODEC_VC1 ||
@@ -167,8 +175,12 @@ static u32 ddl_supported_metadata_flag(struct ddl_client_context *ddl)
 		else if (codec == VCD_CODEC_MPEG2)
 			flag |= (VCD_METADATA_USER_DATA |
 				VCD_METADATA_EXT_DATA);
-	} else
-		flag |= VCD_METADATA_ENC_SLICE;
+	} else {
+		if (codec == VCD_CODEC_H264)
+			flag |= VCD_METADATA_ENC_SLICE | VCD_METADATA_LTR_INFO;
+		else
+			flag |= VCD_METADATA_ENC_SLICE;
+	}
 	return flag;
 }
 
@@ -187,6 +199,8 @@ void ddl_set_default_decoder_metadata_buffer_size(struct ddl_decoder_data
 	u32 flag = decoder->meta_data_enable_flag;
 	u32 suffix = 0, size = 0;
 	if (!flag) {
+		output_buf_req->meta_buffer_size =
+			DDL_SECURE_METADATA_DEFAULT_SIZE;
 		decoder->suffix = 0;
 		return;
 	}
@@ -249,6 +263,9 @@ void ddl_set_default_decoder_metadata_buffer_size(struct ddl_decoder_data
 	DDL_METADATA_ALIGNSIZE(suffix);
 	decoder->suffix = suffix;
 	output_buf_req->sz += suffix;
+	output_buf_req->meta_buffer_size = suffix;
+	output_buf_req->meta_buffer_size =
+		(output_buf_req->meta_buffer_size + 8191) & (~8191);
 	decoder->meta_data_offset = 0;
 	DDL_MSG_LOW("metadata output buf size : %d", suffix);
 }
@@ -272,6 +289,12 @@ void ddl_set_default_encoder_metadata_buffer_size(struct ddl_encoder_data
 		DDL_METADATA_ALIGNSIZE(size);
 		suffix += size;
 	}
+	if (flag & VCD_METADATA_LTR_INFO) {
+		size = DDL_METADATA_HDR_SIZE;
+		size += DDL_METADATA_LTR_INFO_PAYLOAD_SIZE;
+		DDL_METADATA_ALIGNSIZE(size);
+		suffix += size;
+	}
 	size = DDL_METADATA_EXTRADATANONE_SIZE;
 	DDL_METADATA_ALIGNSIZE(size);
 	suffix += (size);
@@ -464,13 +487,14 @@ u32 ddl_vidc_encode_set_metadata_output_buf(struct ddl_client_context *ddl)
 void ddl_vidc_decode_set_metadata_output(struct ddl_decoder_data *decoder)
 {
 	struct ddl_context *ddl_context;
-	u32 loopc, yuv_size;
+	u32 loopc, yuv_size, dpb;
 	u32 *buffer;
-
+	struct ddl_dec_buffers *dec_buffers = &decoder->hw_bufs;
 	if (!decoder->meta_data_enable_flag) {
 		decoder->meta_data_offset = 0;
 		return;
 	}
+	dpb = decoder->dp_buf.no_of_dec_pic_buf;
 	ddl_context = ddl_get_context();
 	yuv_size = ddl_get_yuv_buffer_size(&decoder->client_frame_size,
 		&decoder->buf_format, !decoder->progressive_only,
@@ -478,15 +502,22 @@ void ddl_vidc_decode_set_metadata_output(struct ddl_decoder_data *decoder)
 	decoder->meta_data_offset = DDL_ALIGN_SIZE(yuv_size,
 		DDL_LINEAR_BUF_ALIGN_GUARD_BYTES, DDL_LINEAR_BUF_ALIGN_MASK);
 	buffer = (u32 *) decoder->meta_data_input.align_virtual_addr;
-	*buffer++ = decoder->suffix;
 	DDL_MSG_LOW("Metadata offset & size : %d/%d",
 		decoder->meta_data_offset, decoder->suffix);
-	for (loopc = 0; loopc < decoder->dp_buf.no_of_dec_pic_buf;
-		++loopc) {
-		*buffer++ = (u32)(decoder->meta_data_offset + (u8 *)
+	if (!(decoder->meta_data_enable_flag & VCD_METADATA_SEPARATE_BUF)) {
+		*buffer++ = decoder->suffix;
+		for (loopc = 0; loopc < dpb; ++loopc) {
+			*buffer++ = (u32)(decoder->meta_data_offset + (u8 *)
 			DDL_OFFSET(ddl_context->dram_base_a.
 			align_physical_addr, decoder->dp_buf.
 			dec_pic_buffers[loopc].vcd_frm.physical));
+		}
+	} else if (res_trk_get_enable_sec_metadata()) {
+		*buffer++ = decoder->actual_output_buf_req.meta_buffer_size;
+		for (loopc = 0; loopc < dpb; ++loopc) {
+			*buffer++ = DDL_ADDR_OFFSET(ddl_context->dram_base_a,
+					dec_buffers->meta_hdr[loopc]);
+		}
 	}
 }
 
@@ -495,29 +526,34 @@ void ddl_process_encoder_metadata(struct ddl_client_context *ddl)
 	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
 	struct vcd_frame_data *out_frame =
 		&(ddl->output_frame.vcd_frm);
-	u32 *qfiller_hdr, *qfiller, start_addr;
-	u32 qfiller_size;
+	u32 metadata_available = false;
+	out_frame->metadata_offset = 0;
+	out_frame->metadata_len = 0;
+	out_frame->curr_ltr_id = 0;
+	out_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
 	if (!encoder->meta_data_enable_flag) {
-		out_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
+		DDL_MSG_HIGH("meta_data is not enabled");
 		return;
 	}
-	if (!encoder->enc_frame_info.meta_data_exists) {
-		out_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
-		return;
+	if (encoder->enc_frame_info.meta_data_exists) {
+		DDL_MSG_LOW("meta_data exists");
+		metadata_available = true;
+	}
+	if ((encoder->meta_data_enable_flag & VCD_METADATA_LTR_INFO) &&
+		(encoder->ltr_control.meta_data_reqd == true)) {
+		out_frame->curr_ltr_id = encoder->ltr_control.curr_ltr_id;
+		DDL_MSG_LOW("%s: increment curr_ltr_id = %d",
+			__func__, (u32)encoder->ltr_control.curr_ltr_id);
+		encoder->ltr_control.curr_ltr_id++;
+		metadata_available = true;
+	}
+	if (metadata_available) {
+		DDL_MSG_LOW("%s: data_len/metadata_offset : %d/%d", __func__,
+			out_frame->data_len, encoder->meta_data_offset);
+		out_frame->metadata_offset = encoder->meta_data_offset;
+		out_frame->metadata_len = encoder->suffix;
+		out_frame->flags |= VCD_FRAME_FLAG_EXTRADATA;
 	}
-	out_frame->flags |= VCD_FRAME_FLAG_EXTRADATA;
-	DDL_MSG_LOW("processing metadata for encoder");
-	start_addr = (u32) ((u8 *)out_frame->virtual + out_frame->offset);
-	qfiller = (u32 *)((out_frame->data_len +
-				start_addr + 3) & ~3);
-	qfiller_size = (u32)((encoder->meta_data_offset +
-		(u8 *) out_frame->virtual) - (u8 *) qfiller);
-	qfiller_hdr = ddl_metadata_hdr_entry(ddl, VCD_METADATA_QCOMFILLER);
-	*qfiller++ = qfiller_size;
-	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_VERSION_INDEX];
-	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_PORT_INDEX];
-	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_TYPE_INDEX];
-	*qfiller = (u32)(qfiller_size - DDL_METADATA_HDR_SIZE);
 }
 
 void ddl_process_decoder_metadata(struct ddl_client_context *ddl)
@@ -525,9 +561,8 @@ void ddl_process_decoder_metadata(struct ddl_client_context *ddl)
 	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
 	struct vcd_frame_data *output_frame =
 		&(ddl->output_frame.vcd_frm);
-	u32 *qfiller_hdr, *qfiller;
-	u32 qfiller_size;
-
+	output_frame->metadata_offset = 0;
+	output_frame->metadata_len = 0;
 	if (!decoder->meta_data_enable_flag) {
 		output_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
 		return;
@@ -536,30 +571,12 @@ void ddl_process_decoder_metadata(struct ddl_client_context *ddl)
 		output_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
 		return;
 	}
-	if (!decoder->mp2_datadump_status && decoder->codec.codec ==
-		VCD_CODEC_MPEG2 && !decoder->extn_user_data_enable) {
-		output_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
-		return;
-	}
-	DDL_MSG_LOW("processing metadata for decoder");
-	DDL_MSG_LOW("data_len/metadata_offset : %d/%d",
+
+	DDL_MSG_LOW("%s: data_len/metadata_offset : %d/%d", __func__,
 		output_frame->data_len, decoder->meta_data_offset);
+	output_frame->metadata_offset = decoder->meta_data_offset;
+	output_frame->metadata_len = decoder->suffix;
 	output_frame->flags |= VCD_FRAME_FLAG_EXTRADATA;
-	if (output_frame->data_len != decoder->meta_data_offset) {
-		qfiller = (u32 *)((u32)((output_frame->data_len +
-			output_frame->offset  +
-				(u8 *) output_frame->virtual) + 3) & ~3);
-		qfiller_size = (u32)((decoder->meta_data_offset +
-				(u8 *) output_frame->virtual) -
-				(u8 *) qfiller);
-		qfiller_hdr = ddl_metadata_hdr_entry(ddl,
-				VCD_METADATA_QCOMFILLER);
-		*qfiller++ = qfiller_size;
-		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_VERSION_INDEX];
-		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_PORT_INDEX];
-		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_TYPE_INDEX];
-		*qfiller = (u32)(qfiller_size - DDL_METADATA_HDR_SIZE);
-	}
 }
 
 void ddl_set_mp2_dump_default(struct ddl_decoder_data *decoder, u32 flag)
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.h
index e03a9b7..f133df6 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_metadata.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -19,6 +19,7 @@
 #define DDL_METADATA_EXTRAPAD_SIZE      256
 #define DDL_METADATA_HDR_SIZE            20
 #define DDL_METADATA_EXTRADATANONE_SIZE  24
+#define DDL_SECURE_METADATA_DEFAULT_SIZE  8192
 #define DDL_METADATA_ALIGNSIZE(x) ((x) = (((x) + 0x7) & ~0x7))
 #define DDL_METADATA_MANDATORY \
 	(VCD_METADATA_DATANONE | VCD_METADATA_QCOMFILLER)
@@ -26,6 +27,7 @@
 #define DDL_METADATA_SEI_PAYLOAD_SIZE          100
 #define DDL_METADATA_SEI_MAX                     5
 #define DDL_METADATA_VUI_PAYLOAD_SIZE          256
+#define DDL_METADATA_LTR_INFO_PAYLOAD_SIZE     (4)
 #define DDL_METADATA_PASSTHROUGH_PAYLOAD_SIZE   68
 #define DDL_METADATA_EXT_PAYLOAD_SIZE         (640)
 #define DDL_METADATA_USER_PAYLOAD_SIZE        (2048)
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
index adee803..93ca61e 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -163,6 +163,27 @@ u32 ddl_encoder_ready_to_start(struct ddl_client_context *ddl)
 		DDL_MSG_ERROR("H264BaseLineCABAC!!");
 		return false;
 	}
+	if (DDL_IS_LTR_ENABLED(encoder)) {
+		if ((encoder->codec.codec != VCD_CODEC_H264) ||
+			(encoder->i_period.b_frames)) {
+			DDL_MSG_ERROR("%s: Only support LTR encoding "\
+				"for H264 without B frame. Current "\
+				"codec %d, B-frame %d", __func__,
+				encoder->codec.codec,
+				encoder->i_period.b_frames);
+			return false;
+		}
+		if (encoder->ltr_control.ltrmode.ltr_mode ==
+			VCD_LTR_MODE_MANUAL) {
+			DDL_MSG_ERROR("%s: Manual LTR mode not supported!",
+				__func__);
+			return false;
+		}
+		DDL_MSG_HIGH("%s: LTR: mode = %u, count = %u, period = %u",
+			__func__, (u32)encoder->ltr_control.ltrmode.ltr_mode,
+		encoder->ltr_control.ltr_count,
+		encoder->ltr_control.ltr_period);
+	}
 	return true;
 }
 
@@ -219,6 +240,13 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 			(ddl_valid_buffer_requirement(
 			&decoder->min_input_buf_req, buffer_req))) {
 			decoder->client_input_buf_req = *buffer_req;
+			DDL_MSG_HIGH("set DDL_IN_BUF_REQ: min = %u, "\
+				"max = %u, act = %u, size = %u, align = %u, "\
+				"buf_pool_id = %u, meta_buf_size = %u",
+				buffer_req->min_count, buffer_req->max_count,
+				buffer_req->actual_count, buffer_req->sz,
+				buffer_req->align, buffer_req->buf_pool_id,
+				buffer_req->meta_buffer_size);
 			vcd_status = VCD_S_SUCCESS;
 		}
 	}
@@ -236,9 +264,15 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 			DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)) &&
 			(ddl_valid_buffer_requirement(
 			&decoder->min_output_buf_req, buffer_req))) {
-				decoder->client_output_buf_req =
-					*buffer_req;
-				vcd_status = VCD_S_SUCCESS;
+			decoder->client_output_buf_req = *buffer_req;
+			DDL_MSG_HIGH("set DDL_OUT_BUF_REQ: min = %u, "\
+				"max = %u, act = %u, size = %u, align = %u, "\
+				"buf_pool_id = %u, meta_buf_size = %u",
+				buffer_req->min_count, buffer_req->max_count,
+				buffer_req->actual_count, buffer_req->sz,
+				buffer_req->align, buffer_req->buf_pool_id,
+				buffer_req->meta_buffer_size);
+			vcd_status = VCD_S_SUCCESS;
 		}
 	}
 	break;
@@ -288,7 +322,7 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 				ddl_set_default_decoder_buffer_req(decoder,
 					true);
 			}
-			DDL_MSG_LOW("set  VCD_I_FRAME_SIZE width = %d"
+			DDL_MSG_HIGH("set VCD_I_FRAME_SIZE width = %d"
 				" height = %d\n",
 				frame_size->width, frame_size->height);
 			vcd_status = VCD_S_SUCCESS;
@@ -319,6 +353,61 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 		}
 	}
 	break;
+	case VCD_I_SET_EXT_METABUFFER:
+	{
+		int index, buffer_size;
+		u8 *phys_addr;
+		u8 *virt_addr;
+		struct vcd_property_meta_buffer *meta_buffer =
+			(struct vcd_property_meta_buffer *) property_value;
+		DDL_MSG_LOW("Entered VCD_I_SET_EXT_METABUFFER Virt: %p,"\
+					"Phys %p, fd: %d size: %d count: %d",
+					meta_buffer->kernel_virtual_addr,
+					meta_buffer->physical_addr,
+					meta_buffer->pmem_fd,
+					meta_buffer->size, meta_buffer->count);
+		if ((property_hdr->sz == sizeof(struct
+			vcd_property_meta_buffer)) &&
+			(DDLCLIENT_STATE_IS(ddl,
+			DDL_CLIENT_WAIT_FOR_INITCODEC) ||
+			DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_DPB) ||
+			DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN))) {
+			phys_addr = meta_buffer->dev_addr;
+			virt_addr = meta_buffer->kernel_virtual_addr;
+			buffer_size = meta_buffer->size/meta_buffer->count;
+
+			for (index = 0; index < meta_buffer->count; index++) {
+				ddl->codec_data.decoder.hw_bufs.
+					meta_hdr[index].align_physical_addr
+					= phys_addr;
+				ddl->codec_data.decoder.hw_bufs.
+					meta_hdr[index].align_virtual_addr
+					= virt_addr;
+				ddl->codec_data.decoder.hw_bufs.
+					meta_hdr[index].buffer_size
+					= buffer_size;
+				ddl->codec_data.decoder.hw_bufs.
+					meta_hdr[index].physical_base_addr
+					= phys_addr;
+				ddl->codec_data.decoder.hw_bufs.
+					meta_hdr[index].virtual_base_addr
+					= virt_addr;
+
+				DDL_MSG_LOW("Meta Buffer: "\
+							"Assigned %d buffer for "
+							"virt: %p, phys %p for "
+							"meta_buffers "
+							"of size: %d\n",
+							index, virt_addr,
+							phys_addr, buffer_size);
+
+				phys_addr += buffer_size;
+				virt_addr += buffer_size;
+			}
+			vcd_status = VCD_S_SUCCESS;
+		}
+	}
+	break;
 	case VCD_I_H264_MV_BUFFER:
 	{
 		int index, buffer_size;
@@ -379,6 +468,13 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 			vcd_status = VCD_S_SUCCESS;
 		}
 		break;
+	case VCD_I_FREE_EXT_METABUFFER:
+		{
+			memset(&decoder->hw_bufs.meta_hdr, 0, sizeof(struct
+					ddl_buf_addr) * DDL_MAX_BUFFER_COUNT);
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
 	case VCD_I_OUTPUT_ORDER:
 		{
 			if (sizeof(u32) == property_hdr->sz &&
@@ -440,6 +536,7 @@ static u32 ddl_set_dec_property(struct ddl_client_context *ddl,
 	}
 	break;
 	case VCD_REQ_PERF_LEVEL:
+		DDL_MSG_LOW("%s: VCD_REQ_PERF_LEVEL (do nithing)", __func__);
 		vcd_status = VCD_S_SUCCESS;
 		break;
 	default:
@@ -617,8 +714,9 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 		struct vcd_property_multi_slice *multi_slice =
 			(struct vcd_property_multi_slice *)
 				property_value;
-		DDL_MSG_HIGH("VCD_I_MULTI_SLICE eMSliceSel %d  nMSliceSize %d"
-				"Tot#of MB %d encoder->frame_size.width = %d"
+		DDL_MSG_HIGH("VCD_I_MULTI_SLICE eMSliceSel %d "\
+				"nMSliceSize %d Tot#of MB %d "\
+				"encoder->frame_size.width = %d "\
 				"encoder->frame_size.height = %d",
 				(int)multi_slice->m_slice_sel,
 				multi_slice->m_slice_size,
@@ -836,8 +934,10 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 			property_hdr->sz &&
 			((buffer_format->buffer_format ==
 			VCD_BUFFER_FORMAT_NV12_16M2KA) ||
-			(VCD_BUFFER_FORMAT_TILE_4x2 ==
-			buffer_format->buffer_format))) {
+			(buffer_format->buffer_format ==
+			VCD_BUFFER_FORMAT_TILE_4x2) ||
+			(buffer_format->buffer_format ==
+			VCD_BUFFER_FORMAT_NV21_16M2KA))) {
 			if (buffer_format->buffer_format !=
 				encoder->buf_format.buffer_format) {
 				encoder->buf_format = *buffer_format;
@@ -915,8 +1015,8 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 					align_virtual_addr =
 					recon_buffers->kernel_virtual_addr +
 					recon_buffers->ysize;
-				DDL_MSG_LOW("Y::KVirt: %p,KPhys: %p"
-							"UV::KVirt: %p,KPhys: %p\n",
+				DDL_MSG_LOW("Y::KVirt: %p, KPhys: %p "\
+					"UV::KVirt: %p, KPhys: %p\n",
 				encoder->hw_bufs.dpb_y[index_hw_bufs].
 				align_virtual_addr,
 				encoder->hw_bufs.dpb_y[index_hw_bufs].
@@ -926,7 +1026,7 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 				encoder->hw_bufs.dpb_c[index_hw_bufs].
 				align_physical_addr);
 				vcd_status = VCD_S_SUCCESS;
-				}
+			}
 		}
 	}
 	break;
@@ -981,6 +1081,7 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 		u32 num_mb, num_slices;
 		struct vcd_property_hdr slice_property_hdr;
 		struct vcd_property_meta_data_enable slice_meta_data;
+		slice_meta_data.meta_data_enable_flag = 0;
 		DDL_MSG_HIGH("Set property VCD_I_SLICE_DELIVERY_MODE\n");
 		if (sizeof(u32) == property_hdr->sz &&
 			encoder->codec.codec == VCD_CODEC_H264 &&
@@ -1044,18 +1145,92 @@ static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
 		}
 		break;
 	}
+	case VCD_I_LTR_MODE:
+		if (sizeof(struct vcd_property_ltrmode_type) ==
+			property_hdr->sz && encoder->codec.codec ==
+			VCD_CODEC_H264) {
+			struct vcd_property_ltrmode_type *ltrmode =
+				(struct vcd_property_ltrmode_type *)
+				property_value;
+			encoder->ltr_control.ltrmode.ltr_mode =
+				ltrmode->ltr_mode;
+			DDL_MSG_HIGH("%s: set LTR mode = %u", __func__,
+				(u32)encoder->ltr_control.ltrmode.ltr_mode);
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
+	case VCD_I_LTR_COUNT:
+		if (sizeof(struct vcd_property_ltrcount_type) ==
+			property_hdr->sz && encoder->codec.codec ==
+			VCD_CODEC_H264) {
+			struct vcd_property_ltrcount_type *ltrcount =
+				(struct vcd_property_ltrcount_type *)
+				property_value;
+			if (ltrcount->ltr_count > DDL_MAX_NUM_LTR_FRAMES) {
+				DDL_MSG_ERROR("%s: set LTR count failed. "\
+					"LTR count %u beyond maximum of %u",
+					__func__, ltrcount->ltr_count,
+					(u32)DDL_MAX_NUM_LTR_FRAMES);
+			} else {
+				encoder->ltr_control.ltr_count =
+					ltrcount->ltr_count;
+				DDL_MSG_HIGH("%s: set LTR count = %u", __func__,
+					encoder->ltr_control.ltr_count);
+				vcd_status = VCD_S_SUCCESS;
+			}
+		}
+	break;
 	case VCD_REQ_PERF_LEVEL:
+		DDL_MSG_LOW("%s: VCD_REQ_PERF_LEVEL (do nithing)", __func__);
 		vcd_status = VCD_S_SUCCESS;
 		break;
-    case VCD_I_SET_TURBO_CLK:
-    {
-        vcd_status = VCD_S_SUCCESS;
-        break;
-    }
+	case VCD_I_ENABLE_DELIMITER_FLAG:
+	{
+		struct vcd_property_avc_delimiter_enable *delimiter_enable =
+			(struct vcd_property_avc_delimiter_enable *)
+				property_value;
+		if (sizeof(struct vcd_property_avc_delimiter_enable) ==
+			property_hdr->sz &&
+			encoder->codec.codec == VCD_CODEC_H264) {
+			encoder->avc_delimiter_enable =
+			delimiter_enable->avc_delimiter_enable_flag;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	}
+	case VCD_I_ENABLE_VUI_TIMING_INFO:
+	{
+		struct vcd_property_vui_timing_info_enable *vui_timing_enable =
+			(struct vcd_property_vui_timing_info_enable *)
+				property_value;
+		if (sizeof(struct vcd_property_vui_timing_info_enable) ==
+			property_hdr->sz &&
+			encoder->codec.codec == VCD_CODEC_H264) {
+			encoder->vui_timinginfo_enable =
+			vui_timing_enable->vui_timing_info;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	}
+	case VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG:
+	{
+		struct vcd_property_bitstream_restrict_enable *restrict_enable =
+			(struct vcd_property_bitstream_restrict_enable *)
+				property_value;
+		if (sizeof(struct vcd_property_bitstream_restrict_enable) ==
+			property_hdr->sz &&
+			encoder->codec.codec == VCD_CODEC_H264) {
+			encoder->bitstream_restrict_enable =
+			restrict_enable->bitstream_restrict_enable_flag;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	}
 	default:
-		DDL_MSG_ERROR("INVALID ID %d\n", (int)property_hdr->prop_id);
+		DDL_MSG_ERROR("%s: INVALID ID 0x%x\n", __func__,
+			(int)property_hdr->prop_id);
 		vcd_status = VCD_ERR_ILLEGAL_OP;
-	break;
+		break;
 	}
 	return vcd_status;
 }
@@ -1084,6 +1259,9 @@ static u32 ddl_get_dec_property(struct ddl_client_context *ddl,
 			*(struct vcd_property_frame_size *)
 				property_value =
 					decoder->client_frame_size;
+			DDL_MSG_HIGH("get VCD_I_FRAME_SIZE WxH = %ux%u, "\
+				"SxSH = %ux%u", fz_size->width, fz_size->height,
+				fz_size->stride, fz_size->scan_lines);
 			vcd_status = VCD_S_SUCCESS;
 		}
 	break;
@@ -1116,6 +1294,17 @@ static u32 ddl_get_dec_property(struct ddl_client_context *ddl,
 			*(struct vcd_buffer_requirement *)
 				property_value =
 					decoder->client_input_buf_req;
+			DDL_MSG_HIGH("get DDL_IN_BUF_REQ: min = %u, "\
+				"max = %u, act = %u, size = %u, "\
+				"align = %u, buf_pool_id = %u, "\
+				"meta_buf_size = %u",
+				decoder->client_input_buf_req.min_count,
+				decoder->client_input_buf_req.max_count,
+				decoder->client_input_buf_req.actual_count,
+				decoder->client_input_buf_req.sz,
+				decoder->client_input_buf_req.align,
+				decoder->client_input_buf_req.buf_pool_id,
+				decoder->client_input_buf_req.meta_buffer_size);
 			vcd_status = VCD_S_SUCCESS;
 		}
 	break;
@@ -1124,7 +1313,17 @@ static u32 ddl_get_dec_property(struct ddl_client_context *ddl,
 			property_hdr->sz) {
 				*(struct vcd_buffer_requirement *)
 			property_value = decoder->client_output_buf_req;
-				vcd_status = VCD_S_SUCCESS;
+			DDL_MSG_HIGH("get DDL_OUT_BUF_REQ: min = %u, "\
+			"max = %u, act = %u, size = %u, align = %u, "\
+			"buf_pool_id = %u, meta_buf_size = %u",
+			decoder->client_output_buf_req.min_count,
+			decoder->client_output_buf_req.max_count,
+			decoder->client_output_buf_req.actual_count,
+			decoder->client_output_buf_req.sz,
+			decoder->client_output_buf_req.align,
+			decoder->client_output_buf_req.buf_pool_id,
+			decoder->client_output_buf_req.meta_buffer_size);
+			vcd_status = VCD_S_SUCCESS;
 		}
 	break;
 	case VCD_I_CODEC:
@@ -1209,7 +1408,7 @@ static u32 ddl_get_dec_property(struct ddl_client_context *ddl,
 		break;
 	case VCD_I_METADATA_ENABLE:
 	case VCD_I_METADATA_HEADER:
-		DDL_MSG_ERROR("Meta Data Interface is Requested");
+		DDL_MSG_HIGH("Meta Data Interface is Requested");
 		vcd_status = ddl_get_metadata_params(ddl, property_hdr,
 			property_value);
 		vcd_status = VCD_S_SUCCESS;
@@ -1226,6 +1425,13 @@ static u32 ddl_get_dec_property(struct ddl_client_context *ddl,
 			vcd_status = VCD_S_SUCCESS;
 		}
 	break;
+	case VCD_I_ENABLE_SEC_METADATA:
+		if (sizeof(u32) == property_hdr->sz) {
+			*(u32 *)property_value =
+				res_trk_get_enable_sec_metadata();
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
 	case VCD_I_DISABLE_DMX:
 		if (sizeof(u32) == property_hdr->sz) {
 			*(u32 *)property_value = decoder->dmx_disable;
@@ -1535,7 +1741,94 @@ static u32 ddl_get_enc_property(struct ddl_client_context *ddl,
 			vcd_status = VCD_S_SUCCESS;
 		}
 		break;
+	case VCD_I_ENABLE_DELIMITER_FLAG:
+		if (sizeof(struct vcd_property_avc_delimiter_enable) ==
+			property_hdr->sz) {
+			((struct vcd_property_avc_delimiter_enable *)
+				property_value)->avc_delimiter_enable_flag =
+					encoder->avc_delimiter_enable;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	case VCD_I_ENABLE_VUI_TIMING_INFO:
+		if (sizeof(struct vcd_property_vui_timing_info_enable) ==
+			property_hdr->sz) {
+			((struct vcd_property_vui_timing_info_enable *)
+				property_value)->vui_timing_info =
+					encoder->vui_timinginfo_enable;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		break;
+	case VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG:
+		if (sizeof(struct vcd_property_bitstream_restrict_enable) ==
+			property_hdr->sz) {
+			((struct vcd_property_bitstream_restrict_enable *)
+				property_value)->bitstream_restrict_enable_flag
+					= encoder->bitstream_restrict_enable;
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
+	case VCD_I_CAPABILITY_LTR_COUNT:
+		if (sizeof(struct vcd_property_range_type) ==
+			property_hdr->sz) {
+			struct vcd_property_range_type capability_ltr_range;
+			capability_ltr_range.max = DDL_MAX_NUM_LTR_FRAMES;
+			capability_ltr_range.min = 1;
+			capability_ltr_range.step_size = 1;
+			*(struct vcd_property_range_type *)property_value =
+				capability_ltr_range;
+			DDL_MSG_HIGH("%s: capability_ltr_count = %u",
+				__func__, ((struct vcd_property_range_type *)
+				property_value)->max);
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
+	case VCD_I_LTR_MODE:
+		if (sizeof(struct vcd_property_ltrmode_type) ==
+			property_hdr->sz) {
+			((struct vcd_property_ltrmode_type *)
+				property_value)->ltr_mode =
+				encoder->ltr_control.ltrmode.ltr_mode;
+			DDL_MSG_HIGH("%s: ltr_mode = %u", __func__,
+				(u32)(((struct vcd_property_ltrmode_type *)
+				property_value)->ltr_mode));
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
+	case VCD_I_LTR_COUNT:
+		if (sizeof(struct vcd_property_ltrcount_type) ==
+			property_hdr->sz) {
+			struct vcd_property_ltrcount_type ltr_count;
+			ltr_count.ltr_count =
+				encoder->ltr_control.ltr_count;
+			*(struct vcd_property_ltrcount_type *)property_value =
+				ltr_count;
+			DDL_MSG_HIGH("%s: ltr_count = %u", __func__,
+				((struct vcd_property_ltrcount_type *)
+				property_value)->ltr_count);
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
+	case VCD_I_LTR_PERIOD:
+		if (sizeof(struct vcd_property_ltrperiod_type) ==
+			property_hdr->sz) {
+			struct vcd_property_ltrperiod_type ltr_period;
+			if (!encoder->ltr_control.ltr_period)
+				ltr_period.ltr_period = 0;
+			else
+				ltr_period.ltr_period =
+			encoder->ltr_control.ltr_period - 1;
+			*(struct vcd_property_ltrperiod_type *)property_value =
+				ltr_period;
+			DDL_MSG_HIGH("%s: ltr_period = %u", __func__,
+				((struct vcd_property_ltrperiod_type *)
+				property_value)->ltr_period);
+			vcd_status = VCD_S_SUCCESS;
+		}
+	break;
 	default:
+		DDL_MSG_ERROR("%s: unknown prop_id = 0x%x", __func__,
+			property_hdr->prop_id);
 		vcd_status = VCD_ERR_ILLEGAL_OP;
 		break;
 	}
@@ -1624,6 +1917,77 @@ static u32 ddl_set_enc_dynamic_property(struct ddl_client_context *ddl,
 		}
 	}
 	break;
+	case VCD_I_LTR_PERIOD:
+	{
+		if (sizeof(struct vcd_property_ltrperiod_type) ==
+			property_hdr->sz) {
+			struct vcd_property_ltrperiod_type *ltrperiod =
+				(struct vcd_property_ltrperiod_type *)
+				property_value;
+			encoder->ltr_control.ltr_period =
+				(ltrperiod->ltr_period == 0xFFFFFFFF) ?
+				0xFFFFFFFF : (ltrperiod->ltr_period + 1);
+			DDL_MSG_HIGH("%s: set ltr_period = %u", __func__,
+				encoder->ltr_control.ltr_period);
+			vcd_status = VCD_S_SUCCESS;
+		}
+	}
+	break;
+	case VCD_I_LTR_USE:
+	{
+		if (sizeof(struct vcd_property_ltruse_type) ==
+			property_hdr->sz) {
+			struct vcd_property_ltruse_type *ltruse =
+				(struct vcd_property_ltruse_type *)
+				property_value;
+			if (ltruse->ltr_id >= DDL_LTR_FRAME_START_ID) {
+				struct ddl_ltr_encoding_type *ltr_ctrl =
+					&encoder->ltr_control;
+				s32 idx;
+				idx = ddl_find_ltr_from_list(ltr_ctrl,
+					ltruse->ltr_id);
+				if (idx < 0) {
+					ltr_ctrl->callback_reqd = true;
+					ltr_ctrl->failed_use_cmd.ltr_id =
+						ltruse->ltr_id;
+					ltr_ctrl->failed_use_cmd.ltr_frames =
+						ltruse->ltr_frames;
+					DDL_MSG_ERROR("%s: index (%d) "\
+						"not found. Callback requested. "\
+						"ltr_id = %u, ltr_frames = %u",
+						__func__, idx, ltruse->ltr_id,
+						ltruse->ltr_frames);
+				} else {
+					ddl_use_ltr_from_list(ltr_ctrl, idx);
+					ltr_ctrl->ltr_use_frames =
+						ltruse->ltr_frames;
+					if (ltr_ctrl->using == false)
+						ltr_ctrl->\
+							out_frame_cnt_to_use_this_ltr =
+							ltruse->ltr_frames;
+					else
+						ltr_ctrl->\
+							pending_chg_ltr_useframes =
+							true;
+					ltr_ctrl->first_ltr_use_arvd = true;
+					ltr_ctrl->use_ltr_reqd = true;
+					DDL_MSG_HIGH("%s: index (%d) found. "\
+						"num frames to use this ltr_id (%u) "\
+						"is %u", __func__, idx,
+						ltruse->ltr_id, ltruse->ltr_frames);
+				}
+				dynamic_prop_change = DDL_ENC_LTR_USE_FRAME;
+				vcd_status = VCD_S_SUCCESS;
+			} else {
+				DDL_MSG_ERROR("%s: LTRUse ID %d failed. "\
+					"LTR ID starts from %d", __func__,
+					ltruse->ltr_id,
+					(u32)DDL_LTR_FRAME_START_ID);
+					vcd_status = VCD_ERR_ILLEGAL_OP;
+			}
+		}
+	}
+	break;
 	default:
 		vcd_status = VCD_ERR_ILLEGAL_OP;
 		break;
@@ -1691,11 +2055,16 @@ static void ddl_set_default_enc_property(struct ddl_client_context *ddl)
 	encoder->num_references_for_p_frame = DDL_MIN_NUM_REF_FOR_P_FRAME;
 	if (encoder->codec.codec == VCD_CODEC_MPEG4)
 		encoder->closed_gop = true;
+	encoder->intra_period_changed = false;
+	memset(&encoder->ltr_control, 0,
+		sizeof(struct ddl_ltr_encoding_type));
 	ddl_set_default_metadata_flag(ddl);
 	ddl_set_default_encoder_buffer_req(encoder);
 	encoder->slice_delivery_info.enable = 0;
 	encoder->slice_delivery_info.num_slices = 0;
 	encoder->slice_delivery_info.num_slices_enc = 0;
+	encoder->avc_delimiter_enable = 0;
+	encoder->vui_timinginfo_enable = 0;
 }
 
 static void ddl_set_default_enc_profile(struct ddl_encoder_data *encoder)
@@ -1763,7 +2132,7 @@ static void ddl_set_default_enc_rc_params(
 	encoder->rc_level.frame_level_rc = true;
 	encoder->qp_range.min_qp = 0x1;
 	if (codec == VCD_CODEC_H264) {
-		encoder->qp_range.min_qp = 0x4;
+		encoder->qp_range.min_qp = 0x1;
 		encoder->qp_range.max_qp = 0x33;
 		encoder->session_qp.i_frame_qp = 0x14;
 		encoder->session_qp.p_frame_qp = 0x14;
@@ -1832,12 +2201,14 @@ void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
 		encoder->input_buf_req.min_count;
 	encoder->input_buf_req.max_count    = DDL_MAX_BUFFER_COUNT;
 	encoder->input_buf_req.sz = y_cb_cr_size;
-	if (encoder->buf_format.buffer_format ==
-		VCD_BUFFER_FORMAT_NV12_16M2KA)
+	if ((encoder->buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_NV12_16M2KA) ||
+		(encoder->buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_NV21_16M2KA))
 		encoder->input_buf_req.align =
 			DDL_LINEAR_BUFFER_ALIGN_BYTES;
-	else if (VCD_BUFFER_FORMAT_TILE_4x2 ==
-		encoder->buf_format.buffer_format)
+	else if (encoder->buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_TILE_4x2)
 		encoder->input_buf_req.align = DDL_TILE_BUFFER_ALIGN_BYTES;
 	encoder->client_input_buf_req = encoder->input_buf_req;
 	memset(&encoder->output_buf_req , 0 ,
@@ -1847,8 +2218,6 @@ void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
 		encoder->output_buf_req.min_count + 3;
 	encoder->output_buf_req.max_count    = DDL_MAX_BUFFER_COUNT;
 	encoder->output_buf_req.align	= DDL_LINEAR_BUFFER_ALIGN_BYTES;
-	if (y_cb_cr_size >= VCD_DDL_720P_YUV_BUF_SIZE)
-		y_cb_cr_size = y_cb_cr_size>>1;
 	encoder->output_buf_req.sz =
 		DDL_ALIGN(y_cb_cr_size, DDL_KILO_BYTE(4));
 	ddl_set_default_encoder_metadata_buffer_size(encoder);
@@ -1864,14 +2233,20 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 	struct vcd_buffer_requirement *input_buf_req;
 	struct vcd_buffer_requirement *output_buf_req;
 	u32  min_dpb, y_cb_cr_size;
+	u32  frame_height_actual = 0;
+	u32  min_dpb_from_res_trk = 0;
 
-	if (!decoder->codec.codec)
+	if (!decoder->codec.codec) {
+		DDL_MSG_ERROR("%s: codec not set", __func__);
 		return false;
+	}
 	if (estimate) {
-		if (!decoder->cont_mode)
-			min_dpb = ddl_decoder_min_num_dpb(decoder);
-		else
+		if (decoder->cont_mode &&
+			decoder->codec.codec == VCD_CODEC_H264) {
 			min_dpb = res_trk_get_min_dpb_count();
+			min_dpb_from_res_trk = 1;
+		} else
+			min_dpb = ddl_decoder_min_num_dpb(decoder);
 		frame_size = &decoder->client_frame_size;
 		output_buf_req = &decoder->client_output_buf_req;
 		input_buf_req = &decoder->client_input_buf_req;
@@ -1887,6 +2262,7 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 		if ((decoder->buf_format.buffer_format ==
 			VCD_BUFFER_FORMAT_TILE_4x2) &&
 			(frame_size->height < MDP_MIN_TILE_HEIGHT)) {
+			frame_height_actual = frame_size->height;
 			frame_size->height = MDP_MIN_TILE_HEIGHT;
 			ddl_calculate_stride(frame_size,
 				!decoder->progressive_only);
@@ -1901,14 +2277,13 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 	}
 	memset(output_buf_req, 0,
 		sizeof(struct vcd_buffer_requirement));
-	if (!decoder->idr_only_decoding && !decoder->cont_mode)
+	if (!decoder->idr_only_decoding && !min_dpb_from_res_trk)
 		output_buf_req->actual_count = min_dpb + 4;
 	else
 		output_buf_req->actual_count = min_dpb;
 	output_buf_req->min_count = min_dpb;
 	output_buf_req->max_count = DDL_MAX_BUFFER_COUNT;
 	output_buf_req->sz = y_cb_cr_size;
-	DDL_MSG_LOW("output_buf_req->sz : %d", output_buf_req->sz);
 	if (decoder->buf_format.buffer_format != VCD_BUFFER_FORMAT_NV12)
 		output_buf_req->align = DDL_TILE_BUFFER_ALIGN_BYTES;
 	else
@@ -1917,6 +2292,14 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 		output_buf_req);
 
 	decoder->min_output_buf_req = *output_buf_req;
+	DDL_MSG_HIGH("out_buf_req: estimate = %u, WxH = %ux%u, "\
+		"min_dpb = %u, sz = %d, act = %u, min = %u, max = %u, "\
+		"align = %u, meta_buf_size = %d", estimate,
+		frame_size->width, frame_size->height, min_dpb,
+		output_buf_req->sz, output_buf_req->actual_count,
+		output_buf_req->min_count, output_buf_req->max_count,
+		output_buf_req->align, output_buf_req->meta_buffer_size);
+
 	memset(input_buf_req, 0,
 		sizeof(struct vcd_buffer_requirement));
 	input_buf_req->min_count = 1;
@@ -1925,6 +2308,10 @@ u32 ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
 	input_buf_req->sz = (1024 * 1024 * 2);
 	input_buf_req->align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
 	decoder->min_input_buf_req = *input_buf_req;
+	if (frame_height_actual) {
+		frame_size->height = frame_height_actual;
+		ddl_calculate_stride(frame_size, !decoder->progressive_only);
+	}
 	return true;
 }
 
@@ -1998,7 +2385,7 @@ static u32 ddl_valid_buffer_requirement(struct vcd_buffer_requirement
 		req_buf_req->actual_count &&
 		!((original_buf_req->align - (u32)0x1) &
 		req_buf_req->align) &&
-		
+		/*original_buf_req->align <= req_buf_req->align,*/
 		original_buf_req->sz <= req_buf_req->sz)
 		status = true;
 	else {
@@ -2029,8 +2416,8 @@ static u32 ddl_decoder_min_num_dpb(struct ddl_decoder_data *decoder)
 	case VCD_CODEC_H264:
 	{
 		u32 yuv_size_in_mb = DDL_MIN(DDL_NO_OF_MB(
-			decoder->client_frame_size.stride,
-			decoder->client_frame_size.scan_lines),
+			decoder->client_frame_size.width,
+			decoder->client_frame_size.height),
 			MAX_FRAME_SIZE_L4PT0_MBS);
 		min_dpb = DDL_MIN((MAX_DPB_SIZE_L4PT0_MBS /
 				yuv_size_in_mb), 16);
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
index 07b2fe2..62012b9 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,7 +45,7 @@
 #define VIDC_SM_DISP_PIC_PROFILE_DISP_PIC_PROFILE_SHFT      0
 
 #define VIDC_SM_DISP_PIC_FRAME_TYPE_ADDR                    0x00c0
-#define VIDC_SM_DISP_PIC_FRAME_TYPE_BMSK                    0x00000003
+#define VIDC_SM_DISP_PIC_FRAME_TYPE_BMSK                    0x0000003f
 #define VIDC_SM_DISP_PIC_FRAME_TYPE_SHFT                    0
 
 #define VIDC_SM_FREE_LUMA_DPB_ADDR                          0x00c4
@@ -83,6 +83,14 @@
 #define VIDC_SM_ENC_EXT_CTRL_ADDR                    0x0028
 #define VIDC_SM_ENC_EXT_CTRL_VBV_BUFFER_SIZE_BMSK    0xffff0000
 #define VIDC_SM_ENC_EXT_CTRL_VBV_BUFFER_SIZE_SHFT    16
+#define VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_BMSK     0x00004000
+#define VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_SHFT     14
+#define VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_BMSK 0x2000
+#define VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_SHFT 13
+#define VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_BMSK    0x00000800
+#define VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_SHFT    11
+#define VIDC_SM_ENC_EXT_CTRL_LONG_TERM_REF_ENABLE_BMSK 0x00000400
+#define VIDC_SM_ENC_EXT_CTRL_LONG_TERM_REF_ENABLE_SHFT 10
 #define VIDC_SM_ENC_EXT_CTRL_H263_CPCFC_ENABLE_BMSK  0x80
 #define VIDC_SM_ENC_EXT_CTRL_H263_CPCFC_ENABLE_SHFT  7
 #define VIDC_SM_ENC_EXT_CTRL_SPS_PPS_CONTROL_BMSK    0X100
@@ -174,6 +182,13 @@
 #define VIDC_SM_ENC_NUM_OF_SLICE_COMP_ADDR                        0x01d0
 #define VIDC_SM_ENC_NUM_OF_SLICE_COMP_VALUE_BMSK                  0xffffffff
 #define VIDC_SM_ENC_NUM_OF_SLICE_COMP_VALUE_SHFT                  0
+#define VIDC_SM_ENC_NUM_UNITS_IN_TICK_ADDR                        0x01dc
+#define VIDC_SM_ENC_NUM_UNITS_IN_TICK_VALUE_BMSK                  0xffffffff
+#define VIDC_SM_ENC_NUM_UNITS_IN_TICK_VALUE_SHFT                  0
+#define VIDC_SM_ENC_TIME_SCALE_ADDR                               0x01e0
+#define VIDC_SM_ENC_TIME_SCALE_VALUE_BMSK                         0xffffffff
+#define VIDC_SM_ENC_TIME_SCALE_VALUE_SHFT                         0
+
 
 #define VIDC_SM_ALLOCATED_LUMA_DPB_SIZE_ADDR               0x0064
 #define VIDC_SM_ALLOCATED_CHROMA_DPB_SIZE_ADDR             0x0068
@@ -296,27 +311,48 @@
 #define VIDC_SM_MP2_DATA_DUMP_BUFFER_ADDR                         0x01a4
 #define VIDC_SM_MP2_DATA_DUMP_BUFFER_SIZE_ADDR                    0x01a8
 
-
+#define VIDC_SM_MP2_COMMON_STATUS_DEC_ORDER_ADDR                  0x01b0
+#define VIDC_SM_MP2_SEQ_END_CODE_BMSK                             0x00000002
+#define VIDC_SM_MP2_SEQ_END_CODE_SHIFT                            1
 
 #define VIDC_SM_ENC_EXT_CTRL_CLOSED_GOP_ENABLE_BMSK	0x40
 #define VIDC_SM_ENC_EXT_CTRL_CLOSED_GOP_ENABLE_SHFT	6
 
+#define DDL_SHARED_MEM_11BIT_RIGHT_SHIFT  11
+
+#ifdef VIDC_REGISTER_LOG
+static void DDL_MEM_WRITE_32(struct ddl_buf_addr *shared_mem, u32 offset,
+	u32 val)
+{
+	u32 *addr;
+	VIDC_REG_OUT("\nShared mem write :REG 0x%08x: write 0x%08x",
+		offset, val);
+	addr = (u32 *)((u8 *)(shared_mem)->align_virtual_addr + (offset));
+	*addr = val;
+}
+static u32 DDL_MEM_READ_32(struct ddl_buf_addr *shared_mem, u32 offset)
+{
+	u32 val;
+	val = *((u32 *)((u8 *)(shared_mem)->align_virtual_addr + (offset)));
+	VIDC_REG_IN("\nShared mem read :REG 0x%08x: read 0x%08x",
+		offset, val);
+	return val;
+}
+#else
 #define DDL_MEM_WRITE_32(base, offset, val) ddl_mem_write_32(\
 	(u32 *) ((u8 *) (base)->align_virtual_addr + (offset)), (val))
 #define DDL_MEM_READ_32(base, offset) ddl_mem_read_32(\
 	(u32 *) ((u8 *) (base)->align_virtual_addr + (offset)))
 
-#define DDL_SHARED_MEM_11BIT_RIGHT_SHIFT  11
-
 static void ddl_mem_write_32(u32 *addr, u32 data)
 {
 	*addr = data;
 }
-
 static u32 ddl_mem_read_32(u32 *addr)
 {
 	return *addr;
 }
+#endif
 
 void vidc_sm_get_extended_decode_status(struct ddl_buf_addr *shared_mem,
 	u32 *more_field_needed,
@@ -446,10 +482,11 @@ void vidc_sm_set_extended_encoder_control(struct ddl_buf_addr
 	*shared_mem, u32 hec_enable,
 	enum VIDC_SM_frame_skip frame_skip_mode,
 	u32 seq_hdr_in_band, u32 vbv_buffer_size, u32 cpcfc_enable,
-	u32 sps_pps_control, u32 closed_gop_enable)
+	u32 sps_pps_control, u32 closed_gop_enable,
+	u32 au_delim_enable, u32 vui_timing_info_enable,
+	u32 restrict_bitstream_enable, u32 ltr_enable)
 {
 	u32 enc_ctrl;
-
 	enc_ctrl = VIDC_SETFIELD((hec_enable) ? 1 : 0,
 			VIDC_SM_ENC_EXT_CTRL_HEC_ENABLE_SHFT,
 			VIDC_SM_ENC_EXT_CTRL_HEC_ENABLE_BMSK) |
@@ -470,7 +507,20 @@ void vidc_sm_set_extended_encoder_control(struct ddl_buf_addr
 			VIDC_SM_ENC_EXT_CTRL_SPS_PPS_CONTROL_BMSK) |
 			VIDC_SETFIELD(closed_gop_enable,
 			VIDC_SM_ENC_EXT_CTRL_CLOSED_GOP_ENABLE_SHFT,
-			VIDC_SM_ENC_EXT_CTRL_CLOSED_GOP_ENABLE_BMSK);
+			VIDC_SM_ENC_EXT_CTRL_CLOSED_GOP_ENABLE_BMSK) |
+			VIDC_SETFIELD((au_delim_enable) ? 1 : 0,
+			VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_SHFT,
+			VIDC_SM_ENC_EXT_CTRL_AU_DELIMITER_EN_BMSK) |
+			VIDC_SETFIELD((vui_timing_info_enable) ? 1 : 0,
+			VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_SHFT,
+			VIDC_SM_ENC_EXT_CTRL_TIMING_INFO_EN_BMSK) |
+			VIDC_SETFIELD((restrict_bitstream_enable) ? 1 : 0,
+			VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_SHFT,
+			VIDC_SM_ENC_EXT_CTRL_STREAM_RESTRICT_EN_BMSK) |
+			VIDC_SETFIELD((ltr_enable) ? 1 : 0,
+			VIDC_SM_ENC_EXT_CTRL_LONG_TERM_REF_ENABLE_SHFT,
+			VIDC_SM_ENC_EXT_CTRL_LONG_TERM_REF_ENABLE_BMSK);
+
 	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_ENC_EXT_CTRL_ADDR, enc_ctrl);
 }
 
@@ -956,20 +1006,12 @@ void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
 		(codec == VCD_CODEC_DIVX_4) ||
 		(codec == VCD_CODEC_DIVX_5) ||
 		(codec == VCD_CODEC_DIVX_6) ||
-		(codec == VCD_CODEC_XVID) ||
-		(codec == VCD_CODEC_MPEG2)) {
-
-		if (codec == VCD_CODEC_MPEG2) {
-			aspect_ratio_info->aspect_ratio =
-				VIDC_GETFIELD(aspect_ratio,
-				VIDC_SM_MPEG2_ASPECT_RATIO_INFO_BMSK,
-				VIDC_SM_MPEG2_ASPECT_RATIO_INFO_SHFT);
-		} else {
-			aspect_ratio_info->aspect_ratio =
-				VIDC_GETFIELD(aspect_ratio,
-				VIDC_SM_MPEG4_ASPECT_RATIO_INFO_BMSK,
-				VIDC_SM_MPEG4_ASPECT_RATIO_INFO_SHFT);
-		}
+		(codec == VCD_CODEC_XVID)) {
+
+		aspect_ratio_info->aspect_ratio =
+			VIDC_GETFIELD(aspect_ratio,
+			VIDC_SM_MPEG4_ASPECT_RATIO_INFO_BMSK,
+			VIDC_SM_MPEG4_ASPECT_RATIO_INFO_SHFT);
 
 		switch (aspect_ratio_info->aspect_ratio) {
 		case 1:
@@ -1010,7 +1052,38 @@ void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
 			aspect_ratio_info->par_height   = 1;
 			break;
 		}
+	} else if (codec == VCD_CODEC_MPEG2) {
+
+		aspect_ratio_info->aspect_ratio =
+			VIDC_GETFIELD(aspect_ratio,
+			VIDC_SM_MPEG2_ASPECT_RATIO_INFO_BMSK,
+			VIDC_SM_MPEG2_ASPECT_RATIO_INFO_SHFT);
+
+		switch (aspect_ratio_info->aspect_ratio) {
+		case 1:
+			aspect_ratio_info->par_width    = 1;
+			aspect_ratio_info->par_height   = 1;
+			break;
+		case 2:
+			aspect_ratio_info->par_width    = 4;
+			aspect_ratio_info->par_height   = 3;
+			break;
+		case 3:
+			aspect_ratio_info->par_width    = 16;
+			aspect_ratio_info->par_height   = 9;
+			break;
+		case 4:
+			aspect_ratio_info->par_width    = 221;
+			aspect_ratio_info->par_height   = 100;
+			break;
+		default:
+			DDL_MSG_LOW("Incorrect Aspect Ratio.");
+			aspect_ratio_info->par_width    = 1;
+			aspect_ratio_info->par_height   = 1;
+			break;
+		}
 	}
+
 }
 
 void vidc_sm_set_encoder_slice_batch_int_ctrl(struct ddl_buf_addr *shared_mem,
@@ -1133,3 +1206,26 @@ void vidc_sm_set_mp2datadumpbuffer(struct ddl_buf_addr *shared_mem,
 			VIDC_SM_MP2_DATA_DUMP_BUFFER_SIZE_ADDR,
 			mp2datadumpsize);
 }
+
+void vidc_sm_set_h264_encoder_timing_info(struct ddl_buf_addr *shared_mem,
+	u32 num_units_in_tick, u32 time_scale)
+{
+	DDL_MEM_WRITE_32(shared_mem,
+			VIDC_SM_ENC_NUM_UNITS_IN_TICK_ADDR,
+			num_units_in_tick);
+
+	DDL_MEM_WRITE_32(shared_mem,
+			VIDC_SM_ENC_TIME_SCALE_ADDR,
+			time_scale);
+}
+
+void vidc_sm_get_mp2common_status(struct ddl_buf_addr *shared_mem,
+	u32 *seq_end_code_present)
+{
+	u32 status;
+	status = DDL_MEM_READ_32(shared_mem,
+			VIDC_SM_MP2_COMMON_STATUS_DEC_ORDER_ADDR);
+	*seq_end_code_present = (u32) VIDC_GETFIELD(status,
+				VIDC_SM_MP2_SEQ_END_CODE_BMSK,
+				VIDC_SM_MP2_SEQ_END_CODE_SHIFT);
+}
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
index 9cb1933..5c0db51 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -106,7 +106,8 @@ void vidc_sm_set_extended_encoder_control(
 	struct ddl_buf_addr *shared_mem, u32 hec_enable,
 	enum VIDC_SM_frame_skip  frame_skip_mode, u32 seq_hdr_in_band,
 	u32 vbv_buffer_size, u32 cpcfc_enable, u32 sps_pps_control,
-	u32 closed_gop_enable);
+	u32 closed_gop_enable, u32 au_delim_enable, u32 vui_timing_info_enable,
+	u32 restrict_bitstream_enable, u32 ltr_enable);
 void vidc_sm_set_encoder_param_change(struct ddl_buf_addr *shared_mem,
 	u32 bit_rate_chg, u32 frame_rate_chg, u32 i_period_chg);
 void vidc_sm_set_encoder_vop_time(struct ddl_buf_addr *shared_mem,
@@ -198,6 +199,10 @@ void vidc_sm_get_mp2datadump_status(struct ddl_buf_addr
 void vidc_sm_set_mp2datadump_enable(struct ddl_buf_addr *shared_mem,
 	struct ddl_mp2_datadumpenabletype *ddl_mp2_datadump_enable);
 void vidc_sm_set_mp2datadumpbuffer(struct ddl_buf_addr *shared_mem,
-		u32 mp2datadumpaddr, u32 mp2datadumpsize);
+	u32 mp2datadumpaddr, u32 mp2datadumpsize);
+void vidc_sm_set_h264_encoder_timing_info(struct ddl_buf_addr *shared_mem,
+	u32 num_units_in_tick, u32 time_scale);
+void vidc_sm_get_mp2common_status(struct ddl_buf_addr *shared_mem,
+	u32 *seq_end_code_present);
 
 #endif
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
index 2d64f5f..05acc6e 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,7 +24,7 @@ struct time_data {
 	unsigned int ddl_count;
 };
 static struct time_data proc_time[MAX_TIME_DATA];
-#define DDL_MSG_TIME(x...) printk(KERN_DEBUG "[VID] " x)
+#define DDL_MSG_TIME(x...) printk(KERN_DEBUG x)
 static unsigned int vidc_mmu_subsystem[] =	{
 		MSM_SUBSYSTEM_VIDEO, MSM_SUBSYSTEM_VIDEO_FWARE};
 
@@ -45,7 +45,6 @@ void *ddl_pmem_alloc(struct ddl_buf_addr *addr, size_t sz, u32 alignment)
 	unsigned long iova = 0;
 	unsigned long buffer_size = 0;
 	unsigned long *kernel_vaddr = NULL;
-	unsigned long ionflag = 0;
 	unsigned long flags = 0;
 	int ret = 0;
 	ion_phys_addr_t phyaddr = 0;
@@ -71,20 +70,15 @@ void *ddl_pmem_alloc(struct ddl_buf_addr *addr, size_t sz, u32 alignment)
 		alloc_size = (alloc_size+4095) & ~4095;
 		addr->alloc_handle = ion_alloc(
 		ddl_context->video_ion_client, alloc_size, SZ_4K,
-			res_trk_get_mem_type());
+			res_trk_get_mem_type(), res_trk_get_ion_flags());
 		if (IS_ERR_OR_NULL(addr->alloc_handle)) {
 			DDL_MSG_ERROR("%s() :DDL ION alloc failed\n",
 						 __func__);
 			goto bail_out;
 		}
-		if (res_trk_check_for_sec_session() ||
-			addr->mem_type == DDL_FW_MEM)
-			ionflag = UNCACHED;
-		else
-			ionflag = CACHED;
 		kernel_vaddr = (unsigned long *) ion_map_kernel(
 					ddl_context->video_ion_client,
-					addr->alloc_handle, ionflag);
+					addr->alloc_handle);
 		if (IS_ERR_OR_NULL(kernel_vaddr)) {
 				DDL_MSG_ERROR("%s() :DDL ION map failed\n",
 							 __func__);
@@ -111,7 +105,7 @@ void *ddl_pmem_alloc(struct ddl_buf_addr *addr, size_t sz, u32 alignment)
 					0,
 					&iova,
 					&buffer_size,
-					UNCACHED, 0);
+					0, 0);
 			if (ret || !iova) {
 				DDL_MSG_ERROR(
 				"%s():DDL ION ion map iommu failed, ret = %d iova = 0x%lx\n",
@@ -119,6 +113,11 @@ void *ddl_pmem_alloc(struct ddl_buf_addr *addr, size_t sz, u32 alignment)
 				goto unmap_ion_alloc;
 			}
 			addr->alloced_phys_addr = (phys_addr_t) iova;
+
+			msm_ion_do_cache_op(ddl_context->video_ion_client,
+					addr->alloc_handle,
+					addr->virtual_base_addr,
+					sz, ION_IOC_CLEAN_INV_CACHES);
 		}
 		if (!addr->alloced_phys_addr) {
 			DDL_MSG_ERROR("%s():DDL ION client physical failed\n",
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h
index 162579f..d7b4b10 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,17 +35,18 @@ enum timing_data {
 } while (0)
 
 #ifdef DDL_MSG_LOG
-#define DDL_MSG_LOW(x...)    printk(KERN_INFO "[VID] " x)
-#define DDL_MSG_MED(x...)    printk(KERN_INFO "[VID] " x)
-#define DDL_MSG_HIGH(x...)   printk(KERN_INFO "[VID] " x)
+#define DDL_MSG_LOW(x...)    printk(KERN_INFO x)
+#define DDL_MSG_MED(x...)    printk(KERN_INFO x)
+#define DDL_MSG_HIGH(x...)   printk(KERN_INFO x)
 #else
 #define DDL_MSG_LOW(x...)
 #define DDL_MSG_MED(x...)
 #define DDL_MSG_HIGH(x...)
 #endif
 
-#define DDL_MSG_ERROR(x...)  printk(KERN_INFO "[VID] " x)
-#define DDL_MSG_FATAL(x...)  printk(KERN_INFO "[VID] " x)
+#define DDL_MSG_INFO(x...)   printk(KERN_INFO x)
+#define DDL_MSG_ERROR(x...)  printk(KERN_INFO x)
+#define DDL_MSG_FATAL(x...)  printk(KERN_INFO x)
 
 #define DDL_ALIGN_SIZE(sz, guard_bytes, align_mask) \
 	(((u32)(sz) + guard_bytes) & align_mask)
@@ -62,7 +63,8 @@ enum timing_data {
 #define DDL_GET_ALIGNED_VITUAL(x)   ((x).align_virtual_addr)
 #define DDL_KILO_BYTE(x)   ((x)*1024)
 #define DDL_MEGA_BYTE(x)   ((x)*1024*1024)
-#define DDL_FRAMERATE_SCALE(x)            ((x) * 1000)
+#define DDL_FRAMERATE_SCALE_FACTOR      (1000)
+#define DDL_FRAMERATE_SCALE(x)          ((x) * DDL_FRAMERATE_SCALE_FACTOR)
 
 #define DDL_MIN(x, y)  ((x < y) ? x : y)
 #define DDL_MAX(x, y)  ((x > y) ? x : y)
diff --git a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
index 978d1de..d985c66 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,6 +15,7 @@
 #include "vcd_ddl_metadata.h"
 #include "vcd_ddl_shared_mem.h"
 #include "vcd_core.h"
+#include "vcd_res_tracker_api.h"
 
 #if defined(PIX_CACHE_DISABLE)
 #define DDL_PIX_CACHE_ENABLE  false
@@ -108,7 +109,9 @@ void ddl_vidc_channel_set(struct ddl_client_context *ddl)
 		dec_pix_cache = VIDC_1080P_DECODE_PCACHE_DISABLE;
 	const enum vidc_1080p_encode_p_cache_enable
 		enc_pix_cache = VIDC_1080P_ENCODE_PCACHE_ENABLE;
-	u32 pix_cache_ctrl, ctxt_mem_offset, ctxt_mem_size;
+	u32 pix_cache_ctrl, ctxt_mem_offset, ctxt_mem_size, arg1 = 0;
+	u8 *hw_ctxt = NULL;
+	struct ion_handle *alloc_handle;
 
 	if (ddl->decoding) {
 		ddl_set_core_start_time(__func__, DEC_OP_TIME);
@@ -116,15 +119,30 @@ void ddl_vidc_channel_set(struct ddl_client_context *ddl)
 		pix_cache_ctrl = (u32)dec_pix_cache;
 		ctxt_mem_offset = DDL_ADDR_OFFSET(ddl_context->dram_base_a,
 		ddl->codec_data.decoder.hw_bufs.context) >> 11;
+		hw_ctxt =
+		ddl->codec_data.decoder.hw_bufs.context.align_virtual_addr;
 		ctxt_mem_size =
 			ddl->codec_data.decoder.hw_bufs.context.buffer_size;
+		alloc_handle =
+			ddl->codec_data.decoder.hw_bufs.context.alloc_handle;
 	} else {
 		vcd_codec = &(ddl->codec_data.encoder.codec.codec);
 		pix_cache_ctrl = (u32)enc_pix_cache;
 		ctxt_mem_offset = DDL_ADDR_OFFSET(ddl_context->dram_base_a,
 			ddl->codec_data.encoder.hw_bufs.context) >> 11;
+		hw_ctxt =
+		ddl->codec_data.encoder.hw_bufs.context.align_virtual_addr;
 		ctxt_mem_size =
 			ddl->codec_data.encoder.hw_bufs.context.buffer_size;
+		alloc_handle =
+			ddl->codec_data.encoder.hw_bufs.context.alloc_handle;
+	}
+	if (!res_trk_check_for_sec_session() && hw_ctxt) {
+		memset(hw_ctxt, 0, ctxt_mem_size);
+		msm_ion_do_cache_op(ddl_context->video_ion_client,
+			alloc_handle, hw_ctxt, ctxt_mem_size,
+			ION_IOC_CLEAN_INV_CACHES);
+		arg1 = 1 << 29;
 	}
 	switch (*vcd_codec) {
 	default:
@@ -184,8 +202,9 @@ void ddl_vidc_channel_set(struct ddl_client_context *ddl)
 	DDL_MSG_LOW("ddl_state_transition: %s ~~> DDL_CLIENT_WAIT_FOR_CHDONE",
 	ddl_get_state_string(ddl->client_state));
 	ddl->client_state = DDL_CLIENT_WAIT_FOR_CHDONE;
+	arg1 |= (u32)codec;
 	vidc_1080p_set_host2risc_cmd(VIDC_1080P_HOST2RISC_CMD_OPEN_CH,
-		(u32)codec, pix_cache_ctrl, ctxt_mem_offset,
+		arg1, pix_cache_ctrl, ctxt_mem_offset,
 		ctxt_mem_size);
 }
 
@@ -320,7 +339,7 @@ void ddl_vidc_encode_dynamic_property(struct ddl_client_context *ddl,
 {
 	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
 	u32 frame_rate_change = false, bit_rate_change = false;
-	u32 i_period_change = false, reset_req = false;
+	u32 reset_req = false;
 
 	if (!enable) {
 		if (encoder->dynmic_prop_change_req) {
@@ -333,6 +352,17 @@ void ddl_vidc_encode_dynamic_property(struct ddl_client_context *ddl,
 			encoder->dynamic_prop_change &=
 				~(DDL_ENC_REQ_IFRAME);
 		}
+		if (encoder->dynamic_prop_change & DDL_ENC_LTR_USE_FRAME) {
+			if (encoder->ltr_control.callback_reqd) {
+				DDL_MSG_ERROR("%s: LTR use failed", __func__);
+				ddl_encoder_use_ltr_fail_callback(ddl);
+				encoder->ltr_control.callback_reqd = false;
+			} else {
+				encoder->ltr_control.use_ltr_reqd = true;
+			}
+			encoder->dynamic_prop_change &=
+				~(DDL_ENC_LTR_USE_FRAME);
+		}
 		if ((encoder->dynamic_prop_change &
 			DDL_ENC_CHANGE_BITRATE)) {
 			bit_rate_change = true;
@@ -344,7 +374,7 @@ void ddl_vidc_encode_dynamic_property(struct ddl_client_context *ddl,
 		}
 		if ((encoder->dynamic_prop_change
 			& DDL_ENC_CHANGE_IPERIOD)) {
-			i_period_change = true;
+			encoder->intra_period_changed = true;
 			vidc_sm_set_encoder_new_i_period(
 				&ddl->shared_mem[ddl->command_channel],
 				encoder->i_period.p_frames);
@@ -359,6 +389,15 @@ void ddl_vidc_encode_dynamic_property(struct ddl_client_context *ddl,
 				(u32)(DDL_FRAMERATE_SCALE(encoder->\
 				frame_rate.fps_numerator) /
 				encoder->frame_rate.fps_denominator));
+			if (encoder->vui_timinginfo_enable &&
+				encoder->frame_rate.fps_denominator) {
+				vidc_sm_set_h264_encoder_timing_info(
+					&ddl->shared_mem[ddl->command_channel],
+					DDL_FRAMERATE_SCALE_FACTOR,
+					(u32)(DDL_FRAMERATE_SCALE(encoder->\
+					frame_rate.fps_numerator) / encoder->\
+					frame_rate.fps_denominator) << 1);
+			}
 			encoder->dynamic_prop_change &=
 				~(DDL_ENC_CHANGE_FRAMERATE);
 		}
@@ -367,7 +406,7 @@ void ddl_vidc_encode_dynamic_property(struct ddl_client_context *ddl,
 		vidc_sm_set_encoder_param_change(
 			&ddl->shared_mem[ddl->command_channel],
 			bit_rate_change, frame_rate_change,
-			i_period_change);
+			encoder->intra_period_changed);
 	}
 }
 
@@ -560,7 +599,7 @@ void ddl_vidc_encode_init_codec(struct ddl_client_context *ddl)
 	u32 index, luma[4], chroma[4], hdr_ext_control = false;
 	const u32 recon_bufs = 4;
 	u32 h263_cpfc_enable = false;
-	u32 scaled_frame_rate;
+	u32 scaled_frame_rate, ltr_enable;
 
 	ddl_vidc_encode_set_profile_level(ddl);
 	vidc_1080p_set_encode_frame_size(encoder->frame_size.width,
@@ -581,11 +620,21 @@ void ddl_vidc_encode_init_codec(struct ddl_client_context *ddl)
 		(DDL_FRAMERATE_SCALE(DDL_INITIAL_FRAME_RATE)
 		 != scaled_frame_rate))
 		h263_cpfc_enable = true;
+	ltr_enable = DDL_IS_LTR_ENABLED(encoder);
+	DDL_MSG_HIGH("ltr_enable = %u", ltr_enable);
 	vidc_sm_set_extended_encoder_control(&ddl->shared_mem
 		[ddl->command_channel], hdr_ext_control,
 		r_cframe_skip, false, 0,
 		h263_cpfc_enable, encoder->sps_pps.sps_pps_for_idr_enable_flag,
-		encoder->closed_gop);
+		encoder->closed_gop, encoder->avc_delimiter_enable,
+		encoder->vui_timinginfo_enable,
+		encoder->bitstream_restrict_enable, ltr_enable);
+	if (encoder->vui_timinginfo_enable) {
+		vidc_sm_set_h264_encoder_timing_info(
+			&ddl->shared_mem[ddl->command_channel],
+			DDL_FRAMERATE_SCALE_FACTOR,
+			scaled_frame_rate << 1);
+	}
 	vidc_sm_set_encoder_init_rc_value(&ddl->shared_mem
 		[ddl->command_channel],
 		encoder->target_bit_rate.target_bitrate);
@@ -707,8 +756,15 @@ void ddl_vidc_encode_init_codec(struct ddl_client_context *ddl)
 	default:
 	break;
 	}
-	if (encoder->buf_format.buffer_format ==
-		VCD_BUFFER_FORMAT_NV12_16M2KA)
+	if ((encoder->buf_format.buffer_format ==
+			VCD_BUFFER_FORMAT_NV21_16M2KA)) {
+		DDL_MSG_LOW("NV21 Input format is set to the core");
+		vidc_1080p_set_enc_NV21(true);
+	}
+	if ((encoder->buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_NV12_16M2KA) ||
+		(encoder->buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_NV21_16M2KA))
 		mem_access_method = VIDC_1080P_TILE_LINEAR;
 	else
 		mem_access_method = VIDC_1080P_TILE_64x32;
@@ -753,7 +809,8 @@ void ddl_vidc_encode_frame_run(struct ddl_client_context *ddl)
 	struct vcd_frame_data *stream = &(ddl->output_frame.vcd_frm);
 	struct vcd_frame_data *input_vcd_frm =
 		&(ddl->input_frame.vcd_frm);
-	u32 dpb_addr_y[4], dpb_addr_c[4];
+	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
 	u32 index, y_addr, c_addr;
 
 	DDL_MSG_LOW("%s\n", __func__);
@@ -783,6 +840,8 @@ void ddl_vidc_encode_frame_run(struct ddl_client_context *ddl)
 		ddl_vidc_encode_dynamic_property(ddl, true);
 	}
 
+	if (DDL_IS_LTR_ENABLED(encoder))
+		ddl_encoder_ltr_control(ddl);
 	vidc_1080p_set_encode_circular_intra_refresh(
 		encoder->intra_refresh.cir_mb_number);
 	ddl_vidc_encode_set_multi_slice_info(encoder);
@@ -803,6 +862,17 @@ void ddl_vidc_encode_frame_run(struct ddl_client_context *ddl)
 		encoder->intra_frame_insertion = false;
 	enc_param.input_flush = false;
 	enc_param.slice_enable = false;
+	enc_param.store_ltr0 = encoder->ltr_control.store_ltr0;
+	enc_param.store_ltr1 = encoder->ltr_control.store_ltr1;
+	enc_param.use_ltr0 = encoder->ltr_control.use_ltr0;
+	enc_param.use_ltr1 = encoder->ltr_control.use_ltr1;
+
+	encoder->intra_frame_insertion = false;
+	encoder->intra_period_changed = false;
+	encoder->ltr_control.store_ltr0 = false;
+	encoder->ltr_control.store_ltr1 = false;
+	encoder->ltr_control.use_ltr0 = false;
+	encoder->ltr_control.use_ltr1 = false;
 		vidc_sm_set_encoder_vop_time(
 			&ddl->shared_mem[ddl->command_channel], true,
 			encoder->vop_timing.vop_time_resolution,
@@ -861,7 +931,8 @@ void ddl_vidc_encode_slice_batch_run(struct ddl_client_context *ddl)
 	struct ddl_enc_buffers *enc_buffers = &(encoder->hw_bufs);
 	struct vcd_frame_data *input_vcd_frm =
 		&(ddl->input_frame.vcd_frm);
-	u32 dpb_addr_y[4], dpb_addr_c[4];
+	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
 	u32 index, y_addr, c_addr;
 	u32 bitstream_size;
 	struct vidc_1080p_enc_slice_batch_in_param *slice_batch_in =
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc.c b/drivers/video/msm/vidc/1080p/ddl/vidc.c
index d399847..45ec601 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -83,6 +83,17 @@
 #define VIDC_1080P_SI_RG10_ENCODE_SLICE_IF_ENABLE_SHFT      31
 #define VIDC_1080P_MAX_INTRA_PERIOD 0xffff
 
+#define VIDC_1080P_COMMON_CHX_RG6_I_FRAME_BMASK 0x00000001
+#define VIDC_1080P_COMMON_CHX_RG6_I_FRAME_SHIFT 0
+#define VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_BMASK 0x00000008
+#define VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_SHIFT 3
+#define VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_BMASK 0x00000010
+#define VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_SHIFT 4
+#define VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_BMASK 0x00000020
+#define VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_SHIFT 5
+#define VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_BMASK 0x00000040
+#define VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_SHIFT 6
+
 u8 *VIDC_BASE_PTR;
 
 void vidc_1080p_do_sw_reset(enum vidc_1080p_reset init_flag)
@@ -194,6 +205,95 @@ void vidc_1080p_get_risc2host_cmd_status(u32 err_status,
 
 }
 
+void vidc_1080p_get_mgenaxi_error_info(u32 *axi_error_info_a,
+	u32 *axi_error_info_b)
+{
+	VIDC_HWIO_IN(REG_736158, axi_error_info_a);
+	VIDC_HWIO_IN(REG_598415, axi_error_info_b);
+}
+
+void vidc_1080p_get_mgen2axi_status(struct vidc_1080P_axi_status *axi_a_status,
+	struct vidc_1080P_axi_status *axi_b_status)
+{
+	u32 status;
+	VIDC_HWIO_IN(REG_437878, &status);
+	axi_a_status->axi_error_interrupt = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_A_ERR_INTR_BMSK,
+		HWIO_REG_437878_AXI_A_ERR_INTR_SHFT);
+	axi_a_status->axi_halt_ack = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_A_HALT_ACK_BMSK,
+		HWIO_REG_437878_AXI_A_HALT_ACK_SHFT);
+	axi_a_status->axi_idle = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_A_IDLE_BMSK,
+		HWIO_REG_437878_AXI_A_IDLE_SHFT);
+	axi_a_status->axi_watchdog_error_interrupt = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_A_WDTIMEOUT_INTR_BMSK,
+		HWIO_REG_437878_AXI_A_WDTIMEOUT_INTR_SHFT);
+	axi_b_status->axi_error_interrupt = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_B_ERR_INTR_BMSK,
+		HWIO_REG_437878_AXI_B_ERR_INTR_SHFT);
+	axi_b_status->axi_halt_ack = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_B_HALT_ACK_BMSK,
+		HWIO_REG_437878_AXI_B_HALT_ACK_SHFT);
+	axi_b_status->axi_idle = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_B_IDLE_BMSK,
+		HWIO_REG_437878_AXI_B_IDLE_SHFT);
+	axi_b_status->axi_watchdog_error_interrupt = VIDC_GETFIELD(status,
+		HWIO_REG_437878_AXI_B_WDTIMEOUT_INTR_BMSK,
+		HWIO_REG_437878_AXI_B_WDTIMEOUT_INTR_SHFT);
+}
+
+void vidc_1080p_get_mgen2maxi_ctrl(struct vidc_1080P_axi_ctrl *ctrl)
+{
+	u32 ctrl_value;
+	VIDC_HWIO_IN(REG_471159, &ctrl_value);
+	ctrl->axi_halt_req = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_HALT_REQ_BMSK,
+		HWIO_REG_471159_AXI_HALT_REQ_SHFT);
+	ctrl->axi_reset = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_RESET_BMSK,
+		HWIO_REG_471159_AXI_RESET_SHFT);
+	ctrl->axi_halt_on_readerror = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_HALT_ON_RD_ERR_BMSK,
+		HWIO_REG_471159_AXI_HALT_ON_RD_ERR_SHFT);
+	ctrl->axi_halt_on_writeerror = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_HALT_ON_WR_ERR_BMSK,
+		HWIO_REG_471159_AXI_HALT_ON_WR_ERR_SHFT);
+	ctrl->axi_halt_on_watchdog_timeout = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_HALT_ON_WDTIMEOUT_BMSK,
+		HWIO_REG_471159_AXI_HALT_ON_WDTIMEOUT_SHFT);
+	ctrl->axi_watchdog_timeout_value = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_WDTIMEOUT_LOG2_BMSK,
+		HWIO_REG_471159_AXI_WDTIMEOUT_LOG2_SHFT);
+	ctrl->axi_interrupt_clr = VIDC_GETFIELD(ctrl_value,
+		HWIO_REG_471159_AXI_INTR_CLR_BMSK,
+		HWIO_REG_471159_AXI_INTR_CLR_SHFT);
+}
+
+void vidc_1080p_set_mgen2maxi_ctrl(struct vidc_1080P_axi_ctrl *ctrl)
+{
+	u32 ctrl_value;
+	ctrl_value = VIDC_SETFIELD(ctrl->axi_halt_req,
+		HWIO_REG_471159_AXI_HALT_REQ_SHFT,
+		HWIO_REG_471159_AXI_HALT_REQ_BMSK);
+	ctrl_value |= VIDC_SETFIELD(ctrl->axi_reset,
+		HWIO_REG_471159_AXI_RESET_SHFT,
+		HWIO_REG_471159_AXI_RESET_BMSK);
+	ctrl_value |= VIDC_SETFIELD(ctrl->axi_halt_on_readerror,
+		HWIO_REG_471159_AXI_HALT_ON_RD_ERR_SHFT,
+		HWIO_REG_471159_AXI_HALT_ON_RD_ERR_BMSK);
+	ctrl_value |= VIDC_SETFIELD(ctrl->axi_halt_on_writeerror,
+		HWIO_REG_471159_AXI_HALT_ON_WR_ERR_SHFT,
+		HWIO_REG_471159_AXI_HALT_ON_WR_ERR_BMSK);
+	ctrl_value |= VIDC_SETFIELD(ctrl->axi_halt_on_watchdog_timeout,
+		HWIO_REG_471159_AXI_HALT_ON_WDTIMEOUT_SHFT,
+		HWIO_REG_471159_AXI_HALT_ON_WDTIMEOUT_BMSK);
+	ctrl_value |= VIDC_SETFIELD(ctrl->axi_interrupt_clr,
+		HWIO_REG_471159_AXI_INTR_CLR_SHFT,
+		HWIO_REG_471159_AXI_INTR_CLR_BMSK);
+	VIDC_HWIO_OUT(REG_471159, ctrl_value);
+}
+
 void vidc_1080p_clear_risc2host_cmd(void)
 {
 	VIDC_HWIO_OUT(REG_695082, VIDC_1080P_RISC2HOST_CMD_EMPTY);
@@ -520,8 +620,12 @@ void vidc_1080p_get_decode_frame(
 	u32 frame = 0;
 
 	VIDC_HWIO_IN(REG_760102, &frame);
-	*pe_frame = (enum vidc_1080p_decode_frame)
-		(frame & VIDC_1080P_SI_RG8_DECODE_FRAMETYPE_MASK);
+	if (frame & 0x10)
+		*pe_frame = (enum vidc_1080p_decode_frame)
+			VIDC_1080P_DECODE_FRAMETYPE_IDR;
+	else
+		*pe_frame = (enum vidc_1080p_decode_frame)
+			(frame & VIDC_1080P_SI_RG8_DECODE_FRAMETYPE_MASK);
 }
 
 void vidc_1080p_get_decode_frame_result(
@@ -783,7 +887,8 @@ void vidc_1080p_encode_seq_start_ch1(
 void vidc_1080p_encode_frame_start_ch0(
 	struct vidc_1080p_enc_frame_start_param *param)
 {
-	u32 input_flush;
+	u32 input_flush = 0;
+	u32 frame_insertion = 0;
 	VIDC_HWIO_OUT(REG_695082, VIDC_1080P_RISC2HOST_CMD_EMPTY);
 	VIDC_HWIO_OUT(REG_666957, VIDC_1080P_INIT_CH_INST_ID);
 	VIDC_HWIO_OUT(REG_117192,
@@ -794,7 +899,22 @@ void vidc_1080p_encode_frame_start_ch0(
 		VIDC_1080P_BASE_OFFSET_SHIFT);
 	VIDC_HWIO_OUT(REG_175608, param->current_c_addr_offset >>
 		VIDC_1080P_BASE_OFFSET_SHIFT);
-	VIDC_HWIO_OUT(REG_190381, param->intra_frame);
+	frame_insertion = VIDC_SETFIELD(param->intra_frame,
+		VIDC_1080P_COMMON_CHX_RG6_I_FRAME_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_I_FRAME_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->store_ltr0,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->store_ltr1,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->use_ltr0,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->use_ltr1,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_BMASK);
+	VIDC_HWIO_OUT(REG_190381, frame_insertion);
 	VIDC_HWIO_OUT(REG_889944, param->shared_mem_addr_offset);
 	input_flush = VIDC_SETFIELD(param->input_flush,
 			VIDC_1080P_SI_RG10_ENCODE_INPUT_BUFFER_FLUSH_SHFT,
@@ -812,7 +932,8 @@ void vidc_1080p_encode_frame_start_ch0(
 void vidc_1080p_encode_frame_start_ch1(
 	struct vidc_1080p_enc_frame_start_param *param)
 {
-	u32 input_flush;
+	u32 input_flush = 0;
+	u32 frame_insertion = 0;
 	VIDC_HWIO_OUT(REG_695082, VIDC_1080P_RISC2HOST_CMD_EMPTY);
 	VIDC_HWIO_OUT(REG_313350, VIDC_1080P_INIT_CH_INST_ID);
 	VIDC_HWIO_OUT(REG_980194,
@@ -823,7 +944,22 @@ void vidc_1080p_encode_frame_start_ch1(
 		VIDC_1080P_BASE_OFFSET_SHIFT);
 	VIDC_HWIO_OUT(REG_548308,  param->current_c_addr_offset >>
 		VIDC_1080P_BASE_OFFSET_SHIFT);
-	VIDC_HWIO_OUT(REG_887095, param->intra_frame);
+	frame_insertion = VIDC_SETFIELD(param->intra_frame,
+		VIDC_1080P_COMMON_CHX_RG6_I_FRAME_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_I_FRAME_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->store_ltr0,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR0_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->store_ltr1,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_STORE_LTR1_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->use_ltr0,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR0_BMASK);
+	frame_insertion |= VIDC_SETFIELD(param->use_ltr1,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_SHIFT,
+		VIDC_1080P_COMMON_CHX_RG6_USE_LTR1_BMASK);
+	VIDC_HWIO_OUT(REG_887095, frame_insertion);
 	VIDC_HWIO_OUT(REG_652528, param->shared_mem_addr_offset);
 	input_flush = VIDC_SETFIELD(param->input_flush,
 			VIDC_1080P_SI_RG10_ENCODE_INPUT_BUFFER_FLUSH_SHFT,
@@ -1106,3 +1242,8 @@ void vidc_1080p_frame_start_realloc(u32 instance_id)
 	VIDC_HWIO_OUT(REG_666957,
 		VIDC_1080P_DEC_TYPE_FRAME_START_REALLOC | instance_id);
 }
+
+void vidc_1080p_set_enc_NV21(u32 enc_nv21)
+{
+	VIDC_HWIO_OUT(REG_515664, enc_nv21);
+}
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc.h b/drivers/video/msm/vidc/1080p/ddl/vidc.h
index 7b8dc6f..d8976bd 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -103,6 +103,7 @@
 #define VIDC_1080P_ERROR_SPS_PARSE_ERROR         129
 #define VIDC_1080P_ERROR_PPS_PARSE_ERROR         130
 #define VIDC_1080P_ERROR_SLICE_PARSE_ERROR       131
+#define VIDC_1080P_ERROR_NON_IDR_FRAME_TYPE      132
 #define VIDC_1080P_ERROR_SYNC_POINT_NOT_RECEIVED  171
 
 #define VIDC_1080P_WARN_COMMAND_FLUSHED                  145
@@ -190,6 +191,7 @@
 #define VIDC_1080P_ITLB_MISS_EXCEPTION_HANDLER        0x100
 #define VIDC_1080P_DATA_PAGE_FAULT_EXCEPTION_HANDLER  0x200
 #define VIDC_1080P_INST_PAGE_FAULT_EXCEPTION_HANDLER  0x400
+#define VIDC_1080P_MAX_DEC_DPB                        19
 #define VIDC_1080P_SLICE_BATCH_MAX_STRM_BFR           8
 #define VIDC_1080P_SLICE_BATCH_IN_SIZE(idx)           (4 * sizeof(u32) + \
 							idx * sizeof(u32))
@@ -277,6 +279,7 @@ enum vidc_1080p_decode_frame{
 	VIDC_1080P_DECODE_FRAMETYPE_P          = 2,
 	VIDC_1080P_DECODE_FRAMETYPE_B          = 3,
 	VIDC_1080P_DECODE_FRAMETYPE_OTHERS     = 4,
+	VIDC_1080P_DECODE_FRAMETYPE_IDR        = 5,
 	VIDC_1080P_DECODE_FRAMETYPE_32BIT      = 0x7FFFFFFF
 };
 enum vidc_1080P_decode_frame_correct_type {
@@ -398,6 +401,10 @@ struct vidc_1080p_enc_frame_start_param{
 	u32 intra_frame;
 	u32 input_flush;
 	u32 slice_enable;
+	u32 store_ltr0;
+	u32 store_ltr1;
+	u32 use_ltr0;
+	u32 use_ltr1;
 	enum vidc_1080p_encode encode;
 };
 struct vidc_1080p_enc_frame_info{
@@ -426,6 +433,23 @@ struct vidc_1080p_enc_slice_batch_out_param {
 	struct vidc_1080p_enc_slice_info slice_info
 		[VIDC_1080P_SLICE_BATCH_MAX_STRM_BFR];
 };
+
+struct vidc_1080P_axi_ctrl {
+	u32 axi_halt_req;
+	u32 axi_reset;
+	u32 axi_halt_on_readerror;
+	u32 axi_halt_on_writeerror;
+	u32 axi_halt_on_watchdog_timeout;
+	u32 axi_watchdog_timeout_value;
+	u32 axi_interrupt_clr;
+};
+struct vidc_1080P_axi_status {
+	u32 axi_halt_ack;
+	u32 axi_idle;
+	u32 axi_error_interrupt;
+	u32 axi_watchdog_error_interrupt;
+};
+
 struct vidc_1080p_dec_disp_info{
 	u32 disp_resl_change;
 	u32 dec_resl_change;
@@ -470,6 +494,12 @@ void vidc_1080p_get_risc2host_cmd(u32 *pn_risc2host_command,
 	u32 *pn_risc2host_arg3, u32 *pn_risc2host_arg4);
 void vidc_1080p_get_risc2host_cmd_status(u32 err_status,
 	u32 *dec_err_status, u32 *disp_err_status);
+void vidc_1080p_get_mgen2maxi_ctrl(struct vidc_1080P_axi_ctrl *ctrl);
+void vidc_1080p_set_mgen2maxi_ctrl(struct vidc_1080P_axi_ctrl *ctrl);
+void vidc_1080p_get_mgenaxi_error_info(u32 *axi_error_info_a,
+	u32 *axi_error_info_b);
+void vidc_1080p_get_mgen2axi_status(struct vidc_1080P_axi_status *axi_a_status,
+	struct vidc_1080P_axi_status *axi_b_status);
 void vidc_1080p_clear_risc2host_cmd(void);
 void vidc_1080p_get_fw_version(u32 *pn_fw_version);
 void vidc_1080p_get_fw_status(u32 *pn_fw_status);
@@ -584,4 +614,6 @@ void vidc_1080p_get_intermedia_stage_debug_counter(
 	u32 *intermediate_stage_counter);
 void vidc_1080p_get_exception_status(u32 *exception_status);
 void vidc_1080p_frame_start_realloc(u32 instance_id);
+void vidc_1080p_set_enc_NV21(u32 enc_nv21);
+
 #endif
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc_hwio.h b/drivers/video/msm/vidc/1080p/ddl/vidc_hwio.h
index 657e4e1..d63a45b 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc_hwio.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc_hwio.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -16,16 +16,13 @@
 
 #include "vidc_hwio_reg.h"
 
-extern u32 vidc_msg_register;
-#define VIDC_REG_OUT(x...)          \
-    if (vidc_msg_register) {        \
-        printk(KERN_DEBUG x);       \
-    }
-
-#define VIDC_REG_IN(x...)           \
-    if (vidc_msg_register) {        \
-        printk(KERN_DEBUG x);       \
-    }
+#ifdef VIDC_REGISTER_LOG
+#define VIDC_REG_OUT(x...)  printk(KERN_DEBUG x)
+#define VIDC_REG_IN(x...)   printk(KERN_DEBUG x)
+#else
+#define VIDC_REG_OUT(x...)
+#define VIDC_REG_IN(x...)
+#endif
 
 #define __inpdw(port) __raw_readl(port)
 #define __outpdw(port, val) __raw_writel(val, port)
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc_hwio_reg.h b/drivers/video/msm/vidc/1080p/ddl/vidc_hwio_reg.h
index 819cd6c..50ab8a3 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc_hwio_reg.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc_hwio_reg.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010,2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -3603,6 +3603,22 @@
 #define HWIO_REG_515564_MSLICE_BIT_BMSK  0xffffffff
 #define HWIO_REG_515564_MSLICE_BIT_SHFT  0
 
+#define HWIO_REG_515664_ADDR  (VIDC_BLACKBIRD_REG_BASE + 0x0000c548)
+#define HWIO_REG_515664_PHYS  (VIDC_BLACKBIRD_REG_BASE_PHYS + 0x0000c548)
+#define HWIO_REG_515664_RMSK  0xffffffff
+#define HWIO_REG_515664_SHFT  0
+#define HWIO_REG_515664_IN    in_dword_masked(\
+	HWIO_REG_515664_ADDR, HWIO_REG_515664_RMSK)
+#define HWIO_REG_515664_INM(m)  in_dword_masked(\
+	HWIO_REG_515664_ADDR, m)
+#define HWIO_REG_515664_OUT(v)  out_dword(HWIO_REG_515664_ADDR, v)
+#define HWIO_REG_515664_OUTM(m, v)  out_dword_masked_ns(\
+	HWIO_REG_515664_ADDR, m, v, HWIO_REG_515664_IN);
+#define HWIO_REG_515664_NV21_SEL_BMSK   0xffffffff
+#define HWIO_REG_515664_NV21_SEL_SHFT   0
+
+
+
 #define HWIO_REG_886210_ADDR (VIDC_BLACKBIRD_REG_BASE + 0x0000c518)
 #define HWIO_REG_886210_PHYS (VIDC_BLACKBIRD_REG_BASE_PHYS + 0x0000c518)
 #define HWIO_REG_886210_RMSK  0xffff
@@ -3977,6 +3993,7 @@
 	HWIO_REG_437878_ADDR, HWIO_REG_437878_RMSK)
 #define HWIO_REG_437878_INM(m) \
 	in_dword_masked(HWIO_REG_437878_ADDR, m)
+
 #define HWIO_REG_437878_AXI_WDTIMEOUT_INTR_BMSK  0x3000
 #define HWIO_REG_437878_AXI_WDTIMEOUT_INTR_SHFT  0xc
 #define HWIO_REG_437878_AXI_ERR_INTR_BMSK        0x300
@@ -3986,6 +4003,23 @@
 #define HWIO_REG_437878_AXI_HALT_ACK_BMSK        0x3
 #define HWIO_REG_437878_AXI_HALT_ACK_SHFT        0
 
+#define HWIO_REG_437878_AXI_B_WDTIMEOUT_INTR_BMSK  0x2000
+#define HWIO_REG_437878_AXI_B_WDTIMEOUT_INTR_SHFT  0xd
+#define HWIO_REG_437878_AXI_A_WDTIMEOUT_INTR_BMSK  0x1000
+#define HWIO_REG_437878_AXI_A_WDTIMEOUT_INTR_SHFT  0xc
+#define HWIO_REG_437878_AXI_B_ERR_INTR_BMSK        0x200
+#define HWIO_REG_437878_AXI_B_ERR_INTR_SHFT        0x9
+#define HWIO_REG_437878_AXI_A_ERR_INTR_BMSK        0x100
+#define HWIO_REG_437878_AXI_A_ERR_INTR_SHFT        0x8
+#define HWIO_REG_437878_AXI_B_IDLE_BMSK            0x20
+#define HWIO_REG_437878_AXI_B_IDLE_SHFT            0x5
+#define HWIO_REG_437878_AXI_A_IDLE_BMSK            0x10
+#define HWIO_REG_437878_AXI_A_IDLE_SHFT            0x4
+#define HWIO_REG_437878_AXI_B_HALT_ACK_BMSK        0x2
+#define HWIO_REG_437878_AXI_B_HALT_ACK_SHFT        0x1
+#define HWIO_REG_437878_AXI_A_HALT_ACK_BMSK        0x1
+#define HWIO_REG_437878_AXI_A_HALT_ACK_SHFT        0
+
 #define HWIO_REG_736158_ADDR \
 	(VIDC_MGEN2MAXI_REG_BASE + 0x0000001c)
 #define HWIO_REG_736158_PHYS \
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c b/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c
index 6870525..cf62332 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,8 +15,6 @@
 #include "vidc_hwio.h"
 #include "vidc_pix_cache.h"
 
-
-#define VIDC_1080P_MAX_DEC_DPB 19
 #define VIDC_TILE_MULTIPLY_FACTOR 8192
 
 void vidc_pix_cache_sw_reset(void)
@@ -214,7 +212,7 @@ void vidc_pix_cache_set_ram(u32 ram_select)
 	VIDC_HWIO_IN(REG_261029, &dmi_cfg_reg);
 	dmi_cfg_reg &= (~HWIO_REG_261029_DMI_RAM_SEL_BMSK);
 	dmi_cfg_reg |= VIDC_SETFIELD(ram_select,
-			HWIO_REG_261029_AUTO_INC_EN_SHFT,
+			HWIO_REG_261029_DMI_RAM_SEL_SHFT,
 			HWIO_REG_261029_DMI_RAM_SEL_BMSK);
 	VIDC_HWIO_OUT(REG_261029, dmi_cfg_reg);
 }
diff --git a/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.h b/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.h
index e8a93a1..c70b113 100644
--- a/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.h
+++ b/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
index 7d6cb22..d6b4a0a 100644
--- a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
+++ b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -69,7 +69,7 @@ struct res_trk_vidc_mmu_clk {
 	if (res_trk_get_enable_ion() && addr->alloc_handle) {
 		kernel_vaddr = (unsigned long *) ion_map_kernel(
 					ddl_context->video_ion_client,
-					addr->alloc_handle, UNCACHED);
+					addr->alloc_handle);
 		if (IS_ERR_OR_NULL(kernel_vaddr)) {
 			DDL_MSG_ERROR("%s():DDL ION client map failed\n",
 						 __func__);
@@ -84,7 +84,7 @@ struct res_trk_vidc_mmu_clk {
 				0,
 				&iova,
 				&buffer_size,
-				UNCACHED, 0);
+				0, 0);
 		if (ret || !iova) {
 			DDL_MSG_ERROR(
 			"%s():DDL ION client iommu map failed, ret = %d iova = 0x%lx\n",
@@ -160,9 +160,15 @@ struct res_trk_vidc_mmu_clk {
 static void res_trk_pmem_free(struct ddl_buf_addr *addr)
 {
 	struct ddl_context *ddl_context;
+
+	if (!addr) {
+		DDL_MSG_ERROR("\n%s() NULL address", __func__);
+		return;
+	}
+
 	ddl_context = ddl_get_context();
 	if (ddl_context->video_ion_client) {
-		if (addr && addr->alloc_handle) {
+		if (addr->alloc_handle) {
 			ion_free(ddl_context->video_ion_client,
 			 addr->alloc_handle);
 			addr->alloc_handle = NULL;
@@ -209,7 +215,8 @@ static void res_trk_pmem_free(struct ddl_buf_addr *addr)
 			addr->alloc_handle = ion_alloc(
 					ddl_context->video_ion_client,
 					 alloc_size, SZ_4K,
-					res_trk_get_mem_type());
+					res_trk_get_mem_type(),
+					res_trk_get_ion_flags());
 			if (IS_ERR_OR_NULL(addr->alloc_handle)) {
 				DDL_MSG_ERROR("%s() :DDL ION alloc failed\n",
 						__func__);
@@ -376,7 +383,6 @@ static u32 res_trk_sel_clk_rate(unsigned long hclk_rate)
 	mutex_lock(&resource_context.lock);
 	if (clk_set_rate(resource_context.vcodec_clk,
 		hclk_rate)) {
-		VCDRES_MSG_ERROR("vidc hclk set rate failed\n");
 		status = false;
 	} else
 		resource_context.vcodec_clk_rate = hclk_rate;
@@ -521,12 +527,20 @@ u32 res_trk_power_down(void)
 
 u32 res_trk_get_max_perf_level(u32 *pn_max_perf_lvl)
 {
+	bool turbo_supported =
+		!resource_context.vidc_platform_data->disable_turbo;
+
 	if (!pn_max_perf_lvl) {
 		VCDRES_MSG_ERROR("%s(): pn_max_perf_lvl is NULL\n",
 			__func__);
 		return false;
 	}
-	*pn_max_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
+	if (turbo_supported)
+		*pn_max_perf_lvl = RESTRK_1080P_TURBO_PERF_LEVEL;
+	else
+		*pn_max_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
+	VCDRES_MSG_MED("%s: %u", __func__, (u32)*pn_max_perf_lvl);
+
 	return true;
 }
 
@@ -537,9 +551,8 @@ int res_trk_update_bus_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_level)
 	u32 enc_perf_level = 0, dec_perf_level = 0;
 	u32 bus_clk_index, client_type = 0;
 	int rc = 0;
-
-	if (dev_ctxt->turbo_mode_set)
-		return rc;
+	bool turbo_supported =
+		!resource_context.vidc_platform_data->disable_turbo;
 
 	cctxt_itr = dev_ctxt->cctxt_list_head;
 	while (cctxt_itr) {
@@ -563,16 +576,8 @@ int res_trk_update_bus_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_level)
 
 	if (dev_ctxt->reqd_perf_lvl + dev_ctxt->curr_perf_lvl == 0)
 		bus_clk_index = 2;
-	else if (resource_context.vidc_platform_data->disable_turbo
-						&& bus_clk_index == 3) {
-		VCDRES_MSG_ERROR("Warning: Turbo mode not supported "
-				" falling back to 1080p bus\n");
+	else if (!turbo_supported && bus_clk_index == 3)
 		bus_clk_index = 2;
-	}
-
-	if (bus_clk_index == 3)
-		dev_ctxt->turbo_mode_set = 1;
-
 	bus_clk_index = (bus_clk_index << 1) + (client_type + 1);
 	VCDRES_MSG_LOW("%s(), bus_clk_index = %d", __func__, bus_clk_index);
 	VCDRES_MSG_LOW("%s(),context.pcl = %x", __func__, resource_context.pcl);
@@ -587,36 +592,31 @@ u32 res_trk_set_perf_level(u32 req_perf_lvl, u32 *pn_set_perf_lvl,
 	struct vcd_dev_ctxt *dev_ctxt)
 {
 	u32 vidc_freq = 0;
+	bool turbo_supported =
+		!resource_context.vidc_platform_data->disable_turbo;
+
 	if (!pn_set_perf_lvl || !dev_ctxt) {
 		VCDRES_MSG_ERROR("%s(): NULL pointer! dev_ctxt(%p)\n",
 			__func__, dev_ctxt);
 		return false;
 	}
-	if (dev_ctxt->turbo_mode_set &&
-			(req_perf_lvl < RESTRK_1080P_TURBO_PERF_LEVEL)) {
-		VCDRES_MSG_MED("%s(): TURBO MODE!!\n", __func__);
-		return true;
-	}
 
 	VCDRES_MSG_LOW("%s(), req_perf_lvl = %d", __func__, req_perf_lvl);
 
-	if (resource_context.vidc_platform_data->disable_turbo
-			&& req_perf_lvl > RESTRK_1080P_MAX_PERF_LEVEL) {
+	if (!turbo_supported && req_perf_lvl > RESTRK_1080P_MAX_PERF_LEVEL) {
 		VCDRES_MSG_ERROR("%s(): Turbo not supported! dev_ctxt(%p)\n",
 			__func__, dev_ctxt);
 	}
 
-#ifdef CONFIG_MSM_BUS_SCALING
-	if (!res_trk_update_bus_perf_level(dev_ctxt, req_perf_lvl) < 0) {
-		VCDRES_MSG_ERROR("%s(): update buf perf level failed\n",
-			__func__);
-		return false;
+	if (dev_ctxt->reqd_perf_lvl + dev_ctxt->curr_perf_lvl == 0) {
+		if (turbo_supported)
+			req_perf_lvl = RESTRK_1080P_TURBO_PERF_LEVEL;
+		else
+			req_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
+		VCDRES_MSG_MED("Set initial perf level to %u",
+			req_perf_lvl);
 	}
 
-#endif
-	if (dev_ctxt->reqd_perf_lvl + dev_ctxt->curr_perf_lvl == 0)
-		req_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
-
 	if (req_perf_lvl <= RESTRK_1080P_VGA_PERF_LEVEL) {
 		vidc_freq = vidc_clk_table[0];
 		*pn_set_perf_lvl = RESTRK_1080P_VGA_PERF_LEVEL;
@@ -630,24 +630,31 @@ u32 res_trk_set_perf_level(u32 req_perf_lvl, u32 *pn_set_perf_lvl,
 		vidc_freq = vidc_clk_table[4];
 		*pn_set_perf_lvl = RESTRK_1080P_TURBO_PERF_LEVEL;
 	}
-
-	if (resource_context.vidc_platform_data->disable_turbo &&
-		*pn_set_perf_lvl == RESTRK_1080P_TURBO_PERF_LEVEL) {
-		VCDRES_MSG_ERROR("Warning: Turbo mode not supported "
-				" falling back to 1080p clocks\n");
+	if (!turbo_supported &&
+		 *pn_set_perf_lvl == RESTRK_1080P_TURBO_PERF_LEVEL) {
 		vidc_freq = vidc_clk_table[2];
 		*pn_set_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
 	}
 
 	resource_context.perf_level = *pn_set_perf_lvl;
-	VCDRES_MSG_MED("VIDC: vidc_freq = %u, req_perf_lvl = %u\n",
-		vidc_freq, req_perf_lvl);
+	VCDRES_MSG_HIGH("VIDC: vidc_freq = %u, req_perf_lvl = %u, "\
+		"set_perf_lvl = %u\n", vidc_freq, req_perf_lvl,
+		(u32)*pn_set_perf_lvl);
+#ifdef CONFIG_MSM_BUS_SCALING
+	if (!res_trk_update_bus_perf_level(dev_ctxt, req_perf_lvl) < 0) {
+		VCDRES_MSG_ERROR("%s(): update buf perf level failed\n",
+			__func__);
+		return false;
+	}
+#endif
 #ifdef USE_RES_TRACKER
     if (req_perf_lvl != RESTRK_1080P_MIN_PERF_LEVEL) {
 		VCDRES_MSG_MED("%s(): Setting vidc freq to %u\n",
 			__func__, vidc_freq);
 		if (!res_trk_sel_clk_rate(vidc_freq)) {
 			if (vidc_freq == vidc_clk_table[4]) {
+				VCDRES_MSG_MED("%s(): Setting vidc freq "\
+					"to %u\n", __func__, (u32)vidc_clk_table[3]);
 				if (res_trk_sel_clk_rate(vidc_clk_table[3]))
 					goto ret;
 			}
@@ -746,6 +753,9 @@ void res_trk_init(struct device *device, u32 irq)
 			resource_context.vidc_platform_data->disable_dmx;
 			resource_context.disable_fullhd =
 			resource_context.vidc_platform_data->disable_fullhd;
+			resource_context.enable_sec_metadata =
+			resource_context.vidc_platform_data->
+				enable_sec_metadata;
 #ifdef CONFIG_MSM_BUS_SCALING
 			resource_context.vidc_bus_client_pdata =
 			resource_context.vidc_platform_data->
@@ -840,17 +850,31 @@ int res_trk_get_mem_type(void)
 	if (resource_context.vidc_platform_data->enable_ion) {
 		if (res_trk_check_for_sec_session()) {
 			mem_type = ION_HEAP(mem_type);
-	if (resource_context.res_mem_type != DDL_FW_MEM)
-		mem_type |= ION_SECURE;
-	else if (res_trk_is_cp_enabled())
-		mem_type |= ION_SECURE;
 	} else
 		mem_type = (ION_HEAP(mem_type) |
 			ION_HEAP(ION_IOMMU_HEAP_ID));
 	}
+
 	return mem_type;
 }
 
+unsigned int res_trk_get_ion_flags(void)
+{
+	unsigned int flags = 0;
+	if (resource_context.res_mem_type == DDL_FW_MEM)
+		return flags;
+
+	if (resource_context.vidc_platform_data->enable_ion) {
+		if (res_trk_check_for_sec_session()) {
+			if (resource_context.res_mem_type != DDL_FW_MEM)
+				flags |= ION_SECURE;
+			else if (res_trk_is_cp_enabled())
+				flags |= ION_SECURE;
+		}
+	}
+	return flags;
+}
+
 u32 res_trk_is_cp_enabled(void)
 {
 	if (resource_context.vidc_platform_data->cp_enabled)
@@ -890,6 +914,10 @@ u32 res_trk_get_disable_fullhd(void)
 {
 	return resource_context.disable_fullhd;
 }
+u32 res_trk_get_enable_sec_metadata(void)
+{
+	return resource_context.enable_sec_metadata;
+}
 
 int res_trk_enable_iommu_clocks(void)
 {
@@ -1001,9 +1029,9 @@ int res_trk_open_secure_session()
 	mutex_unlock(&resource_context.secure_lock);
 	return 0;
 unsecure_cmd_heap:
-	msm_ion_unsecure_heap(ION_HEAP(resource_context.memtype));
-unsecure_memtype_heap:
 	msm_ion_unsecure_heap(ION_HEAP(resource_context.cmd_mem_type));
+unsecure_memtype_heap:
+	msm_ion_unsecure_heap(ION_HEAP(resource_context.memtype));
 disable_iommu_clks:
 	res_trk_disable_iommu_clocks();
 error_open:
@@ -1060,18 +1088,28 @@ u32 get_res_trk_perf_level(enum vcd_perf_level perf_level)
 		VCD_MSG_ERROR("Invalid perf level: %d\n", perf_level);
 		res_trk_perf_level = -EINVAL;
 	}
+	VCDRES_MSG_MED("%s: res_trk_perf_level = %u", __func__,
+		res_trk_perf_level);
 	return res_trk_perf_level;
 }
 
 u32 res_trk_estimate_perf_level(u32 pn_perf_lvl)
 {
-	VCDRES_MSG_MED("%s(), req_perf_lvl = %d", __func__, pn_perf_lvl);
+	bool turbo_supported =
+		!resource_context.vidc_platform_data->disable_turbo;
+
+	VCDRES_MSG_MED("%s(): pn_perf_lvl = %d, turbo support = %d",
+		__func__, pn_perf_lvl, turbo_supported);
 	if ((pn_perf_lvl >= RESTRK_1080P_VGA_PERF_LEVEL) &&
 		(pn_perf_lvl < RESTRK_1080P_720P_PERF_LEVEL)) {
 		return RESTRK_1080P_720P_PERF_LEVEL;
 	} else if ((pn_perf_lvl >= RESTRK_1080P_720P_PERF_LEVEL) &&
 			(pn_perf_lvl < RESTRK_1080P_MAX_PERF_LEVEL)) {
 		return RESTRK_1080P_MAX_PERF_LEVEL;
+	} else if ((pn_perf_lvl >= RESTRK_1080P_MAX_PERF_LEVEL) &&
+			(pn_perf_lvl < RESTRK_1080P_TURBO_PERF_LEVEL) &&
+			turbo_supported) {
+		return RESTRK_1080P_TURBO_PERF_LEVEL;
 	} else {
 		return pn_perf_lvl;
 	}
diff --git a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h
index 6ecb340..9ba99e1 100644
--- a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h
+++ b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -14,7 +14,7 @@
 #define _VIDEO_720P_RESOURCE_TRACKER_H_
 
 #include <linux/regulator/consumer.h>
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include "vcd_res_tracker_api.h"
 #ifdef CONFIG_MSM_BUS_SCALING
 #include <mach/msm_bus.h>
@@ -53,6 +53,7 @@ struct res_trk_context {
 	struct ion_client *res_ion_client;
 	u32 disable_dmx;
 	u32 disable_fullhd;
+	u32 enable_sec_metadata;
 	enum ddl_mem_area res_mem_type;
 	u32 mmu_clks_on;
 	u32 secure_session;
@@ -60,20 +61,22 @@ struct res_trk_context {
 	u32 sec_clk_heap;
 };
 
-extern u32 vidc_msg_debug;
+#if DEBUG
 
-#define VCDRES_MSG_LOW(xx_fmt...)			\
-	if (vidc_msg_debug) {				\
-		printk(KERN_INFO "\n\t* [VID] " xx_fmt);\
-	}
-#define VCDRES_MSG_MED(xx_fmt...)			\
-	if (vidc_msg_debug) {				\
-		printk(KERN_INFO "\n  * [VID] " xx_fmt);\
-	}
+#define VCDRES_MSG_LOW(xx_fmt...)	printk(KERN_INFO "\n\t* " xx_fmt)
+#define VCDRES_MSG_MED(xx_fmt...)	printk(KERN_INFO "\n  * " xx_fmt)
 
-#define VCDRES_MSG_HIGH(xx_fmt...)	printk(KERN_WARNING "\n [VID] " xx_fmt)
-#define VCDRES_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n [VID] err: " xx_fmt)
-#define VCDRES_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n [VID] <FATAL> " xx_fmt)
+#else
+
+#define VCDRES_MSG_LOW(xx_fmt...)
+#define VCDRES_MSG_MED(xx_fmt...)
+
+#endif
+
+#define VCDRES_MSG_HIGH(xx_fmt...)	printk(KERN_WARNING "\n" xx_fmt)
+#define VCDRES_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n err: " xx_fmt)
+#define VCDRES_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n<FATAL> " xx_fmt)
+#define VCDRES_MSG_INFO(xx_fmt...)	printk(KERN_INFO "\n  * " xx_fmt)
 
 #ifdef CONFIG_MSM_BUS_SCALING
 int res_trk_update_bus_perf_level(struct vcd_dev_ctxt *dev_ctxt,
diff --git a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h
index 2ae2512..15ffa96 100644
--- a/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h
+++ b/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -30,9 +30,11 @@ u32 res_trk_set_perf_level(u32 req_perf_lvl, u32 *pn_set_perf_lvl,
 u32 res_trk_get_core_type(void);
 u32 res_trk_get_firmware_addr(struct ddl_buf_addr *firm_addr);
 int res_trk_get_mem_type(void);
+unsigned int res_trk_get_ion_flags(void);
 u32 res_trk_get_enable_ion(void);
 u32 res_trk_is_cp_enabled(void);
 u32 res_trk_get_disable_fullhd(void);
+u32 res_trk_get_enable_sec_metadata(void);
 struct ion_client *res_trk_get_ion_client(void);
 u32 res_trk_get_disable_dmx(void);
 u32 res_trk_get_min_dpb_count(void);
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl.c
new file mode 100644
index 0000000..9b27abd
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl.c
@@ -0,0 +1,637 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_metadata.h"
+#include "vcd_res_tracker_api.h"
+
+u32 ddl_device_init(struct ddl_init_config *ddl_init_config,
+		    void *client_data)
+{
+	struct ddl_context *ddl_context;
+	u32 status = VCD_S_SUCCESS;
+
+	if ((!ddl_init_config) ||
+	    (!ddl_init_config->ddl_callback) ||
+	    (!ddl_init_config->core_virtual_base_addr)
+	    ) {
+		VIDC_LOGERR_STRING("ddl_dev_init:Bad_argument");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+
+	ddl_context = ddl_get_context();
+
+	if (DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dev_init:Multiple_init");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dev_init:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+
+	DDL_MEMSET(ddl_context, 0, sizeof(struct ddl_context));
+	DDL_BUSY(ddl_context);
+
+	if (res_trk_get_enable_ion()) {
+		VIDC_LOGERR_STRING("ddl_dev_init: ION framework enabled");
+		ddl_context->video_ion_client  =
+			res_trk_get_ion_client();
+		if (!ddl_context->video_ion_client) {
+			VIDC_LOGERR_STRING("ION client create failed");
+			return VCD_ERR_ILLEGAL_OP;
+		}
+	}
+	ddl_context->memtype = res_trk_get_mem_type();
+	if (ddl_context->memtype == -1) {
+		VIDC_LOGERR_STRING("ddl_dev_init:Invalid Memtype");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+	ddl_context->ddl_callback = ddl_init_config->ddl_callback;
+	ddl_context->interrupt_clr = ddl_init_config->interrupt_clr;
+	ddl_context->core_virtual_base_addr =
+	    ddl_init_config->core_virtual_base_addr;
+	ddl_context->client_data = client_data;
+
+	vidc_720p_set_device_virtual_base(ddl_context->
+					   core_virtual_base_addr);
+
+	ddl_context->current_ddl = NULL;
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	ddl_client_transact(DDL_INIT_CLIENTS, NULL);
+
+	ddl_pmem_alloc(&ddl_context->context_buf_addr,
+		       DDL_CONTEXT_MEMORY, DDL_LINEAR_BUFFER_ALIGN_BYTES);
+	if (!ddl_context->context_buf_addr.virtual_base_addr) {
+		VIDC_LOGERR_STRING("ddl_dev_init:Context_alloc_fail");
+		status = VCD_ERR_ALLOC_FAIL;
+	}
+	if (!status) {
+		ddl_pmem_alloc(&ddl_context->db_line_buffer,
+			       DDL_DB_LINE_BUF_SIZE,
+			       DDL_TILE_BUFFER_ALIGN_BYTES);
+		if (!ddl_context->db_line_buffer.virtual_base_addr) {
+			VIDC_LOGERR_STRING("ddl_dev_init:Line_buf_alloc_fail");
+			status = VCD_ERR_ALLOC_FAIL;
+		}
+	}
+
+	if (!status) {
+		ddl_pmem_alloc(&ddl_context->data_partition_tempbuf,
+					   DDL_MPEG4_DATA_PARTITION_BUF_SIZE,
+					   DDL_TILE_BUFFER_ALIGN_BYTES);
+		if (ddl_context->data_partition_tempbuf.virtual_base_addr \
+			== NULL) {
+			VIDC_LOGERR_STRING
+				("ddl_dev_init:Data_partition_buf_alloc_fail");
+			status = VCD_ERR_ALLOC_FAIL;
+		}
+   }
+
+   if (!status) {
+
+		ddl_pmem_alloc(&ddl_context->metadata_shared_input,
+					   DDL_METADATA_TOTAL_INPUTBUFSIZE,
+					   DDL_LINEAR_BUFFER_ALIGN_BYTES);
+		if (!ddl_context->metadata_shared_input.virtual_base_addr) {
+			VIDC_LOGERR_STRING
+			("ddl_dev_init:metadata_shared_input_alloc_fail");
+			status = VCD_ERR_ALLOC_FAIL;
+		}
+	 }
+
+	if (!status) {
+		ddl_pmem_alloc(&ddl_context->dbg_core_dump, \
+					   DDL_DBG_CORE_DUMP_SIZE,  \
+					   DDL_LINEAR_BUFFER_ALIGN_BYTES);
+		if (!ddl_context->dbg_core_dump.virtual_base_addr) {
+			VIDC_LOGERR_STRING
+				("ddl_dev_init:dbg_core_dump_alloc_failed");
+			status = VCD_ERR_ALLOC_FAIL;
+		}
+		ddl_context->enable_dbg_core_dump = 0;
+	}
+
+	if (!status && !vcd_fw_init()) {
+		VIDC_LOGERR_STRING("ddl_dev_init:fw_init_failed");
+		status = VCD_ERR_ALLOC_FAIL;
+	}
+	if (status) {
+		ddl_release_context_buffers(ddl_context);
+		DDL_IDLE(ddl_context);
+		return status;
+	}
+
+	ddl_move_command_state(ddl_context, DDL_CMD_DMA_INIT);
+
+	ddl_core_init(ddl_context);
+
+	return status;
+}
+
+u32 ddl_device_release(void *client_data)
+{
+	struct ddl_context *ddl_context;
+
+	ddl_context = ddl_get_context();
+
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dev_rel:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dev_rel:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	if (!ddl_client_transact(DDL_ACTIVE_CLIENT, NULL)) {
+		VIDC_LOGERR_STRING("ddl_dev_rel:Client_present_err");
+		return VCD_ERR_CLIENT_PRESENT;
+	}
+	DDL_BUSY(ddl_context);
+
+	ddl_context->device_state = DDL_DEVICE_NOTINIT;
+	ddl_context->client_data = client_data;
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	vidc_720p_stop_fw();
+
+	VIDC_LOG_STRING("FW_ENDDONE");
+	ddl_release_context_buffers(ddl_context);
+	ddl_context->video_ion_client = NULL;
+	DDL_IDLE(ddl_context);
+
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_open(u32 **ddl_handle, u32 decoding)
+{
+	struct ddl_context *ddl_context;
+	struct ddl_client_context *ddl;
+	u32 status;
+
+	if (!ddl_handle) {
+		VIDC_LOGERR_STRING("ddl_open:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+
+	ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_open:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	status = ddl_client_transact(DDL_GET_CLIENT, &ddl);
+
+	if (status) {
+		VIDC_LOGERR_STRING("ddl_open:Client_trasac_failed");
+		return status;
+	}
+
+	ddl_move_client_state(ddl, DDL_CLIENT_OPEN);
+
+	ddl->codec_data.hdr.decoding = decoding;
+	ddl->decoding = decoding;
+
+	ddl_set_default_meta_data_hdr(ddl);
+
+	ddl_set_initial_default_values(ddl);
+
+	*ddl_handle = (u32 *) ddl;
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_close(u32 **ddl_handle)
+{
+	struct ddl_context *ddl_context;
+	struct ddl_client_context **ddl =
+	    (struct ddl_client_context **)ddl_handle;
+
+	if (!ddl || !*ddl) {
+		VIDC_LOGERR_STRING("ddl_close:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+
+	ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_close:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	if (!DDLCLIENT_STATE_IS(*ddl, DDL_CLIENT_OPEN)) {
+		VIDC_LOGERR_STRING("ddl_close:Not_in_open_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	ddl_move_client_state(*ddl, DDL_CLIENT_INVALID);
+	if ((*ddl)->decoding) {
+		vcd_fw_transact(false, true,
+			(*ddl)->codec_data.decoder.codec.codec);
+	} else {
+		vcd_fw_transact(false, false,
+			(*ddl)->codec_data.encoder.codec.codec);
+	}
+	ddl_client_transact(DDL_FREE_CLIENT, ddl);
+
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_encode_start(u32 *ddl_handle, void *client_data)
+{
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context;
+	struct ddl_encoder_data *encoder;
+	u32 dpb_size;
+
+	ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Not_opened");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	if (!ddl_encoder_ready_to_start(ddl)) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Err_param_settings");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	encoder = &ddl->codec_data.encoder;
+
+	dpb_size = ddl_get_yuv_buffer_size(&encoder->frame_size,
+					&encoder->re_con_buf_format, false,
+					encoder->codec.codec);
+
+	dpb_size *= DDL_ENC_NUM_DPB_BUFFERS;
+	ddl_pmem_alloc(&encoder->enc_dpb_addr,
+		       dpb_size, DDL_TILE_BUFFER_ALIGN_BYTES);
+	if (!encoder->enc_dpb_addr.virtual_base_addr) {
+		VIDC_LOGERR_STRING("ddl_enc_start:Dpb_alloc_failed");
+		return VCD_ERR_ALLOC_FAIL;
+	}
+
+	if ((encoder->codec.codec == VCD_CODEC_MPEG4 &&
+	     !encoder->short_header.short_header) ||
+	    encoder->codec.codec == VCD_CODEC_H264) {
+		ddl_pmem_alloc(&encoder->seq_header,
+			       DDL_ENC_SEQHEADER_SIZE,
+			       DDL_LINEAR_BUFFER_ALIGN_BYTES);
+		if (!encoder->seq_header.virtual_base_addr) {
+			ddl_pmem_free(&encoder->enc_dpb_addr);
+			VIDC_LOGERR_STRING
+			    ("ddl_enc_start:Seq_hdr_alloc_failed");
+			return VCD_ERR_ALLOC_FAIL;
+		}
+	} else {
+		encoder->seq_header.buffer_size = 0;
+		encoder->seq_header.virtual_base_addr = 0;
+	}
+
+	DDL_BUSY(ddl_context);
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+	ddl_channel_set(ddl);
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_decode_start(u32 *ddl_handle,
+     struct vcd_sequence_hdr *header, void *client_data)
+{
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context;
+	struct ddl_decoder_data *decoder;
+
+	ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || !ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Not_in_opened_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	if ((header) &&
+	    ((!header->sequence_header_len) ||
+	     (!header->sequence_header)
+	    )
+	    ) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Bad_param_seq_header");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+
+	if (!ddl_decoder_ready_to_start(ddl, header)) {
+		VIDC_LOGERR_STRING("ddl_dec_start:Err_param_settings");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	DDL_BUSY(ddl_context);
+
+	decoder = &ddl->codec_data.decoder;
+	if (header) {
+		decoder->header_in_start = true;
+		decoder->decode_config = *header;
+	} else {
+		decoder->header_in_start = false;
+		decoder->decode_config.sequence_header_len = 0;
+	}
+
+	if (decoder->codec.codec == VCD_CODEC_H264) {
+		ddl_pmem_alloc(&decoder->h264Vsp_temp_buffer,
+			       DDL_DECODE_H264_VSPTEMP_BUFSIZE,
+			       DDL_LINEAR_BUFFER_ALIGN_BYTES);
+		if (!decoder->h264Vsp_temp_buffer.virtual_base_addr) {
+			DDL_IDLE(ddl_context);
+			VIDC_LOGERR_STRING
+			    ("ddl_dec_start:H264Sps_alloc_failed");
+			return VCD_ERR_ALLOC_FAIL;
+		}
+	}
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+
+	ddl_channel_set(ddl);
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_decode_frame(u32 *ddl_handle,
+     struct ddl_frame_data_tag *input_bits, void *client_data)
+{
+	u32 vcd_status = VCD_S_SUCCESS;
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_frame:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_frame:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || !ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_dec_frame:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (!input_bits ||
+	    ((!input_bits->vcd_frm.physical ||
+	      !input_bits->vcd_frm.data_len) &&
+	     (!(VCD_FRAME_FLAG_EOS & input_bits->vcd_frm.flags))
+	    )
+	    ) {
+		VIDC_LOGERR_STRING("ddl_dec_frame:Bad_input_param");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+
+	DDL_BUSY(ddl_context);
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+
+	ddl->input_frame = *input_bits;
+
+	if (DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME)) {
+		ddl_decode_frame_run(ddl);
+	} else {
+		if (!ddl->codec_data.decoder.dp_buf.no_of_dec_pic_buf) {
+			VIDC_LOGERR_STRING("ddl_dec_frame:Dpbs_requied");
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+		} else if (DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_DPB)) {
+			vcd_status = ddl_decode_set_buffers(ddl);
+		} else
+		    if (DDLCLIENT_STATE_IS
+			(ddl, DDL_CLIENT_WAIT_FOR_INITCODEC)) {
+			ddl->codec_data.decoder.decode_config.
+			    sequence_header =
+			    ddl->input_frame.vcd_frm.physical;
+			ddl->codec_data.decoder.decode_config.
+			    sequence_header_len =
+			    ddl->input_frame.vcd_frm.data_len;
+			ddl_decode_init_codec(ddl);
+		} else {
+			VIDC_LOGERR_STRING("Dec_frame:Wrong_state");
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+		}
+		if (vcd_status)
+			DDL_IDLE(ddl_context);
+	}
+	return vcd_status;
+}
+
+u32 ddl_encode_frame(u32 *ddl_handle,
+     struct ddl_frame_data_tag *input_frame,
+     struct ddl_frame_data_tag *output_bit, void *client_data)
+{
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context = ddl_get_context();
+
+	if (vidc_msg_timing)
+		ddl_set_core_start_time(__func__, ENC_OP_TIME);
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (!input_frame ||
+	    !input_frame->vcd_frm.physical ||
+	    !input_frame->vcd_frm.data_len) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Bad_input_params");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+	if ((((u32) input_frame->vcd_frm.physical +
+		   input_frame->vcd_frm.offset) &
+		  (DDL_STREAMBUF_ALIGN_GUARD_BYTES)
+	    )
+	    ) {
+		VIDC_LOGERR_STRING
+		    ("ddl_enc_frame:Un_aligned_yuv_start_address");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+	if (!output_bit ||
+	    !output_bit->vcd_frm.physical ||
+	    !output_bit->vcd_frm.alloc_len) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Bad_output_params");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+	if ((ddl->codec_data.encoder.output_buf_req.sz +
+	     output_bit->vcd_frm.offset) >
+	    output_bit->vcd_frm.alloc_len) {
+		VIDC_LOGERR_STRING
+		    ("ddl_enc_frame:offset_large, Exceeds_min_buf_size");
+	}
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME)) {
+		VIDC_LOGERR_STRING("ddl_enc_frame:Wrong_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	DDL_BUSY(ddl_context);
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+
+	ddl->input_frame = *input_frame;
+	ddl->output_frame = *output_bit;
+
+	ddl_encode_frame_run(ddl);
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_decode_end(u32 *ddl_handle, void *client_data)
+{
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context;
+
+	ddl_context = ddl_get_context();
+
+	if (vidc_msg_timing) {
+		ddl_reset_core_time_variables(DEC_OP_TIME);
+		ddl_reset_core_time_variables(DEC_IP_TIME);
+	}
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_end:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_dec_end:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || !ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_dec_end:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME) &&
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_INITCODEC) &&
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_DPB) &&
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_FATAL_ERROR)
+	    ) {
+		VIDC_LOGERR_STRING("ddl_dec_end:Wrong_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	DDL_BUSY(ddl_context);
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+
+	ddl_channel_end(ddl);
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_encode_end(u32 *ddl_handle, void *client_data)
+{
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+	struct ddl_context *ddl_context;
+
+	ddl_context = ddl_get_context();
+
+	if (vidc_msg_timing)
+		ddl_reset_core_time_variables(ENC_OP_TIME);
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_end:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	if (DDL_IS_BUSY(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_enc_end:Ddl_busy");
+		return VCD_ERR_BUSY;
+	}
+	if (!ddl || ddl->decoding) {
+		VIDC_LOGERR_STRING("ddl_enc_end:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME) &&
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_INITCODEC) &&
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_FATAL_ERROR)) {
+		VIDC_LOGERR_STRING("ddl_enc_end:Wrong_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+	DDL_BUSY(ddl_context);
+
+	ddl_context->current_ddl = ddl;
+	ddl_context->client_data = client_data;
+
+	ddl_channel_end(ddl);
+	return VCD_S_SUCCESS;
+}
+
+u32 ddl_reset_hw(u32 mode)
+{
+	struct ddl_context *ddl_context;
+	struct ddl_client_context *ddl;
+	int i_client_num;
+
+	VIDC_LOG_STRING("ddl_reset_hw:called");
+	ddl_context = ddl_get_context();
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	DDL_BUSY(ddl_context);
+
+	if (ddl_context->core_virtual_base_addr)
+		vidc_720p_do_sw_reset();
+
+	ddl_context->device_state = DDL_DEVICE_NOTINIT;
+	for (i_client_num = 0; i_client_num < VCD_MAX_NO_CLIENT;
+			++i_client_num) {
+		ddl = ddl_context->ddl_clients[i_client_num];
+		ddl_context->ddl_clients[i_client_num] = NULL;
+		if (ddl) {
+			ddl_release_client_internal_buffers(ddl);
+			ddl_client_transact(DDL_FREE_CLIENT, &ddl);
+		}
+	}
+
+	ddl_release_context_buffers(ddl_context);
+	DDL_MEMSET(ddl_context, 0, sizeof(struct ddl_context));
+
+	return true;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl.h
new file mode 100644
index 0000000..7a79a40
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl.h
@@ -0,0 +1,294 @@
+/* Copyright (c) 2010-2012 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_H_
+#define _VCD_DDL_H_
+#include <mach/msm_subsystem_map.h>
+#include "vcd_ddl_api.h"
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_firmware.h"
+#include "vidc.h"
+
+#undef DDL_INLINE
+#define DDL_INLINE
+
+#define DDL_BUSY_STATE 1
+#define DDL_IDLE_STATE 0
+#define DDL_ERROR_STATE 2
+#define DDL_IS_BUSY(ddl_context) \
+	(((ddl_context)->ddl_busy != DDL_IDLE_STATE))
+#define DDL_BUSY(ddl_context) \
+	((ddl_context)->ddl_busy = DDL_BUSY_STATE)
+#define DDL_IDLE(ddl_context) \
+	((ddl_context)->ddl_busy = DDL_IDLE_STATE)
+#define DDL_ERROR(ddl_context) \
+	((ddl_context)->ddl_busy = DDL_ERROR_STATE)
+
+#define DDL_DEVICE_NOTINIT  0
+#define DDL_DEVICE_INITED   1
+#define DDL_DEVICE_HWFATAL  2
+#define DDL_IS_INITIALIZED(ddl_context)  \
+(ddl_context->device_state == DDL_DEVICE_INITED)
+
+#define DDLCOMMAND_STATE_IS(ddl_context, command_state) \
+(command_state == (ddl_context)->cmd_state)
+
+#define DDLCLIENT_STATE_IS(ddl, current_state) \
+(current_state == (ddl)->client_state)
+
+#define DDL_DPB_OP_INIT       1
+#define DDL_DPB_OP_MARK_FREE  2
+#define DDL_DPB_OP_MARK_BUSY  3
+#define DDL_DPB_OP_SET_MASK   4
+#define DDL_DPB_OP_RETRIEVE   5
+
+#define DDL_INIT_CLIENTS     0
+#define DDL_GET_CLIENT       1
+#define DDL_FREE_CLIENT      2
+#define DDL_ACTIVE_CLIENT    3
+
+#define DDL_INVALID_CHANNEL_ID  ((u32)~0)
+#define DDL_INVALID_CODEC_TYPE ((u32)~0)
+
+#define DDL_ENC_REQ_IFRAME                      0x01
+#define DDL_ENC_CHANGE_IPERIOD                  0x02
+#define DDL_ENC_CHANGE_BITRATE                  0x04
+#define DDL_ENC_CHANGE_FRAMERATE                0x08
+#define DDL_ENC_CHANGE_CIR                      0x10
+
+#define DDL_DEC_REQ_OUTPUT_FLUSH                0x1
+
+enum ddl_mem_area {
+	DDL_MM_MEM	= 0x0
+};
+
+struct ddl_buf_addr {
+	u32 *physical_base_addr;
+	u32 *virtual_base_addr;
+	u32 *align_physical_addr;
+	u32 *align_virtual_addr;
+	struct msm_mapped_buffer *mapped_buffer;
+	struct ion_handle *alloc_handle;
+	u32 buffer_size;
+	enum ddl_mem_area mem_type;
+};
+
+enum ddl_cmd_state {
+	DDL_CMD_INVALID = 0x0,
+	DDL_CMD_DMA_INIT = 0x1,
+	DDL_CMD_CPU_RESET = 0x2,
+	DDL_CMD_CHANNEL_SET = 0x3,
+	DDL_CMD_INIT_CODEC = 0x4,
+	DDL_CMD_HEADER_PARSE = 0x5,
+	DDL_CMD_DECODE_SET_DPB = 0x6,
+	DDL_CMD_DECODE_FRAME = 0x7,
+	DDL_CMD_ENCODE_FRAME = 0x8,
+	DDL_CMD_EOS = 0x9,
+	DDL_CMD_CHANNEL_END = 0xA,
+	DDL_CMD_32BIT = 0x7FFFFFFF
+};
+
+enum ddl_client_state {
+	DDL_CLIENT_INVALID = 0x0,
+	DDL_CLIENT_OPEN = 0x1,
+	DDL_CLIENT_WAIT_FOR_CHDONE = 0x2,
+	DDL_CLIENT_WAIT_FOR_INITCODEC = 0x3,
+	DDL_CLIENT_WAIT_FOR_INITCODECDONE = 0x4,
+	DDL_CLIENT_WAIT_FOR_DPB = 0x5,
+	DDL_CLIENT_WAIT_FOR_DPBDONE = 0x6,
+	DDL_CLIENT_WAIT_FOR_FRAME = 0x7,
+	DDL_CLIENT_WAIT_FOR_FRAME_DONE = 0x8,
+	DDL_CLIENT_WAIT_FOR_EOS_DONE = 0x9,
+	DDL_CLIENT_WAIT_FOR_CHEND = 0xA,
+	DDL_CLIENT_FATAL_ERROR = 0xB,
+	DDL_CLIENT_32BIT = 0x7FFFFFFF
+};
+
+struct ddl_mask {
+	u32 client_mask;
+	u32 hw_mask;
+};
+
+struct ddl_context;
+
+struct ddl_client_context;
+
+struct ddl_codec_data_hdr {
+	u32 decoding;
+};
+
+struct ddl_encoder_data {
+	struct ddl_codec_data_hdr hdr;
+	struct vcd_property_codec codec;
+	struct vcd_property_frame_size frame_size;
+	struct vcd_property_frame_rate frame_rate;
+	struct vcd_property_target_bitrate target_bit_rate;
+	struct vcd_property_profile profile;
+	struct vcd_property_level level;
+	struct vcd_property_rate_control rc;
+	struct vcd_property_multi_slice multi_slice;
+	u32 meta_data_enable_flag;
+	u32 suffix;
+	struct ddl_buf_addr meta_data_input;
+	u32 meta_data_offset;
+	struct vcd_property_short_header short_header;
+	struct vcd_property_vop_timing vop_timing;
+	u32 hdr_ext_control;
+	struct vcd_property_db_config db_control;
+	struct vcd_property_entropy_control entropy_control;
+	struct vcd_property_i_period i_period;
+	struct vcd_property_session_qp session_qp;
+	struct vcd_property_qp_range qp_range;
+	struct vcd_property_rc_level rc_level;
+	u32 r_cframe_skip;
+	u32 vb_vbuffer_size;
+	struct vcd_property_frame_level_rc_params frame_level_rc;
+	struct vcd_property_adaptive_rc_params adaptive_rc;
+	struct vcd_property_intra_refresh_mb_number intra_refresh;
+	struct vcd_property_buffer_format buf_format;
+	struct vcd_property_buffer_format re_con_buf_format;
+	u32 dynamic_prop_change;
+	u32 dynmic_prop_change_req;
+	u32 ext_enc_control_val;
+	struct vidc_720p_enc_frame_info enc_frame_info;
+	struct ddl_buf_addr enc_dpb_addr;
+	struct ddl_buf_addr seq_header;
+	struct vcd_buffer_requirement input_buf_req;
+	struct vcd_buffer_requirement output_buf_req;
+	struct vcd_buffer_requirement client_input_buf_req;
+	struct vcd_buffer_requirement client_output_buf_req;
+};
+
+struct ddl_decoder_data {
+	struct ddl_codec_data_hdr hdr;
+	struct vcd_property_codec codec;
+	struct vcd_property_buffer_format buf_format;
+	struct vcd_property_frame_size frame_size;
+	struct vcd_property_frame_size client_frame_size;
+	struct vcd_property_profile profile;
+	struct vcd_property_level level;
+	u32 progressive_only;
+	u32 output_order;
+	u32 meta_data_enable_flag;
+	u32 suffix;
+	struct ddl_buf_addr meta_data_input;
+	struct ddl_buf_addr ref_buffer;
+	u32 meta_data_offset;
+	struct vcd_property_post_filter post_filter;
+	struct vcd_sequence_hdr decode_config;
+	u32 header_in_start;
+	u32 min_dpb_num;
+	u32 y_cb_cr_size;
+	struct ddl_property_dec_pic_buffers dp_buf;
+	struct ddl_mask dpb_mask;
+	u32 dynamic_prop_change;
+	u32 dynmic_prop_change_req;
+	struct vidc_720p_dec_disp_info dec_disp_info;
+	struct ddl_buf_addr dpb_comv_buffer;
+	struct ddl_buf_addr h264Vsp_temp_buffer;
+	struct vcd_buffer_requirement actual_input_buf_req;
+	struct vcd_buffer_requirement min_input_buf_req;
+	struct vcd_buffer_requirement client_input_buf_req;
+	struct vcd_buffer_requirement actual_output_buf_req;
+	struct vcd_buffer_requirement min_output_buf_req;
+	struct vcd_buffer_requirement client_output_buf_req;
+	u32 idr_only_decoding;
+};
+
+union ddl_codec_data {
+	struct ddl_codec_data_hdr hdr;
+	struct ddl_decoder_data decoder;
+	struct ddl_encoder_data encoder;
+};
+
+struct ddl_context {
+	int memtype;
+	u8 *core_virtual_base_addr;
+	void (*ddl_callback) (u32 event, u32 status, void *payload, size_t sz,
+			      u32 *ddl_handle, void *const client_data);
+	void *client_data;
+	void (*interrupt_clr) (void);
+	enum ddl_cmd_state cmd_state;
+	struct ddl_client_context *current_ddl;
+	struct ddl_buf_addr context_buf_addr;
+	struct ddl_buf_addr db_line_buffer;
+	struct ddl_buf_addr data_partition_tempbuf;
+	struct ddl_buf_addr metadata_shared_input;
+	struct ddl_buf_addr dbg_core_dump;
+	u32 enable_dbg_core_dump;
+	struct ddl_client_context *ddl_clients[VCD_MAX_NO_CLIENT];
+	struct ion_client *video_ion_client;
+	u32 device_state;
+	u32 ddl_busy;
+	u32  intr_status;
+	u32 cmd_err_status;
+	u32 disp_pic_err_status;
+	u32 op_failed;
+};
+
+struct ddl_client_context {
+	struct ddl_context *ddl_context;
+	enum ddl_client_state client_state;
+	u32 decoding;
+	u32 channel_id;
+	struct ddl_frame_data_tag input_frame;
+	struct ddl_frame_data_tag output_frame;
+	union ddl_codec_data codec_data;
+};
+
+DDL_INLINE struct ddl_context *ddl_get_context(void);
+DDL_INLINE void ddl_move_command_state(struct ddl_context *ddl_context,
+				       enum ddl_cmd_state command_state);
+DDL_INLINE void ddl_move_client_state(struct ddl_client_context *ddl,
+				      enum ddl_client_state client_state);
+void ddl_core_init(struct ddl_context *);
+void ddl_core_start_cpu(struct ddl_context *);
+void ddl_channel_set(struct ddl_client_context *);
+void ddl_channel_end(struct ddl_client_context *);
+void ddl_encode_init_codec(struct ddl_client_context *);
+void ddl_decode_init_codec(struct ddl_client_context *);
+void ddl_encode_frame_run(struct ddl_client_context *);
+void ddl_decode_frame_run(struct ddl_client_context *);
+void  ddl_decode_eos_run(struct ddl_client_context *);
+void ddl_release_context_buffers(struct ddl_context *);
+void ddl_release_client_internal_buffers(struct ddl_client_context *ddl);
+u32 ddl_decode_set_buffers(struct ddl_client_context *);
+u32 ddl_decoder_dpb_transact(struct ddl_decoder_data *decoder,
+			     struct ddl_frame_data_tag *in_out_frame,
+			     u32 operation);
+u32 ddl_client_transact(u32, struct ddl_client_context **);
+void ddl_set_default_decoder_buffer_req
+    (struct ddl_decoder_data *decoder, u32 estimate);
+void ddl_set_default_encoder_buffer_req
+    (struct ddl_encoder_data *encoder);
+void ddl_set_default_dec_property(struct ddl_client_context *);
+u32 ddl_encoder_ready_to_start(struct ddl_client_context *);
+u32 ddl_decoder_ready_to_start(struct ddl_client_context *,
+			       struct vcd_sequence_hdr *);
+u32 ddl_get_yuv_buffer_size
+    (struct vcd_property_frame_size *frame_size,
+     struct vcd_property_buffer_format *buf_format, u32 inter_lace,
+     enum vcd_codec codec);
+void ddl_calculate_stride(struct vcd_property_frame_size *frame_size,
+	u32 inter_lace, enum vcd_codec codec);
+void ddl_encode_dynamic_property(struct ddl_client_context *ddl,
+				 u32 enable);
+void ddl_decode_dynamic_property(struct ddl_client_context *ddl,
+				 u32 enable);
+void ddl_set_initial_default_values(struct ddl_client_context *ddl);
+u32 ddl_handle_core_errors(struct ddl_context *ddl_context);
+void ddl_client_fatal_cb(struct ddl_context *ddl_context);
+void ddl_hw_fatal_cb(struct ddl_context *ddl_context);
+u32 ddl_hal_engine_reset(struct ddl_context *ddl_context);
+void ddl_pmem_alloc(struct ddl_buf_addr *addr, size_t sz, u32 alignment);
+void ddl_pmem_free(struct ddl_buf_addr *addr);
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_api.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_api.h
new file mode 100644
index 0000000..3796e8f
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_api.h
@@ -0,0 +1,53 @@
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_API_H_
+#define _VCD_DDL_API_H_
+#include "vcd_ddl_internal_property.h"
+
+struct ddl_init_config {
+	int memtype;
+	u8 *core_virtual_base_addr;
+	void (*interrupt_clr) (void);
+	void (*ddl_callback) (u32 event, u32 status, void *payload, size_t sz,
+		u32 *ddl_handle, void *const client_data);
+};
+
+struct ddl_frame_data_tag {
+	struct vcd_frame_data vcd_frm;
+	u32 frm_trans_end;
+	u32 frm_delta;
+};
+
+u32 ddl_device_init(struct ddl_init_config *ddl_init_config,
+					void *client_data);
+u32 ddl_device_release(void *client_data);
+u32 ddl_open(u32 **ddl_handle, u32 decoding);
+u32 ddl_close(u32 **ddl_handle);
+u32 ddl_encode_start(u32 *ddl_handle, void *client_data);
+u32 ddl_encode_frame(u32 *ddl_handle,
+	struct ddl_frame_data_tag *input_frame,
+	struct ddl_frame_data_tag *output_bit, void *client_data);
+u32 ddl_encode_end(u32 *ddl_handle, void *client_data);
+u32 ddl_decode_start(u32 *ddl_handle, struct vcd_sequence_hdr *header,
+					void *client_data);
+u32 ddl_decode_frame(u32 *ddl_handle,
+	struct ddl_frame_data_tag *input_bits, void *client_data);
+u32 ddl_decode_end(u32 *ddl_handle, void *client_data);
+u32 ddl_set_property(u32 *ddl_handle,
+	struct vcd_property_hdr *property_hdr, void *property_value);
+u32 ddl_get_property(u32 *ddl_handle,
+	struct vcd_property_hdr *property_hdr, void *property_value);
+void ddl_read_and_clear_interrupt(void);
+u32 ddl_process_core_response(void);
+u32 ddl_reset_hw(u32 mode);
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_core.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_core.h
new file mode 100644
index 0000000..78b05ec
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_core.h
@@ -0,0 +1,99 @@
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_CORE_H_
+#define _VCD_DDL_CORE_H_
+
+#define DDL_LINEAR_BUF_ALIGN_MASK   0xFFFFFFF8U
+#define DDL_LINEAR_BUF_ALIGN_GUARD_BYTES 0x7
+#define DDL_LINEAR_BUFFER_ALIGN_BYTES  8
+
+#define DDL_TILE_BUF_ALIGN_MASK   0xFFFFE000U
+#define DDL_TILE_BUF_ALIGN_GUARD_BYTES 0x1FFF
+#define DDL_TILE_BUFFER_ALIGN_BYTES  8192
+
+#define DDL_MAX_FRAME_WIDTH   (1280)
+#define DDL_MAX_FRAME_HEIGHT  (720)
+
+#define DDL_MAX_DP_FRAME_WIDTH  352
+#define DDL_MAX_DP_FRAME_HEIGHT 288
+
+#define DDL_MAX_BIT_RATE (14*1000*1000)
+
+#define DDL_SW_RESET_SLEEP 10
+
+#define VCD_MAX_NO_CLIENT  4
+#define VCD_FRAME_COMMAND_DEPTH 1
+#define VCD_GENERAL_COMMAND_DEPTH 1
+#define VCD_COMMAND_EXCLUSIVE true
+
+#define DDL_HW_TIMEOUT_IN_MS  1000
+
+#define DDL_STREAMBUF_ALIGN_GUARD_BYTES 0x7
+
+#define DDL_CONTEXT_MEMORY (1024 * 15 * (VCD_MAX_NO_CLIENT + 1))
+#define DDL_DB_LINE_BUF_SIZE \
+(((((DDL_MAX_FRAME_WIDTH * 4) - 1) / 256) + 1) * 8 * 1024)
+#define DDL_MPEG4_DATA_PARTITION_BUF_SIZE (64 * 1024)
+#define DDL_DECODE_H264_VSPTEMP_BUFSIZE 0x59c00
+#define DDL_ENC_NUM_DPB_BUFFERS 2
+
+#define DDL_DBG_CORE_DUMP_SIZE (10 * 1024)
+
+#define DDL_BUFEND_PAD    256
+#define DDL_ENC_SEQHEADER_SIZE (256+DDL_BUFEND_PAD)
+#define DDL_MAX_BUFFER_COUNT  32
+
+#define DDL_MPEG_REFBUF_COUNT  2
+
+#define DDL_MPEG_COMV_BUF_NO 2
+#define DDL_H263_COMV_BUF_NO 2
+#define DDL_COMV_BUFLINE_NO  128
+#define DDL_VC1_COMV_BUFLINE_NO  32
+#define DDL_MINIMUM_BYTE_PER_SLICE  1920
+
+#define DDL_MAX_H264_QP   51
+#define DDL_MAX_MPEG4_QP  31
+
+#define DDL_PADDING_HACK(addr) \
+ (addr) = (u32)((((u32)(addr) + DDL_STREAMBUF_ALIGN_GUARD_BYTES) & \
+			 ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES)) + DDL_BUFEND_PAD)
+
+#define DDL_QCIF_MBS 99
+#define DDL_CIF_MBS  396
+#define DDL_QVGA_MBS 300
+#define DDL_VGA_MBS  1200
+#define DDL_WVGA_MBS 1500
+#define DDL_720P_MBS 3600
+
+#define DDL_FRAMESIZE_DIV_FACTOR   (0xF)
+
+#define DDL_NO_OF_MB(width, height) \
+	(((width + 15) >> 4) * ((height + 15) >> 4))
+
+#define DDL_ALLOW_ENC_FRAMESIZE(width, height) \
+((DDL_NO_OF_MB(width, height) <= DDL_720P_MBS) \
+ && (((width) <= DDL_MAX_FRAME_WIDTH) &&            \
+     ((height) <= DDL_MAX_FRAME_WIDTH))            \
+ && ((width) >= 32 && (height) >= 32))
+
+#define DDL_VALIDATE_ENC_FRAMESIZE(width, height) \
+	(!((width) & DDL_FRAMESIZE_DIV_FACTOR) &&     \
+     !((height) & DDL_FRAMESIZE_DIV_FACTOR))
+
+#define DDL_TILE_ALIGN_WIDTH     128
+#define DDL_TILE_ALIGN_HEIGHT    32
+#define DDL_TILE_MULTIPLY_FACTOR 8192
+#define DDL_TILE_ALIGN(val, grid) \
+   (((val) + (grid) - 1) / (grid) * (grid))
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_errors.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_errors.c
new file mode 100644
index 0000000..6e43a7c
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_errors.c
@@ -0,0 +1,612 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl.h"
+
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
+
+#define ERR(x...) printk(KERN_ERR x)
+
+#define INVALID_CHANNEL_NUMBER  1
+#define INVALID_COMMAND_ID 2
+#define CHANNEL_ALREADY_IN_USE 3
+#define CHANNEL_NOT_SET_BEFORE_CHANNEL_CLOSE 4
+#define CHANNEL_SET_ERROR_INIT_CODEC 5
+#define INIT_CODEC_ALREADY_CALLED 6
+#define CHANNEL_SET_ERROR_INIT_BUFFERS 7
+#define INIT_CODEC_ERROR_INIT_BUFFERS 8
+#define INIT_BUFFER_ALREADY_CALLED  9
+#define CHANNEL_SET_ERROR_FRAME_RUN 10
+#define INIT_CODEC_ERROR_FRAME_RUN 11
+#define INIT_BUFFERS_ERROR_FRAME_RUN 12
+#define CODEC_LIMIT_EXCEEDED 13
+#define FIRMWARE_SIZE_ZERO 14
+#define FIRMWARE_ADDRESS_EXT_ZERO 15
+#define CONTEXT_DMA_IN_ERROR 16
+#define CONTEXT_DMA_OUT_ERROR 17
+#define PROGRAM_DMA_ERROR 18
+#define CONTEXT_STORE_EXT_ADD_ZERO 19
+#define MEM_ALLOCATION_FAILED 20
+
+
+#define UNSUPPORTED_FEATURE_IN_PROFILE 27
+#define RESOLUTION_NOT_SUPPORTED 28
+#define HEADER_NOT_FOUND 52
+#define MB_NUM_INVALID 61
+#define FRAME_RATE_NOT_SUPPORTED 62
+#define INVALID_QP_VALUE 63
+#define INVALID_RC_REACTION_COEFFICIENT 64
+#define INVALID_CPB_SIZE_AT_GIVEN_LEVEL 65
+
+#define ALLOC_DPB_SIZE_NOT_SUFFICIENT 71
+#define ALLOC_DB_SIZE_NOT_SUFFICIENT 72
+#define ALLOC_COMV_SIZE_NOT_SUFFICIENT 73
+#define NUM_BUF_OUT_OF_RANGE 74
+#define NULL_CONTEXT_POINTER 75
+#define NULL_COMAMND_CONTROL_COMM_POINTER 76
+#define NULL_METADATA_INPUT_POINTER 77
+#define NULL_DPB_POINTER 78
+#define NULL_DB_POINTER 79
+#define NULL_COMV_POINTER 80
+
+#define DIVIDE_BY_ZERO 81
+#define BIT_STREAM_BUF_EXHAUST 82
+#define DMA_NOT_STOPPED 83
+#define DMA_TX_NOT_COMPLETE 84
+
+#define MB_HEADER_NOT_DONE  85
+#define MB_COEFF_NOT_DONE 86
+#define CODEC_SLICE_NOT_DONE 87
+#define VME_NOT_READY 88
+#define VC1_BITPLANE_DECODE_ERR 89
+
+
+#define VSP_NOT_READY 90
+#define BUFFER_FULL_STATE 91
+
+#define RESOLUTION_MISMATCH 112
+#define NV_QUANT_ERR 113
+#define SYNC_MARKER_ERR 114
+#define FEATURE_NOT_SUPPORTED 115
+#define MEM_CORRUPTION  116
+#define INVALID_REFERENCE_FRAME  117
+#define PICTURE_CODING_TYPE_ERR  118
+#define MV_RANGE_ERR  119
+#define PICTURE_STRUCTURE_ERR 120
+#define SLICE_ADDR_INVALID  121
+#define NON_PAIRED_FIELD_NOT_SUPPORTED  122
+#define NON_FRAME_DATA_RECEIVED 123
+#define INCOMPLETE_FRAME  124
+#define NO_BUFFER_RELEASED_FROM_HOST  125
+#define PICTURE_MANAGEMENT_ERROR  128
+#define INVALID_MMCO  129
+#define INVALID_PIC_REORDERING 130
+#define INVALID_POC_TYPE 131
+#define ACTIVE_SPS_NOT_PRESENT 132
+#define ACTIVE_PPS_NOT_PRESENT 133
+#define INVALID_SPS_ID 134
+#define INVALID_PPS_ID 135
+
+
+#define METADATA_NO_SPACE_QP 151
+#define METADATA_NO_SAPCE_CONCEAL_MB 152
+#define METADATA_NO_SPACE_VC1_PARAM 153
+#define METADATA_NO_SPACE_SEI 154
+#define METADATA_NO_SPACE_VUI 155
+#define METADATA_NO_SPACE_EXTRA 156
+#define METADATA_NO_SPACE_DATA_NONE 157
+#define FRAME_RATE_UNKNOWN 158
+#define ASPECT_RATIO_UNKOWN 159
+#define COLOR_PRIMARIES_UNKNOWN 160
+#define TRANSFER_CHAR_UNKWON 161
+#define MATRIX_COEFF_UNKNOWN 162
+#define NON_SEQ_SLICE_ADDR 163
+#define BROKEN_LINK 164
+#define FRAME_CONCEALED 165
+#define PROFILE_UNKOWN 166
+#define LEVEL_UNKOWN 167
+#define BIT_RATE_NOT_SUPPORTED 168
+#define COLOR_DIFF_FORMAT_NOT_SUPPORTED 169
+#define NULL_EXTRA_METADATA_POINTER  170
+#define SYNC_POINT_NOT_RECEIVED_STARTED_DECODING  171
+#define NULL_FW_DEBUG_INFO_POINTER  172
+#define ALLOC_DEBUG_INFO_SIZE_INSUFFICIENT  173
+#define MAX_STAGE_COUNTER_EXCEEDED 174
+
+#define METADATA_NO_SPACE_MB_INFO 180
+#define METADATA_NO_SPACE_SLICE_SIZE 181
+#define RESOLUTION_WARNING 182
+
+static void ddl_handle_npf_decoding_error(
+	struct ddl_context *ddl_context);
+
+static u32 ddl_handle_seqhdr_fail_error(
+	struct ddl_context *ddl_context);
+
+void ddl_hw_fatal_cb(struct ddl_context *ddl_context)
+{
+	/* Invalidate the command state */
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	ddl_context->device_state = DDL_DEVICE_HWFATAL;
+
+	/* callback to the client to indicate hw fatal error */
+	ddl_context->ddl_callback(VCD_EVT_IND_HWERRFATAL,
+					VCD_ERR_HW_FATAL, NULL, 0,
+					(void *)ddl_context->current_ddl,
+					ddl_context->client_data);
+
+	DDL_IDLE(ddl_context);
+}
+
+static u32 ddl_handle_hw_fatal_errors(struct ddl_context
+			*ddl_context)
+{
+	u32 status = false;
+
+	switch (ddl_context->cmd_err_status) {
+
+	case INVALID_CHANNEL_NUMBER:
+	case INVALID_COMMAND_ID:
+	case CHANNEL_ALREADY_IN_USE:
+	case CHANNEL_NOT_SET_BEFORE_CHANNEL_CLOSE:
+	case CHANNEL_SET_ERROR_INIT_CODEC:
+	case INIT_CODEC_ALREADY_CALLED:
+	case CHANNEL_SET_ERROR_INIT_BUFFERS:
+	case INIT_CODEC_ERROR_INIT_BUFFERS:
+	case INIT_BUFFER_ALREADY_CALLED:
+	case CHANNEL_SET_ERROR_FRAME_RUN:
+	case INIT_CODEC_ERROR_FRAME_RUN:
+	case INIT_BUFFERS_ERROR_FRAME_RUN:
+	case CODEC_LIMIT_EXCEEDED:
+	case FIRMWARE_SIZE_ZERO:
+	case FIRMWARE_ADDRESS_EXT_ZERO:
+
+	case CONTEXT_DMA_IN_ERROR:
+	case CONTEXT_DMA_OUT_ERROR:
+	case PROGRAM_DMA_ERROR:
+	case CONTEXT_STORE_EXT_ADD_ZERO:
+	case MEM_ALLOCATION_FAILED:
+
+	case DIVIDE_BY_ZERO:
+	case DMA_NOT_STOPPED:
+	case DMA_TX_NOT_COMPLETE:
+
+	case VSP_NOT_READY:
+	case BUFFER_FULL_STATE:
+	case NULL_DB_POINTER:
+		ERR("HW FATAL ERROR");
+		ddl_hw_fatal_cb(ddl_context);
+		status = true;
+		break;
+	}
+	return status;
+}
+
+void ddl_client_fatal_cb(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context  *ddl =
+		ddl_context->current_ddl;
+
+	if (ddl_context->cmd_state == DDL_CMD_DECODE_FRAME)
+		ddl_decode_dynamic_property(ddl, false);
+	else if (ddl_context->cmd_state == DDL_CMD_ENCODE_FRAME)
+		ddl_encode_dynamic_property(ddl, false);
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	ddl_move_client_state(ddl, DDL_CLIENT_FATAL_ERROR);
+
+	ddl_context->ddl_callback
+	(
+		VCD_EVT_IND_HWERRFATAL,
+		VCD_ERR_CLIENT_FATAL,
+		NULL,
+		0,
+		(void *)ddl,
+		ddl_context->client_data
+	);
+
+	DDL_IDLE(ddl_context);
+}
+
+static u32 ddl_handle_client_fatal_errors(struct ddl_context
+			*ddl_context)
+{
+	u32 status = false;
+
+	switch (ddl_context->cmd_err_status) {
+	case MB_NUM_INVALID:
+	case FRAME_RATE_NOT_SUPPORTED:
+	case INVALID_QP_VALUE:
+	case INVALID_RC_REACTION_COEFFICIENT:
+	case INVALID_CPB_SIZE_AT_GIVEN_LEVEL:
+
+	case ALLOC_DPB_SIZE_NOT_SUFFICIENT:
+	case ALLOC_DB_SIZE_NOT_SUFFICIENT:
+	case ALLOC_COMV_SIZE_NOT_SUFFICIENT:
+	case NUM_BUF_OUT_OF_RANGE:
+	case NULL_CONTEXT_POINTER:
+	case NULL_COMAMND_CONTROL_COMM_POINTER:
+	case NULL_METADATA_INPUT_POINTER:
+	case NULL_DPB_POINTER:
+	case NULL_COMV_POINTER:
+		{
+			status = true;
+			break;
+		}
+	}
+
+	if (!status)
+		ERR("UNKNOWN-OP-FAILED");
+
+	ddl_client_fatal_cb(ddl_context);
+
+	return true;
+}
+
+static void ddl_input_failed_cb(struct ddl_context *ddl_context,
+			u32 vcd_event, u32 vcd_status)
+{
+	struct ddl_client_context  *ddl = ddl_context->current_ddl;
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	if (ddl->decoding)
+		ddl_decode_dynamic_property(ddl, false);
+	else
+		ddl_encode_dynamic_property(ddl, false);
+
+	ddl_context->ddl_callback(vcd_event,
+		vcd_status, &ddl->input_frame,
+		sizeof(struct ddl_frame_data_tag),
+		(void *)ddl, ddl_context->client_data);
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+}
+
+static u32 ddl_handle_core_recoverable_errors(struct ddl_context \
+			*ddl_context)
+{
+	struct ddl_client_context  *ddl = ddl_context->current_ddl;
+	u32   vcd_status = VCD_S_SUCCESS;
+	u32   vcd_event = VCD_EVT_RESP_INPUT_DONE;
+	u32   eos = false, pending_display = 0, release_mask = 0;
+
+	if (ddl->decoding)
+		if (ddl_handle_seqhdr_fail_error(ddl_context))
+			return true;
+
+	if (ddl_context->cmd_state != DDL_CMD_DECODE_FRAME &&
+		ddl_context->cmd_state != DDL_CMD_ENCODE_FRAME) {
+		return false;
+	}
+	switch (ddl_context->cmd_err_status) {
+	case NON_PAIRED_FIELD_NOT_SUPPORTED:
+		{
+			ddl_handle_npf_decoding_error(ddl_context);
+			return true;
+		}
+	case NO_BUFFER_RELEASED_FROM_HOST:
+		{
+			/* lets check sanity of this error */
+			release_mask =
+				ddl->codec_data.decoder.dpb_mask.hw_mask;
+			while (release_mask > 0) {
+				if ((release_mask & 0x1))
+					pending_display += 1;
+				release_mask >>= 1;
+			}
+
+			if (pending_display >=
+				ddl->codec_data.decoder.min_dpb_num) {
+				DBG("FWISSUE-REQBUF!!");
+				/* callback to client for client fatal error */
+				ddl_client_fatal_cb(ddl_context);
+				return true ;
+			}
+		vcd_event = VCD_EVT_RESP_OUTPUT_REQ;
+		break;
+		}
+	case BIT_STREAM_BUF_EXHAUST:
+	case MB_HEADER_NOT_DONE:
+	case MB_COEFF_NOT_DONE:
+	case CODEC_SLICE_NOT_DONE:
+	case VME_NOT_READY:
+	case VC1_BITPLANE_DECODE_ERR:
+		{
+			u32 reset_core;
+			/* need to reset the internal core hw engine */
+			reset_core = ddl_hal_engine_reset(ddl_context);
+			if (!reset_core)
+				return true;
+			/* fall through to process bitstream error handling */
+		}
+	case RESOLUTION_MISMATCH:
+	case NV_QUANT_ERR:
+	case SYNC_MARKER_ERR:
+	case FEATURE_NOT_SUPPORTED:
+	case MEM_CORRUPTION:
+	case INVALID_REFERENCE_FRAME:
+	case PICTURE_CODING_TYPE_ERR:
+	case MV_RANGE_ERR:
+	case PICTURE_STRUCTURE_ERR:
+	case SLICE_ADDR_INVALID:
+	case NON_FRAME_DATA_RECEIVED:
+	case INCOMPLETE_FRAME:
+	case PICTURE_MANAGEMENT_ERROR:
+	case INVALID_MMCO:
+	case INVALID_PIC_REORDERING:
+	case INVALID_POC_TYPE:
+		{
+			vcd_status = VCD_ERR_BITSTREAM_ERR;
+			break;
+		}
+	case ACTIVE_SPS_NOT_PRESENT:
+	case ACTIVE_PPS_NOT_PRESENT:
+		{
+			if (ddl->codec_data.decoder.idr_only_decoding) {
+				DBG("Consider warnings as errors in idr mode");
+				ddl_client_fatal_cb(ddl_context);
+				return true;
+			}
+			vcd_status = VCD_ERR_BITSTREAM_ERR;
+			break;
+		}
+	case PROFILE_UNKOWN:
+		if (ddl->decoding)
+			vcd_status = VCD_ERR_BITSTREAM_ERR;
+		break;
+	}
+
+	if (!vcd_status && vcd_event == VCD_EVT_RESP_INPUT_DONE)
+		return false;
+
+	ddl->input_frame.frm_trans_end = true;
+
+	eos = ((vcd_event == VCD_EVT_RESP_INPUT_DONE) &&
+		((VCD_FRAME_FLAG_EOS & ddl->input_frame.
+				vcd_frm.flags)));
+
+	if ((ddl->decoding && eos) ||
+		(!ddl->decoding))
+		ddl->input_frame.frm_trans_end = false;
+
+	if (vcd_event == VCD_EVT_RESP_INPUT_DONE &&
+		ddl->decoding &&
+		!ddl->codec_data.decoder.header_in_start &&
+		!ddl->codec_data.decoder.dec_disp_info.img_size_x &&
+		!ddl->codec_data.decoder.dec_disp_info.img_size_y &&
+		!eos) {
+		DBG("Treat header in start error %u as success",
+			vcd_status);
+		/* this is first frame seq. header only case */
+		vcd_status = VCD_S_SUCCESS;
+		ddl->input_frame.vcd_frm.flags |=
+			VCD_FRAME_FLAG_CODECCONFIG;
+		ddl->input_frame.frm_trans_end = !eos;
+		/* put just some non - zero value */
+		ddl->codec_data.decoder.dec_disp_info.img_size_x = 0xff;
+	}
+	/* inform client about input failed */
+	ddl_input_failed_cb(ddl_context, vcd_event, vcd_status);
+
+	/* for Encoder case, we need to send output done also */
+	if (!ddl->decoding) {
+		/* transaction is complete after this callback */
+		ddl->output_frame.frm_trans_end = !eos;
+		/* error case: NO data present */
+		ddl->output_frame.vcd_frm.data_len = 0;
+		/* call back to client for output frame done */
+		ddl_context->ddl_callback(VCD_EVT_RESP_OUTPUT_DONE,
+		VCD_ERR_FAIL, &(ddl->output_frame),
+			sizeof(struct ddl_frame_data_tag),
+			(void *)ddl, ddl_context->client_data);
+
+		if (eos) {
+			DBG("ENC-EOS_DONE");
+			/* send client EOS DONE callback */
+			ddl_context->ddl_callback(VCD_EVT_RESP_EOS_DONE,
+				VCD_S_SUCCESS, NULL, 0, (void *)ddl,
+				ddl_context->client_data);
+		}
+	}
+
+	/* if it is decoder EOS case */
+	if (ddl->decoding && eos) {
+		DBG("DEC-EOS_RUN");
+		ddl_decode_eos_run(ddl);
+	} else
+		DDL_IDLE(ddl_context);
+
+	return true;
+}
+
+static u32 ddl_handle_core_warnings(u32 err_status)
+{
+	u32 status = false;
+
+	switch (err_status) {
+	case FRAME_RATE_UNKNOWN:
+	case ASPECT_RATIO_UNKOWN:
+	case COLOR_PRIMARIES_UNKNOWN:
+	case TRANSFER_CHAR_UNKWON:
+	case MATRIX_COEFF_UNKNOWN:
+	case NON_SEQ_SLICE_ADDR:
+	case BROKEN_LINK:
+	case FRAME_CONCEALED:
+	case PROFILE_UNKOWN:
+	case LEVEL_UNKOWN:
+	case BIT_RATE_NOT_SUPPORTED:
+	case COLOR_DIFF_FORMAT_NOT_SUPPORTED:
+	case NULL_EXTRA_METADATA_POINTER:
+	case SYNC_POINT_NOT_RECEIVED_STARTED_DECODING:
+
+	case NULL_FW_DEBUG_INFO_POINTER:
+	case ALLOC_DEBUG_INFO_SIZE_INSUFFICIENT:
+	case MAX_STAGE_COUNTER_EXCEEDED:
+
+	case METADATA_NO_SPACE_MB_INFO:
+	case METADATA_NO_SPACE_SLICE_SIZE:
+	case RESOLUTION_WARNING:
+
+	/* decoder warnings */
+	case METADATA_NO_SPACE_QP:
+	case METADATA_NO_SAPCE_CONCEAL_MB:
+	case METADATA_NO_SPACE_VC1_PARAM:
+	case METADATA_NO_SPACE_SEI:
+	case METADATA_NO_SPACE_VUI:
+	case METADATA_NO_SPACE_EXTRA:
+	case METADATA_NO_SPACE_DATA_NONE:
+		{
+			status = true;
+			DBG("CMD-WARNING-IGNORED!!");
+			break;
+		}
+	}
+	return status;
+}
+
+u32 ddl_handle_core_errors(struct ddl_context *ddl_context)
+{
+	u32 status = false;
+
+	if (!ddl_context->cmd_err_status &&
+		!ddl_context->disp_pic_err_status &&
+		!ddl_context->op_failed)
+		return false;
+
+	if (ddl_context->cmd_state == DDL_CMD_INVALID) {
+		DBG("SPURIOUS_INTERRUPT_ERROR");
+		return true;
+	}
+
+	if (!ddl_context->op_failed) {
+		u32 disp_status;
+		status = ddl_handle_core_warnings(ddl_context->
+			cmd_err_status);
+		disp_status = ddl_handle_core_warnings(
+			ddl_context->disp_pic_err_status);
+		if (!status && !disp_status)
+			DBG("ddl_warning:Unknown");
+
+		return false;
+	}
+
+	ERR("\n %s(): OPFAILED!!", __func__);
+	ERR("\n CMD_ERROR_STATUS = %u, DISP_ERR_STATUS = %u",
+		ddl_context->cmd_err_status,
+		ddl_context->disp_pic_err_status);
+
+	status = ddl_handle_hw_fatal_errors(ddl_context);
+
+	if (!status)
+		status = ddl_handle_core_recoverable_errors(ddl_context);
+
+	if (!status)
+		status = ddl_handle_client_fatal_errors(ddl_context);
+
+	return status;
+}
+
+void ddl_handle_npf_decoding_error(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+	if (!ddl->decoding) {
+		ERR("FWISSUE-ENC-NPF!!!");
+		ddl_client_fatal_cb(ddl_context);
+		return;
+	}
+	vidc_720p_decode_display_info(&decoder->dec_disp_info);
+	ddl_decode_dynamic_property(ddl, false);
+	ddl->output_frame.vcd_frm.ip_frm_tag =
+		decoder->dec_disp_info.tag_top;
+	ddl->output_frame.vcd_frm.physical = NULL;
+	ddl->output_frame.frm_trans_end = false;
+	ddl->ddl_context->ddl_callback(
+		VCD_EVT_RESP_OUTPUT_DONE,
+		VCD_ERR_INTRLCD_FIELD_DROP,
+		&ddl->output_frame,
+		sizeof(struct ddl_frame_data_tag),
+		(void *)ddl,
+		ddl->ddl_context->client_data);
+	ddl_decode_frame_run(ddl);
+}
+
+u32 ddl_handle_seqhdr_fail_error(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+	u32 status = false;
+	if (ddl_context->cmd_state == DDL_CMD_HEADER_PARSE &&
+		DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_INITCODECDONE)) {
+		switch (ddl_context->cmd_err_status) {
+		case UNSUPPORTED_FEATURE_IN_PROFILE:
+		case HEADER_NOT_FOUND:
+		case INVALID_SPS_ID:
+		case INVALID_PPS_ID:
+		case RESOLUTION_NOT_SUPPORTED:
+		case PROFILE_UNKOWN:
+			ERR("SEQ-HDR-FAILED!!!");
+			if ((ddl_context->cmd_err_status ==
+				 RESOLUTION_NOT_SUPPORTED) &&
+				(decoder->codec.codec == VCD_CODEC_H264 ||
+				decoder->codec.codec == VCD_CODEC_H263 ||
+				decoder->codec.codec == VCD_CODEC_MPEG4 ||
+				decoder->codec.codec == VCD_CODEC_VC1_RCV ||
+				decoder->codec.codec == VCD_CODEC_VC1)) {
+				ddl_client_fatal_cb(ddl_context);
+				status = true;
+				break;
+			}
+			if (decoder->header_in_start) {
+				decoder->header_in_start = false;
+				ddl_context->ddl_callback(VCD_EVT_RESP_START,
+					VCD_ERR_SEQHDR_PARSE_FAIL,
+					NULL, 0, (void *)ddl,
+					ddl_context->client_data);
+			} else {
+				if (ddl->input_frame.vcd_frm.flags &
+					VCD_FRAME_FLAG_EOS)
+					ddl->input_frame.frm_trans_end = false;
+				else
+					ddl->input_frame.frm_trans_end = true;
+				ddl_decode_dynamic_property(ddl, false);
+				ddl_context->ddl_callback(
+					VCD_EVT_RESP_INPUT_DONE,
+					VCD_ERR_SEQHDR_PARSE_FAIL,
+					&ddl->input_frame,
+					sizeof(struct ddl_frame_data_tag),
+					(void *)ddl, ddl_context->client_data);
+				if (ddl->input_frame.vcd_frm.flags &
+					VCD_FRAME_FLAG_EOS)
+					ddl_context->ddl_callback(
+						VCD_EVT_RESP_EOS_DONE,
+						VCD_S_SUCCESS, NULL,
+						0, (void *)ddl,
+						ddl_context->client_data);
+			}
+			ddl_move_client_state(ddl,
+				DDL_CLIENT_WAIT_FOR_INITCODEC);
+			DDL_IDLE(ddl_context);
+			status = true;
+		}
+	}
+	return status;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.c
new file mode 100644
index 0000000..23948d4
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.c
@@ -0,0 +1,352 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_firmware.h"
+#include "vcd_ddl_utils.h"
+
+#define VCDFW_TOTALNUM_IMAGE  7
+#define VCDFW_MAX_NO_IMAGE    2
+
+struct vcd_firmware {
+	u32 active_fw_img[VCDFW_TOTALNUM_IMAGE];
+	struct ddl_buf_addr boot_code;
+
+	struct ddl_buf_addr enc_mpeg4;
+	struct ddl_buf_addr encH264;
+
+	struct ddl_buf_addr dec_mpeg4;
+	struct ddl_buf_addr decH264;
+	struct ddl_buf_addr decH263;
+	struct ddl_buf_addr dec_mpeg2;
+	struct ddl_buf_addr dec_vc1;
+};
+
+static struct vcd_firmware vcd_firmware;
+
+
+static void vcd_fw_change_endian(unsigned char *fw, u32 fw_size)
+{
+	u32 i = 0;
+	unsigned char temp;
+	for (i = 0; i < fw_size; i = i + 4) {
+		temp = fw[i];
+		fw[i] = fw[i + 3];
+		fw[i + 3] = temp;
+
+		temp = fw[i + 1];
+		fw[i + 1] = fw[i + 2];
+		fw[i + 2] = temp;
+	}
+	return;
+}
+
+static u32 vcd_fw_prepare(struct ddl_buf_addr *fw_details,
+			 const unsigned char fw_array[],
+			 const unsigned int fw_array_size, u32 change_endian)
+{
+	u32 *buffer;
+
+	ddl_pmem_alloc(fw_details, fw_array_size,
+		       DDL_LINEAR_BUFFER_ALIGN_BYTES);
+	if (!fw_details->virtual_base_addr)
+		return false;
+
+	fw_details->buffer_size = fw_array_size / 4;
+
+	buffer = fw_details->align_virtual_addr;
+
+	memcpy(buffer, fw_array, fw_array_size);
+	if (change_endian)
+		vcd_fw_change_endian((unsigned char *)buffer, fw_array_size);
+	return true;
+}
+
+u32 vcd_fw_init(void)
+{
+	u32 status = false;
+
+	status = vcd_fw_prepare(&vcd_firmware.boot_code,
+				vidc_command_control_fw,
+				vidc_command_control_fw_size, false);
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.dec_mpeg4,
+					vidc_mpg4_dec_fw,
+					vidc_mpg4_dec_fw_size, true);
+	}
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.decH264,
+					vidc_h264_dec_fw,
+					vidc_h264_dec_fw_size, true);
+	}
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.decH263,
+					vidc_h263_dec_fw,
+					vidc_h263_dec_fw_size, true);
+	}
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.enc_mpeg4,
+					vidc_mpg4_enc_fw,
+					vidc_mpg4_enc_fw_size, true);
+	}
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.encH264,
+					vidc_h264_enc_fw,
+					vidc_h264_enc_fw_size, true);
+	}
+
+	if (status) {
+		status = vcd_fw_prepare(&vcd_firmware.dec_vc1,
+					vidc_vc1_dec_fw,
+					vidc_vc1_dec_fw_size, true);
+	}
+	return status;
+}
+
+
+static u32 get_dec_fw_image(struct vcd_fw_details *fw_details)
+{
+	u32 status = true;
+	switch (fw_details->codec) {
+	case VCD_CODEC_DIVX_4:
+	case VCD_CODEC_DIVX_5:
+	case VCD_CODEC_DIVX_6:
+	case VCD_CODEC_XVID:
+	case VCD_CODEC_MPEG4:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.dec_mpeg4.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.dec_mpeg4.buffer_size;
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.decH264.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.decH264.buffer_size;
+			break;
+		}
+	case VCD_CODEC_VC1:
+	case VCD_CODEC_VC1_RCV:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.dec_vc1.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.dec_vc1.buffer_size;
+			break;
+		}
+	case VCD_CODEC_MPEG2:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.dec_mpeg2.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.dec_mpeg2.buffer_size;
+			break;
+		}
+	case VCD_CODEC_H263:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.decH263.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.decH263.buffer_size;
+			break;
+		}
+	default:
+		{
+			status = false;
+			break;
+		}
+	}
+	return status;
+}
+
+static u32 get_enc_fw_image(struct vcd_fw_details *fw_details)
+{
+	u32 status = true;
+	switch (fw_details->codec) {
+	case VCD_CODEC_H263:
+	case VCD_CODEC_MPEG4:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.enc_mpeg4.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.enc_mpeg4.buffer_size;
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.encH264.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.encH264.buffer_size;
+			break;
+		}
+	default:
+		{
+			status = false;
+			break;
+		}
+	}
+	return status;
+}
+
+u32 vcd_get_fw_property(u32 prop_id, void *prop_details)
+{
+	u32 status = true;
+	struct vcd_fw_details *fw_details;
+	switch (prop_id) {
+	case VCD_FW_ENDIAN:
+		{
+			*(u32 *) prop_details = VCD_FW_BIG_ENDIAN;
+			break;
+		}
+	case VCD_FW_BOOTCODE:
+		{
+			fw_details =
+			    (struct vcd_fw_details *)prop_details;
+			fw_details->fw_buffer_addr =
+			    vcd_firmware.boot_code.align_physical_addr;
+			fw_details->fw_size =
+			    vcd_firmware.boot_code.buffer_size;
+			break;
+		}
+	case VCD_FW_DECODE:
+		{
+			fw_details =
+			    (struct vcd_fw_details *)prop_details;
+			status = get_dec_fw_image(fw_details);
+			break;
+		}
+	case VCD_FW_ENCODE:
+		{
+			fw_details =
+			    (struct vcd_fw_details *)prop_details;
+			status = get_enc_fw_image(fw_details);
+			break;
+		}
+	default:
+		{
+			status = false;
+			break;
+		}
+	}
+	return status;
+}
+
+u32 vcd_fw_transact(u32 add, u32 decoding, enum vcd_codec codec)
+{
+	u32 status = true;
+	u32 index = 0, active_fw = 0, loop_count;
+
+	if (decoding) {
+		switch (codec) {
+		case VCD_CODEC_DIVX_4:
+		case VCD_CODEC_DIVX_5:
+		case VCD_CODEC_DIVX_6:
+		case VCD_CODEC_XVID:
+		case VCD_CODEC_MPEG4:
+			{
+				index = 0;
+				break;
+			}
+		case VCD_CODEC_H264:
+			{
+				index = 1;
+				break;
+			}
+		case VCD_CODEC_H263:
+			{
+				index = 2;
+				break;
+			}
+		case VCD_CODEC_MPEG2:
+			{
+				index = 3;
+				break;
+			}
+		case VCD_CODEC_VC1:
+		case VCD_CODEC_VC1_RCV:
+			{
+				index = 4;
+				break;
+			}
+		default:
+			{
+				status = false;
+				break;
+			}
+		}
+	} else {
+		switch (codec) {
+		case VCD_CODEC_H263:
+		case VCD_CODEC_MPEG4:
+			{
+				index = 5;
+				break;
+			}
+		case VCD_CODEC_H264:
+			{
+				index = 6;
+				break;
+			}
+		default:
+			{
+				status = false;
+				break;
+			}
+		}
+	}
+
+	if (!status)
+		return status;
+
+	if (!add &&
+	    vcd_firmware.active_fw_img[index]
+	    ) {
+		--vcd_firmware.active_fw_img[index];
+		return status;
+	}
+
+	for (loop_count = 0; loop_count < VCDFW_TOTALNUM_IMAGE;
+	     ++loop_count) {
+		if (vcd_firmware.active_fw_img[loop_count])
+			++active_fw;
+	}
+
+	if (active_fw < VCDFW_MAX_NO_IMAGE ||
+	    vcd_firmware.active_fw_img[index] > 0) {
+		++vcd_firmware.active_fw_img[index];
+	} else {
+		status = false;
+	}
+	return status;
+}
+
+void vcd_fw_release(void)
+{
+	ddl_pmem_free(&vcd_firmware.boot_code);
+	ddl_pmem_free(&vcd_firmware.enc_mpeg4);
+	ddl_pmem_free(&vcd_firmware.encH264);
+	ddl_pmem_free(&vcd_firmware.dec_mpeg4);
+	ddl_pmem_free(&vcd_firmware.decH264);
+	ddl_pmem_free(&vcd_firmware.decH263);
+	ddl_pmem_free(&vcd_firmware.dec_mpeg2);
+	ddl_pmem_free(&vcd_firmware.dec_vc1);
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.h
new file mode 100644
index 0000000..ba8dbcb
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_firmware.h
@@ -0,0 +1,53 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_FIRMWARE_H_
+#define _VCD_DDL_FIRMWARE_H_
+#include <media/msm/vcd_property.h>
+
+#define VCD_FW_BIG_ENDIAN     0x0
+#define VCD_FW_LITTLE_ENDIAN  0x1
+
+struct vcd_fw_details {
+	enum vcd_codec codec;
+	u32 *fw_buffer_addr;
+	u32 fw_size;
+};
+
+#define VCD_FW_PROP_BASE         0x0
+
+#define VCD_FW_ENDIAN       (VCD_FW_PROP_BASE + 0x1)
+#define VCD_FW_BOOTCODE     (VCD_FW_PROP_BASE + 0x2)
+#define VCD_FW_DECODE     (VCD_FW_PROP_BASE + 0x3)
+#define VCD_FW_ENCODE     (VCD_FW_PROP_BASE + 0x4)
+
+extern unsigned char *vidc_command_control_fw;
+extern u32 vidc_command_control_fw_size;
+extern unsigned char *vidc_mpg4_dec_fw;
+extern u32 vidc_mpg4_dec_fw_size;
+extern unsigned char *vidc_h263_dec_fw;
+extern u32 vidc_h263_dec_fw_size;
+extern unsigned char *vidc_h264_dec_fw;
+extern u32 vidc_h264_dec_fw_size;
+extern unsigned char *vidc_mpg4_enc_fw;
+extern u32 vidc_mpg4_enc_fw_size;
+extern unsigned char *vidc_h264_enc_fw;
+extern u32 vidc_h264_enc_fw_size;
+extern unsigned char *vidc_vc1_dec_fw;
+extern u32 vidc_vc1_dec_fw_size;
+
+u32 vcd_fw_init(void);
+u32 vcd_get_fw_property(u32 prop_id, void *prop_details);
+u32 vcd_fw_transact(u32 add, u32 decoding, enum vcd_codec codec);
+void vcd_fw_release(void);
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_hal.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_hal.c
new file mode 100644
index 0000000..4cbd984
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_hal.c
@@ -0,0 +1,971 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_metadata.h"
+
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
+
+#define DBG_INFO(x...) pr_info(x)
+
+void ddl_core_init(struct ddl_context *ddl_context)
+{
+	char *psz_version;
+	struct vcd_fw_details fw_details;
+	u32 fw_endianness;
+	enum vidc_720p_endian dma_endian;
+	u32 interrupt_off;
+	enum vidc_720p_interrupt_level_selection interrupt_sel;
+	u32 intr_mask = 0x0;
+
+	vcd_get_fw_property(VCD_FW_BOOTCODE, &fw_details);
+	vcd_get_fw_property(VCD_FW_ENDIAN, &fw_endianness);
+	if (fw_endianness == VCD_FW_BIG_ENDIAN)
+		dma_endian = VIDC_720P_BIG_ENDIAN;
+	else
+		dma_endian = VIDC_720P_LITTLE_ENDIAN;
+
+	interrupt_off = false;
+	interrupt_sel = VIDC_720P_INTERRUPT_LEVEL_SEL;
+
+	intr_mask |= VIDC_720P_INTR_BUFFER_FULL;
+	intr_mask |= VIDC_720P_INTR_FW_DONE;
+	intr_mask |= VIDC_720P_INTR_DMA_DONE;
+	intr_mask |= VIDC_720P_INTR_FRAME_DONE;
+
+	vidc_720p_do_sw_reset();
+
+	DBG_INFO("Loading CONTROL_FW of FW_SIZE %u\n",
+		fw_details.fw_size*4);
+
+	vidc_720p_init(&psz_version,
+			fw_details.fw_size,
+			fw_details.fw_buffer_addr,
+			dma_endian,
+			interrupt_off, interrupt_sel, intr_mask);
+	return;
+}
+
+void ddl_core_start_cpu(struct ddl_context *ddl_context)
+{
+	u32 fw_endianness;
+	enum vidc_720p_endian dma_endian;
+	u32 dbg_core_dump_buf_size = 0;
+
+	vcd_get_fw_property(VCD_FW_ENDIAN, &fw_endianness);
+	if (fw_endianness == VCD_FW_BIG_ENDIAN)
+		dma_endian = VIDC_720P_LITTLE_ENDIAN;
+	else
+		dma_endian = VIDC_720P_BIG_ENDIAN;
+
+	ddl_move_command_state(ddl_context, DDL_CMD_CPU_RESET);
+
+	DBG("VSP_BUF_ADDR_SIZE %d",
+		ddl_context->context_buf_addr.buffer_size);
+	if (ddl_context->enable_dbg_core_dump) {
+		dbg_core_dump_buf_size = ddl_context->dbg_core_dump.
+			buffer_size;
+	}
+
+	vidc_720p_start_cpu(dma_endian,
+		ddl_context->context_buf_addr.align_physical_addr,
+		ddl_context->dbg_core_dump.align_physical_addr,
+		dbg_core_dump_buf_size);
+
+	VIDC_DEBUG_REGISTER_LOG;
+}
+
+void ddl_channel_set(struct ddl_client_context *ddl)
+{
+	enum vidc_720p_enc_dec_selection enc_dec_sel;
+	enum vidc_720p_codec codec;
+	enum vcd_codec *vcd_codec;
+	u32 fw_property_id;
+	struct vcd_fw_details fw_details;
+
+	if (ddl->decoding) {
+		if (vidc_msg_timing)
+			ddl_set_core_start_time(__func__, DEC_OP_TIME);
+		enc_dec_sel = VIDC_720P_DECODER;
+		fw_property_id = VCD_FW_DECODE;
+		vcd_codec = &(ddl->codec_data.decoder.codec.codec);
+	} else {
+		enc_dec_sel = VIDC_720P_ENCODER;
+		fw_property_id = VCD_FW_ENCODE;
+		vcd_codec = &(ddl->codec_data.encoder.codec.codec);
+	}
+	switch (*vcd_codec) {
+	default:
+	case VCD_CODEC_MPEG4:
+		{
+			codec = VIDC_720P_MPEG4;
+
+		if (ddl->decoding) {
+			vidc_720p_decode_set_mpeg4_data_partitionbuffer
+				(ddl->ddl_context->data_partition_tempbuf.
+				 align_physical_addr);
+		}
+
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			codec = VIDC_720P_H264;
+			break;
+		}
+	case VCD_CODEC_DIVX_4:
+	case VCD_CODEC_DIVX_5:
+	case VCD_CODEC_DIVX_6:
+		{
+			codec = VIDC_720P_DIVX;
+			break;
+		}
+	case VCD_CODEC_XVID:
+		{
+			codec = VIDC_720P_XVID;
+			break;
+		}
+	case VCD_CODEC_H263:
+		{
+			codec = VIDC_720P_H263;
+			break;
+		}
+	case VCD_CODEC_MPEG2:
+		{
+			codec = VIDC_720P_MPEG2;
+			break;
+		}
+	case VCD_CODEC_VC1:
+	case VCD_CODEC_VC1_RCV:
+		{
+			codec = VIDC_720P_VC1;
+			break;
+		}
+	}
+
+	fw_details.codec = *vcd_codec;
+	vcd_get_fw_property(fw_property_id, &fw_details);
+	VIDC_DEBUG_REGISTER_LOG;
+
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_CHANNEL_SET);
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_CHDONE);
+
+	DBG_INFO("Loading firmware for CODEC:%u of FW_SIZE:%u\n",
+		fw_details.codec, fw_details.fw_size*4);
+
+	vidc_720p_set_channel(ddl->channel_id,
+			       enc_dec_sel,
+			       codec,
+			       fw_details.fw_buffer_addr,
+			       fw_details.fw_size);
+}
+
+void ddl_decode_init_codec(struct ddl_client_context *ddl)
+{
+	u32 seq_h = 0, seq_e = 0, start_byte_num = 0;
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	struct vcd_sequence_hdr *seq_hdr = &decoder->decode_config;
+	enum vidc_720p_memory_access_method mem_access_method;
+	if (vidc_msg_timing)
+		ddl_set_core_start_time(__func__, DEC_OP_TIME);
+	ddl_metadata_enable(ddl);
+
+	vidc_720p_decode_set_error_control(true);
+
+	vidc_720p_decode_set_mpeg4Post_filter(decoder->post_filter.
+					       post_filter);
+
+	if (decoder->codec.codec == VCD_CODEC_H264) {
+		vidc_720p_decode_setH264VSPBuffer(decoder->
+						   h264Vsp_temp_buffer.
+						   align_physical_addr);
+		VIDC_LOG1("VSP_BUF_ADDR_SIZE",
+			   decoder->h264Vsp_temp_buffer.buffer_size);
+	}
+
+	if (decoder->codec.codec == VCD_CODEC_VC1_RCV ||
+		decoder->codec.codec == VCD_CODEC_VC1) {
+		vidc_720p_set_frame_size(decoder->client_frame_size.width,
+			decoder->client_frame_size.height);
+	} else {
+		vidc_720p_set_frame_size(0x0, 0x0);
+	}
+
+	switch (decoder->buf_format.buffer_format) {
+	default:
+	case VCD_BUFFER_FORMAT_NV12:
+		{
+			mem_access_method = VIDC_720P_TILE_LINEAR;
+			break;
+		}
+	case VCD_BUFFER_FORMAT_TILE_4x2:
+		{
+			mem_access_method = VIDC_720P_TILE_64x32;
+			break;
+		}
+	}
+	VIDC_LOG_STRING("HEADER-PARSE-START");
+	VIDC_DEBUG_REGISTER_LOG;
+	seq_h = (u32) seq_hdr->sequence_header;
+	start_byte_num = 8 - (seq_h & DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+	seq_e = seq_h + seq_hdr->sequence_header_len;
+	seq_h &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+	DDL_PADDING_HACK(seq_e);
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_INITCODECDONE);
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_HEADER_PARSE);
+
+	vidc_720p_decode_bitstream_header(ddl->channel_id,
+		   seq_hdr->sequence_header_len,
+		   start_byte_num,
+		   seq_h,
+		   seq_e,
+		   mem_access_method,
+		   decoder->output_order);
+}
+
+void ddl_decode_dynamic_property(struct ddl_client_context *ddl,
+				 u32 enable)
+{
+	uint8_t *temp = NULL;
+	u32 extra_datastart = 0;
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	struct vcd_frame_data *bit_stream =
+	    &(ddl->input_frame.vcd_frm);
+
+	if (!enable) {
+		if (decoder->dynmic_prop_change_req) {
+			decoder->dynmic_prop_change_req = false;
+			vidc_720p_decode_dynamic_req_reset();
+		}
+		return;
+	}
+	if ((decoder->dynamic_prop_change &
+				DDL_DEC_REQ_OUTPUT_FLUSH)) {
+		decoder->dynmic_prop_change_req = true;
+		decoder->dynamic_prop_change &= ~(DDL_DEC_REQ_OUTPUT_FLUSH);
+		decoder->dpb_mask.hw_mask = 0;
+		vidc_720p_decode_dynamic_req_set(VIDC_720P_FLUSH_REQ);
+	}
+	if (((decoder->meta_data_enable_flag & VCD_METADATA_PASSTHROUGH))
+	    && ((VCD_FRAME_FLAG_EXTRADATA & bit_stream->flags))
+	    ) {
+
+		temp = ((uint8_t *)bit_stream->physical +
+					bit_stream->offset +
+					bit_stream->data_len + 3);
+
+		extra_datastart = (u32) ((u32)temp & ~3);
+		decoder->dynmic_prop_change_req = true;
+
+		vidc_720p_decode_setpassthrough_start(extra_datastart);
+
+		vidc_720p_decode_dynamic_req_set(VIDC_720P_EXTRADATA);
+	}
+}
+
+void ddl_encode_dynamic_property(struct ddl_client_context *ddl,
+				 u32 enable)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	u32 enc_param_change = 0;
+
+	if (!enable) {
+		if (encoder->dynmic_prop_change_req) {
+			encoder->dynmic_prop_change_req = false;
+			encoder->ext_enc_control_val &=
+				~(VIDC_720P_ENC_IFRAME_REQ);
+			vidc_720p_encode_set_control_param
+			(encoder->ext_enc_control_val);
+			vidc_720p_encoder_set_param_change(enc_param_change);
+		}
+		return;
+	}
+	if ((encoder->dynamic_prop_change & DDL_ENC_REQ_IFRAME)) {
+		encoder->dynamic_prop_change &= ~(DDL_ENC_REQ_IFRAME);
+		encoder->ext_enc_control_val |= VIDC_720P_ENC_IFRAME_REQ;
+		vidc_720p_encode_set_control_param
+		(encoder->ext_enc_control_val);
+	}
+	if ((encoder->dynamic_prop_change & DDL_ENC_CHANGE_BITRATE)) {
+		vidc_720p_encode_set_bit_rate(
+		encoder->target_bit_rate.target_bitrate);
+		enc_param_change |= VIDC_720P_ENC_BITRATE_CHANGE;
+		encoder->dynamic_prop_change &= ~(DDL_ENC_CHANGE_BITRATE);
+	}
+	if ((encoder->dynamic_prop_change & DDL_ENC_CHANGE_CIR)) {
+		vidc_720p_encode_set_intra_refresh_mb_number(
+			encoder->intra_refresh.cir_mb_number);
+		encoder->dynamic_prop_change &= ~(DDL_ENC_CHANGE_CIR);
+	}
+	if ((encoder->dynamic_prop_change & DDL_ENC_CHANGE_IPERIOD)) {
+		vidc_720p_encode_set_i_period
+			(encoder->i_period.p_frames);
+		enc_param_change |= VIDC_720P_ENC_IPERIOD_CHANGE;
+		encoder->dynamic_prop_change &= ~(DDL_ENC_CHANGE_IPERIOD);
+	}
+	if ((encoder->dynamic_prop_change &
+				DDL_ENC_CHANGE_FRAMERATE)) {
+		vidc_720p_encode_set_fps
+		    ((encoder->frame_rate.fps_numerator * 1000) /
+		     encoder->frame_rate.fps_denominator);
+		enc_param_change |= VIDC_720P_ENC_FRAMERATE_CHANGE;
+		encoder->dynamic_prop_change &= ~(DDL_ENC_CHANGE_FRAMERATE);
+	}
+	if (enc_param_change)
+		vidc_720p_encoder_set_param_change(enc_param_change);
+}
+
+static void ddl_encode_set_profile_level(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	u32 profile;
+	u32 level;
+
+	switch (encoder->profile.profile) {
+	default:
+	case VCD_PROFILE_MPEG4_SP:
+		{
+			profile = VIDC_720P_PROFILE_MPEG4_SP;
+			break;
+		}
+	case VCD_PROFILE_MPEG4_ASP:
+		{
+			profile = VIDC_720P_PROFILE_MPEG4_ASP;
+			break;
+		}
+	case VCD_PROFILE_H264_BASELINE:
+		{
+			profile = VIDC_720P_PROFILE_H264_CPB;
+			break;
+		}
+	case VCD_PROFILE_H264_MAIN:
+		{
+			profile = VIDC_720P_PROFILE_H264_MAIN;
+			break;
+		}
+	case VCD_PROFILE_H264_HIGH:
+		{
+			profile = VIDC_720P_PROFILE_H264_HIGH;
+			break;
+		}
+	case VCD_PROFILE_H263_BASELINE:
+		{
+			profile = VIDC_720P_PROFILE_H263_BASELINE;
+			break;
+		}
+	}
+	switch (encoder->level.level) {
+	default:
+	case VCD_LEVEL_MPEG4_0:
+		{
+			level = VIDC_720P_MPEG4_LEVEL0;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_0b:
+		{
+			level = VIDC_720P_MPEG4_LEVEL0b;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_1:
+		{
+			level = VIDC_720P_MPEG4_LEVEL1;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_2:
+		{
+			level = VIDC_720P_MPEG4_LEVEL2;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_3:
+		{
+			level = VIDC_720P_MPEG4_LEVEL3;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_3b:
+		{
+			level = VIDC_720P_MPEG4_LEVEL3b;
+			break;
+		}
+
+	case VCD_LEVEL_MPEG4_4:
+	case VCD_LEVEL_MPEG4_4a:
+		{
+			level = VIDC_720P_MPEG4_LEVEL4a;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_5:
+		{
+			level = VIDC_720P_MPEG4_LEVEL5;
+			break;
+		}
+	case VCD_LEVEL_MPEG4_6:
+		{
+			level = VIDC_720P_MPEG4_LEVEL6;
+			break;
+		}
+	case VCD_LEVEL_H264_1:
+		{
+			level = VIDC_720P_H264_LEVEL1;
+			break;
+		}
+	case VCD_LEVEL_H264_1b:
+		{
+			level = VIDC_720P_H264_LEVEL1b;
+			break;
+		}
+	case VCD_LEVEL_H264_1p1:
+		{
+			level = VIDC_720P_H264_LEVEL1p1;
+			break;
+		}
+	case VCD_LEVEL_H264_1p2:
+		{
+			level = VIDC_720P_H264_LEVEL1p2;
+			break;
+		}
+	case VCD_LEVEL_H264_1p3:
+		{
+			level = VIDC_720P_H264_LEVEL1p3;
+			break;
+		}
+	case VCD_LEVEL_H264_2:
+		{
+			level = VIDC_720P_H264_LEVEL2;
+			break;
+		}
+	case VCD_LEVEL_H264_2p1:
+		{
+			level = VIDC_720P_H264_LEVEL2p1;
+			break;
+		}
+	case VCD_LEVEL_H264_2p2:
+		{
+			level = VIDC_720P_H264_LEVEL2p2;
+			break;
+		}
+	case VCD_LEVEL_H264_3:
+		{
+			level = VIDC_720P_H264_LEVEL3;
+			break;
+		}
+	case VCD_LEVEL_H264_3p1:
+		{
+			level = VIDC_720P_H264_LEVEL3p1;
+			break;
+		}
+	case VCD_LEVEL_H263_10:
+		{
+			level = VIDC_720P_H263_LEVEL10;
+			break;
+		}
+	case VCD_LEVEL_H263_20:
+		{
+			level = VIDC_720P_H263_LEVEL20;
+			break;
+		}
+	case VCD_LEVEL_H263_30:
+		{
+			level = VIDC_720P_H263_LEVEL30;
+			break;
+		}
+	case VCD_LEVEL_H263_40:
+		{
+			level = VIDC_720P_H263_LEVEL40;
+			break;
+		}
+	case VCD_LEVEL_H263_45:
+		{
+			level = VIDC_720P_H263_LEVEL45;
+			break;
+		}
+	case VCD_LEVEL_H263_50:
+		{
+			level = VIDC_720P_H263_LEVEL50;
+			break;
+		}
+	case VCD_LEVEL_H263_60:
+		{
+			level = VIDC_720P_H263_LEVEL60;
+			break;
+		}
+	case VCD_LEVEL_H263_70:
+		{
+			level = VIDC_720P_H263_LEVEL70;
+			break;
+		}
+	}
+	vidc_720p_encode_set_profile(profile, level);
+}
+
+void ddl_encode_init_codec(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	enum vidc_720p_memory_access_method mem_access_method;
+	enum vidc_720p_DBConfig db_config;
+	enum vidc_720p_MSlice_selection m_slice_sel;
+
+	ddl_encode_set_profile_level(ddl);
+
+	vidc_720p_set_frame_size
+	    (encoder->frame_size.width, encoder->frame_size.height);
+	vidc_720p_encode_set_qp_params
+	    (encoder->qp_range.max_qp, encoder->qp_range.min_qp);
+	vidc_720p_encode_set_rc_config
+	    (encoder->rc_level.frame_level_rc,
+	     encoder->rc_level.mb_level_rc,
+	     encoder->session_qp.i_frame_qp,
+	     encoder->session_qp.p_frame_qp);
+
+	if (encoder->r_cframe_skip) {
+		if (encoder->vb_vbuffer_size) {
+			encoder->ext_enc_control_val = (0x2 << 0x2) |
+			(encoder->vb_vbuffer_size << 0x10);
+		} else
+			encoder->ext_enc_control_val = (0x1 << 2);
+	} else
+		encoder->ext_enc_control_val = 0;
+
+	vidc_720p_encode_set_fps
+	    ((encoder->frame_rate.fps_numerator * 1000) /
+	     encoder->frame_rate.fps_denominator);
+
+	vidc_720p_encode_set_vop_time(
+			encoder->vop_timing.vop_time_resolution, 0);
+
+	if (encoder->rc_level.frame_level_rc) {
+		vidc_720p_encode_set_bit_rate
+		    (encoder->target_bit_rate.target_bitrate);
+
+		vidc_720p_encode_set_frame_level_rc_params
+		    (encoder->frame_level_rc.reaction_coeff);
+	}
+	if (encoder->rc_level.mb_level_rc) {
+		vidc_720p_encode_set_mb_level_rc_params
+		    (encoder->adaptive_rc.dark_region_as_flag,
+		     encoder->adaptive_rc.smooth_region_as_flag,
+		     encoder->adaptive_rc.static_region_as_flag,
+		     encoder->adaptive_rc.activity_region_flag);
+	}
+	if (encoder->codec.codec == VCD_CODEC_MPEG4) {
+		vidc_720p_encode_set_short_header
+		    (encoder->short_header.short_header);
+
+		if (encoder->hdr_ext_control) {
+			vidc_720p_encode_set_hec_period
+			(encoder->hdr_ext_control);
+			encoder->ext_enc_control_val |= (0x1 << 0x1);
+		}
+	}
+	/* set extended encoder control settings */
+	vidc_720p_encode_set_control_param
+	(encoder->ext_enc_control_val);
+
+	if (encoder->codec.codec == VCD_CODEC_H264) {
+		enum vidc_720p_entropy_sel entropy_sel;
+		enum vidc_720p_cabac_model cabac_model_number;
+		switch (encoder->entropy_control.entropy_sel) {
+		default:
+		case VCD_ENTROPY_SEL_CAVLC:
+			{
+				entropy_sel = VIDC_720P_ENTROPY_SEL_CAVLC;
+				break;
+			}
+		case VCD_ENTROPY_SEL_CABAC:
+			{
+				entropy_sel = VIDC_720P_ENTROPY_SEL_CABAC;
+				break;
+			}
+		}
+		switch (encoder->entropy_control.cabac_model) {
+		default:
+		case VCD_CABAC_MODEL_NUMBER_0:
+			{
+				cabac_model_number =
+				    VIDC_720P_CABAC_MODEL_NUMBER_0;
+				break;
+			}
+		case VCD_CABAC_MODEL_NUMBER_1:
+			{
+				cabac_model_number =
+				    VIDC_720P_CABAC_MODEL_NUMBER_1;
+				break;
+			}
+		case VCD_CABAC_MODEL_NUMBER_2:
+			{
+				cabac_model_number =
+				    VIDC_720P_CABAC_MODEL_NUMBER_2;
+				break;
+			}
+		}
+		vidc_720p_encode_set_entropy_control
+		    (entropy_sel, cabac_model_number);
+		switch (encoder->db_control.db_config) {
+		default:
+		case VCD_DB_ALL_BLOCKING_BOUNDARY:
+			{
+				db_config =
+				    VIDC_720P_DB_ALL_BLOCKING_BOUNDARY;
+				break;
+			}
+		case VCD_DB_DISABLE:
+			{
+				db_config =
+				    VIDC_720P_DB_DISABLE;
+				break;
+			}
+		case VCD_DB_SKIP_SLICE_BOUNDARY:
+			{
+				db_config =
+				    VIDC_720P_DB_SKIP_SLICE_BOUNDARY;
+				break;
+			}
+		}
+		vidc_720p_encode_set_db_filter_control
+		    (db_config,
+		     encoder->db_control.slice_alpha_offset,
+		     encoder->db_control.slice_beta_offset);
+	}
+
+	vidc_720p_encode_set_intra_refresh_mb_number
+	    (encoder->intra_refresh.cir_mb_number);
+
+	switch (encoder->multi_slice.m_slice_sel) {
+	default:
+	case VCD_MSLICE_OFF:
+		m_slice_sel = VIDC_720P_MSLICE_OFF;
+		break;
+	case VCD_MSLICE_BY_MB_COUNT:
+		{
+			m_slice_sel = VIDC_720P_MSLICE_BY_MB_COUNT;
+			break;
+		}
+	case VCD_MSLICE_BY_BYTE_COUNT:
+		{
+			m_slice_sel = VIDC_720P_MSLICE_BY_BYTE_COUNT;
+			break;
+		}
+	case VCD_MSLICE_BY_GOB:
+		{
+			m_slice_sel = VIDC_720P_MSLICE_BY_GOB;
+			break;
+		}
+	}
+	vidc_720p_encode_set_multi_slice_info
+	    (m_slice_sel, encoder->multi_slice.m_slice_size);
+
+	vidc_720p_encode_set_dpb_buffer
+	    (encoder->enc_dpb_addr.align_physical_addr,
+			 encoder->enc_dpb_addr.buffer_size);
+
+	VIDC_LOG1("ENC_DPB_ADDR_SIZE", encoder->enc_dpb_addr.buffer_size);
+
+	vidc_720p_encode_set_i_period(encoder->i_period.p_frames);
+
+	ddl_metadata_enable(ddl);
+
+	if (encoder->seq_header.virtual_base_addr) {
+		u32 ext_buffer_start, ext_buffer_end, start_byte_num;
+		ext_buffer_start =
+		    (u32) encoder->seq_header.align_physical_addr;
+		ext_buffer_end =
+		    ext_buffer_start + encoder->seq_header.buffer_size;
+		start_byte_num =
+		    (ext_buffer_start & DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+		ext_buffer_start &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+		ext_buffer_end &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+		VIDC_LOG1("ENC_SEQHDR_ALLOC_SIZE",
+			   encoder->seq_header.buffer_size);
+		vidc_720p_encode_set_seq_header_buffer(ext_buffer_start,
+							ext_buffer_end,
+							start_byte_num);
+	}
+
+	if (encoder->re_con_buf_format.buffer_format ==
+		VCD_BUFFER_FORMAT_NV12)
+		mem_access_method = VIDC_720P_TILE_LINEAR;
+	else
+		mem_access_method = VIDC_720P_TILE_16x16;
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_INITCODECDONE);
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_INIT_CODEC);
+
+	vidc_720p_encode_init_codec(ddl->channel_id, mem_access_method);
+}
+
+void ddl_channel_end(struct ddl_client_context *ddl)
+{
+	VIDC_DEBUG_REGISTER_LOG;
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_CHEND);
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_CHANNEL_END);
+
+	vidc_720p_submit_command(ddl->channel_id, VIDC_720P_CMD_CHEND);
+}
+
+void ddl_encode_frame_run(struct ddl_client_context *ddl)
+{
+	u32 ext_buffer_start, ext_buffer_end;
+	u32 y_addr, c_addr;
+	u32 start_byte_number = 0;
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	struct vcd_frame_data *stream = &(ddl->output_frame.vcd_frm);
+
+	ext_buffer_start = (u32) stream->physical + stream->offset;
+	ext_buffer_end = ddl_encode_set_metadata_output_buf(ddl);
+	start_byte_number =
+	    (ext_buffer_start & DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+	if (start_byte_number) {
+		u32 upper_data, lower_data;
+		u32 *align_virtual_addr;
+		ext_buffer_start &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+		align_virtual_addr = (u32 *) (((u32) stream->virtual +
+						 stream->offset) -
+						start_byte_number);
+		upper_data = *align_virtual_addr;
+		align_virtual_addr++;
+		lower_data = *align_virtual_addr;
+		vidc_720p_encode_unalign_bitstream(upper_data, lower_data);
+	}
+
+	y_addr = (u32) ddl->input_frame.vcd_frm.physical +
+	    ddl->input_frame.vcd_frm.offset;
+	c_addr = (y_addr + (encoder->frame_size.scan_lines *
+				encoder->frame_size.stride));
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE);
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_ENCODE_FRAME);
+
+	if (encoder->dynamic_prop_change) {
+		encoder->dynmic_prop_change_req = true;
+		ddl_encode_dynamic_property(ddl, true);
+	}
+	vidc_720p_encode_set_vop_time(
+			encoder->vop_timing.vop_time_resolution,
+			ddl->input_frame.frm_delta
+	    );
+
+	vidc_720p_encode_frame(ddl->channel_id,
+			ext_buffer_start,
+				ext_buffer_end,
+				start_byte_number, y_addr, c_addr);
+}
+
+u32 ddl_decode_set_buffers(struct ddl_client_context *ddl)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	u32 comv_buf_size = DDL_COMV_BUFLINE_NO, comv_buf_no = 0;
+	u32 ref_buf_no = 0;
+	struct ddl_context  *ddl_ctxt = NULL;
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_DPB)) {
+		VIDC_LOG_STRING("STATE-CRITICAL");
+		return VCD_ERR_FAIL;
+	}
+	if (vidc_msg_timing)
+		ddl_set_core_start_time(__func__, DEC_OP_TIME);
+	switch (decoder->codec.codec) {
+	default:
+	case VCD_CODEC_DIVX_4:
+	case VCD_CODEC_DIVX_5:
+	case VCD_CODEC_DIVX_6:
+	case VCD_CODEC_XVID:
+	case VCD_CODEC_MPEG2:
+	case VCD_CODEC_MPEG4:
+		{
+			comv_buf_no = DDL_MPEG_COMV_BUF_NO;
+			ref_buf_no = DDL_MPEG_REFBUF_COUNT;
+			break;
+		}
+	case VCD_CODEC_H263:
+		{
+			comv_buf_no = DDL_H263_COMV_BUF_NO;
+			break;
+		}
+	case VCD_CODEC_VC1:
+	case VCD_CODEC_VC1_RCV:
+		{
+			comv_buf_no =
+			    decoder->client_output_buf_req.actual_count + 1;
+			comv_buf_size = DDL_VC1_COMV_BUFLINE_NO;
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			if (decoder->idr_only_decoding)
+				comv_buf_no = decoder->min_dpb_num;
+			else
+				comv_buf_no =
+					decoder->
+					client_output_buf_req.
+					actual_count;
+			break;
+		}
+	}
+
+	if (comv_buf_no) {
+		comv_buf_size *= (comv_buf_no *
+			(decoder->client_frame_size.stride >> 4) *
+			((decoder->client_frame_size.scan_lines >> 4) + 1));
+		if (decoder->dpb_comv_buffer.virtual_base_addr)
+			ddl_pmem_free(&decoder->dpb_comv_buffer);
+		ddl_pmem_alloc(&decoder->dpb_comv_buffer, comv_buf_size,
+			       DDL_LINEAR_BUFFER_ALIGN_BYTES);
+		if (!decoder->dpb_comv_buffer.virtual_base_addr) {
+			VIDC_LOGERR_STRING
+			    ("Dec_set_buf:Comv_buf_alloc_failed");
+			return VCD_ERR_ALLOC_FAIL;
+		}
+		vidc_720p_decode_set_comv_buffer(decoder->dpb_comv_buffer.
+						  align_physical_addr,
+						  decoder->dpb_comv_buffer.
+						  buffer_size);
+	}
+	decoder->ref_buffer.align_physical_addr = NULL;
+	if (ref_buf_no) {
+		size_t sz, align_bytes, y_sz, frm_sz;
+		u32 i = 0;
+		sz = decoder->dp_buf.dec_pic_buffers[0].vcd_frm.alloc_len;
+		frm_sz = sz;
+		y_sz = decoder->client_frame_size.height *
+				decoder->client_frame_size.width;
+		sz *= ref_buf_no;
+		align_bytes = decoder->client_output_buf_req.align;
+		if (decoder->ref_buffer.virtual_base_addr)
+			ddl_pmem_free(&decoder->ref_buffer);
+		ddl_pmem_alloc(&decoder->ref_buffer, sz, align_bytes);
+		if (!decoder->ref_buffer.virtual_base_addr) {
+			ddl_pmem_free(&decoder->dpb_comv_buffer);
+			VIDC_LOGERR_STRING
+			    ("Dec_set_buf:mpeg_ref_buf_alloc_failed");
+			return VCD_ERR_ALLOC_FAIL;
+		}
+		memset((u8 *)decoder->ref_buffer.virtual_base_addr,
+			0x80, sz);
+		for (i = 0; i < ref_buf_no; i++)
+			memset((u8 *)decoder->ref_buffer.align_virtual_addr +
+				i*frm_sz, 0x10, y_sz);
+	}
+	ddl_decode_set_metadata_output(decoder);
+	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_INIT);
+	ddl_ctxt = ddl_get_context();
+	vidc_720p_set_deblock_line_buffer(
+		ddl_ctxt->db_line_buffer.align_physical_addr,
+		ddl_ctxt->db_line_buffer.buffer_size);
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_DPBDONE);
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_DECODE_SET_DPB);
+
+	vidc_720p_submit_command(ddl->channel_id,
+		VIDC_720P_CMD_INITBUFFERS);
+	return VCD_S_SUCCESS;
+}
+
+void ddl_decode_frame_run(struct ddl_client_context *ddl)
+{
+	u32 ext_buffer_start = 0, ext_buffer_end = 0;
+	u32 start_byte_num = 8;
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+	struct vcd_frame_data *bit_stream =
+	    &(ddl->input_frame.vcd_frm);
+	if (vidc_msg_timing) {
+		ddl_set_core_start_time(__func__, DEC_OP_TIME);
+		ddl_set_core_start_time(__func__, DEC_IP_TIME);
+	}
+	if (!bit_stream->data_len ||
+		!bit_stream->physical) {
+		ddl_decode_eos_run(ddl);
+		return;
+	}
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE);
+
+	ddl_decode_dynamic_property(ddl, true);
+
+	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_SET_MASK);
+
+	ext_buffer_start = (u32)bit_stream->physical +
+		bit_stream->offset;
+	start_byte_num = 8 - (ext_buffer_start &
+		DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+	ext_buffer_end = ext_buffer_start + bit_stream->data_len;
+	ext_buffer_start &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+	DDL_PADDING_HACK(ext_buffer_end);
+
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_DECODE_FRAME);
+
+	vidc_720p_decode_frame(ddl->channel_id,
+			ext_buffer_start,
+			ext_buffer_end,
+			bit_stream->data_len,
+			start_byte_num, bit_stream->ip_frm_tag);
+}
+
+void  ddl_decode_eos_run(struct ddl_client_context *ddl)
+{
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_EOS_DONE);
+
+	ddl_decode_dynamic_property(ddl, true);
+
+	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_SET_MASK);
+
+	decoder->dynmic_prop_change_req = true;
+
+	ddl_move_command_state(ddl->ddl_context, DDL_CMD_EOS);
+
+	vidc_720p_issue_eos(ddl->channel_id);
+}
+
+u32 ddl_hal_engine_reset(struct ddl_context *ddl_context)
+{
+	u32 eng_reset;
+	u32 channel_id = 0;
+	u32 fw_endianness;
+	enum vidc_720p_endian dma_endian;
+	enum vidc_720p_interrupt_level_selection interrupt_sel;
+	u32 intr_mask = 0x0;
+
+	if (ddl_context->current_ddl)
+		channel_id = ddl_context->current_ddl->channel_id;
+
+	interrupt_sel = VIDC_720P_INTERRUPT_LEVEL_SEL;
+	/* Enable all the supported interrupt */
+	intr_mask |= VIDC_720P_INTR_BUFFER_FULL;
+	intr_mask |= VIDC_720P_INTR_FW_DONE;
+	intr_mask |= VIDC_720P_INTR_DMA_DONE;
+	intr_mask |= VIDC_720P_INTR_FRAME_DONE;
+
+	vcd_get_fw_property(VCD_FW_ENDIAN, &fw_endianness);
+	/* Reverse the endianness settings after boot code download */
+	if (fw_endianness == VCD_FW_BIG_ENDIAN)
+		dma_endian = VIDC_720P_LITTLE_ENDIAN;
+	else
+		dma_endian = VIDC_720P_BIG_ENDIAN;
+
+	/* Need to reset MFC silently */
+	eng_reset = vidc_720p_engine_reset(
+		channel_id,
+		dma_endian, interrupt_sel,
+		intr_mask);
+	if (!eng_reset) {
+		/* call the hw fatal callback if engine reset fails */
+		ddl_hw_fatal_cb(ddl_context);
+	}
+	return eng_reset ;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_helper.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_helper.c
new file mode 100644
index 0000000..b97fae6
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_helper.c
@@ -0,0 +1,297 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+
+DDL_INLINE struct ddl_context *ddl_get_context(void)
+{
+	static struct ddl_context ddl_context;
+	return &ddl_context;
+}
+
+DDL_INLINE void ddl_move_client_state(struct ddl_client_context *ddl,
+				      enum ddl_client_state client_state)
+{
+	ddl->client_state = client_state;
+}
+
+DDL_INLINE void ddl_move_command_state(struct ddl_context *ddl_context,
+				       enum ddl_cmd_state command_state)
+{
+	ddl_context->cmd_state = command_state;
+}
+
+u32 ddl_client_transact(u32 operation,
+			struct ddl_client_context **pddl_client)
+{
+	u32 ret_status = VCD_ERR_FAIL;
+	u32 counter;
+	struct ddl_context *ddl_context;
+
+	ddl_context = ddl_get_context();
+	switch (operation) {
+	case DDL_FREE_CLIENT:
+		{
+			if (pddl_client && *pddl_client) {
+				u32 channel_id;
+				channel_id = (*pddl_client)->channel_id;
+				if (channel_id < VCD_MAX_NO_CLIENT) {
+					ddl_context->
+					    ddl_clients[channel_id] = NULL;
+				} else {
+					VIDC_LOG_STRING("CHID_CORRUPTION");
+				}
+				DDL_FREE(*pddl_client);
+				ret_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_GET_CLIENT:
+		{
+			ret_status = VCD_ERR_MAX_CLIENT;
+			for (counter = 0; counter < VCD_MAX_NO_CLIENT &&
+			     ret_status == VCD_ERR_MAX_CLIENT; ++counter) {
+				if (!ddl_context->ddl_clients[counter]) {
+					*pddl_client =
+					    (struct ddl_client_context *)
+					    DDL_MALLOC(sizeof
+					       (struct ddl_client_context)
+					       );
+					if (!*pddl_client) {
+						ret_status = VCD_ERR_ALLOC_FAIL;
+					} else {
+						DDL_MEMSET(*pddl_client, 0,
+						   sizeof(struct
+						   ddl_client_context));
+						ddl_context->
+						    ddl_clients[counter] =
+						    *pddl_client;
+						(*pddl_client)->channel_id =
+						    counter;
+						(*pddl_client)->ddl_context =
+						    ddl_context;
+						ret_status = VCD_S_SUCCESS;
+					}
+				}
+			}
+			break;
+		}
+	case DDL_INIT_CLIENTS:
+		{
+			for (counter = 0; counter < VCD_MAX_NO_CLIENT;
+			     ++counter) {
+				ddl_context->ddl_clients[counter] = NULL;
+			}
+			ret_status = VCD_S_SUCCESS;
+			break;
+		}
+	case DDL_ACTIVE_CLIENT:
+		{
+			for (counter = 0; counter < VCD_MAX_NO_CLIENT;
+			     ++counter) {
+				if (ddl_context->ddl_clients[counter]) {
+					ret_status = VCD_S_SUCCESS;
+					break;
+				}
+			}
+			break;
+		}
+	default:
+		{
+			ret_status = VCD_ERR_ILLEGAL_PARM;
+			break;
+		}
+	}
+	return ret_status;
+}
+
+u32 ddl_decoder_dpb_transact(struct ddl_decoder_data *decoder,
+			     struct ddl_frame_data_tag *in_out_frame,
+			     u32 operation)
+{
+	u32 vcd_status = VCD_S_SUCCESS;
+	u32 loopc;
+	struct ddl_frame_data_tag *found_frame = NULL;
+	struct ddl_mask *dpb_mask = &decoder->dpb_mask;
+	u32 temp_mask;
+
+	switch (operation) {
+	case DDL_DPB_OP_MARK_BUSY:
+	case DDL_DPB_OP_MARK_FREE:
+		{
+			for (loopc = 0; !found_frame &&
+			     loopc < decoder->dp_buf.no_of_dec_pic_buf;
+			     ++loopc) {
+				if (in_out_frame->vcd_frm.physical ==
+				    decoder->dp_buf.
+				    dec_pic_buffers[loopc].vcd_frm.
+				    physical) {
+					found_frame =
+					    &(decoder->dp_buf.
+					      dec_pic_buffers[loopc]);
+					break;
+				}
+			}
+
+			if (found_frame) {
+				if (operation == DDL_DPB_OP_MARK_BUSY) {
+					temp_mask = (~(0x1 << loopc));
+					if (decoder->idr_only_decoding)
+						temp_mask = ~(0xffffffff);
+					dpb_mask->hw_mask &= temp_mask;
+					*in_out_frame = *found_frame;
+				} else if (operation ==
+					DDL_DPB_OP_MARK_FREE) {
+					temp_mask = (0x1 << loopc);
+					if (decoder->idr_only_decoding)
+						temp_mask = 0xffffffff;
+					dpb_mask->client_mask |= temp_mask;
+					*found_frame = *in_out_frame;
+				}
+			} else {
+				in_out_frame->vcd_frm.physical = NULL;
+				in_out_frame->vcd_frm.virtual = NULL;
+				vcd_status = VCD_ERR_BAD_POINTER;
+				VIDC_LOG_STRING("BUF_NOT_FOUND");
+			}
+			break;
+		}
+	case DDL_DPB_OP_SET_MASK:
+		{
+			dpb_mask->hw_mask |= dpb_mask->client_mask;
+			dpb_mask->client_mask = 0;
+			vidc_720p_decode_set_dpb_release_buffer_mask
+			    (dpb_mask->hw_mask);
+			break;
+		}
+	case DDL_DPB_OP_INIT:
+		{
+			u32 dpb_size, index, num_dpb;
+			dpb_size = (!decoder->meta_data_offset) ?
+			    decoder->dp_buf.dec_pic_buffers[0].vcd_frm.
+			    alloc_len : decoder->meta_data_offset;
+			if (decoder->idr_only_decoding)
+				num_dpb = decoder->min_dpb_num;
+			else
+				num_dpb = decoder->dp_buf.no_of_dec_pic_buf;
+			vidc_720p_decode_set_dpb_details(
+						  num_dpb,
+						  dpb_size,
+						  decoder->ref_buffer.
+						  align_physical_addr);
+			for (loopc = 0; loopc < num_dpb; ++loopc) {
+				if (decoder->idr_only_decoding)
+					index = 0;
+				else
+					index = loopc;
+				vidc_720p_decode_set_dpb_buffers(loopc,
+							  (u32 *)
+							  decoder->
+							  dp_buf.
+							  dec_pic_buffers
+							  [index].
+							  vcd_frm.
+							  physical);
+				VIDC_LOG1("DEC_DPB_BUFn_SIZE=%d",
+					   decoder->dp_buf.
+					   dec_pic_buffers[index].vcd_frm.
+					   alloc_len);
+			}
+			break;
+		}
+	case DDL_DPB_OP_RETRIEVE:
+		{
+			u32 position;
+			if (dpb_mask->client_mask) {
+				position = 0x1;
+				for (loopc = 0;
+				     loopc <
+				     decoder->dp_buf.no_of_dec_pic_buf
+				     && !found_frame; ++loopc) {
+					if (dpb_mask->
+					    client_mask & position) {
+						found_frame =
+						    &decoder->dp_buf.
+						    dec_pic_buffers[loopc];
+						dpb_mask->client_mask &=
+						    ~(position);
+					}
+					position <<= 1;
+				}
+			} else if (dpb_mask->hw_mask) {
+				position = 0x1;
+				for (loopc = 0;
+				     loopc <
+				     decoder->dp_buf.no_of_dec_pic_buf
+				     && !found_frame; ++loopc) {
+					if (dpb_mask->hw_mask
+							& position) {
+						found_frame =
+						    &decoder->dp_buf.
+						    dec_pic_buffers[loopc];
+						dpb_mask->hw_mask &=
+						    ~(position);
+					}
+					position <<= 1;
+				}
+			}
+			if (found_frame)
+				*in_out_frame = *found_frame;
+			else {
+				in_out_frame->vcd_frm.physical = NULL;
+				in_out_frame->vcd_frm.virtual = NULL;
+			}
+			break;
+		}
+	}
+	return vcd_status;
+}
+
+void ddl_release_context_buffers(struct ddl_context *ddl_context)
+{
+	ddl_pmem_free(&ddl_context->context_buf_addr);
+	ddl_pmem_free(&ddl_context->db_line_buffer);
+	ddl_pmem_free(&ddl_context->data_partition_tempbuf);
+	ddl_pmem_free(&ddl_context->metadata_shared_input);
+	ddl_pmem_free(&ddl_context->dbg_core_dump);
+
+	vcd_fw_release();
+}
+
+void ddl_release_client_internal_buffers(struct ddl_client_context *ddl)
+{
+	if (ddl->decoding) {
+		struct ddl_decoder_data *decoder =
+		    &(ddl->codec_data.decoder);
+		ddl_pmem_free(&decoder->h264Vsp_temp_buffer);
+		ddl_pmem_free(&decoder->dpb_comv_buffer);
+		ddl_pmem_free(&decoder->ref_buffer);
+		DDL_FREE(decoder->dp_buf.dec_pic_buffers);
+		ddl_decode_dynamic_property(ddl, false);
+		decoder->decode_config.sequence_header_len = 0;
+		decoder->decode_config.sequence_header = NULL;
+		decoder->dpb_mask.client_mask = 0;
+		decoder->dpb_mask.hw_mask = 0;
+		decoder->dp_buf.no_of_dec_pic_buf = 0;
+		decoder->dynamic_prop_change = 0;
+
+	} else {
+		struct ddl_encoder_data *encoder =
+		    &(ddl->codec_data.encoder);
+		ddl_pmem_free(&encoder->enc_dpb_addr);
+		ddl_pmem_free(&encoder->seq_header);
+		ddl_encode_dynamic_property(ddl, false);
+		encoder->dynamic_prop_change = 0;
+	}
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_internal_property.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_internal_property.h
new file mode 100644
index 0000000..32a4047
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_internal_property.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_INTERNAL_PROPERTY_H_
+#define _VCD_DDL_INTERNAL_PROPERTY_H_
+#include <media/msm/vcd_api.h>
+
+#define VCD_EVT_RESP_DDL_BASE          0x3000
+#define VCD_EVT_RESP_DEVICE_INIT       (VCD_EVT_RESP_DDL_BASE + 0x1)
+#define VCD_EVT_RESP_OUTPUT_REQ        (VCD_EVT_RESP_DDL_BASE + 0x2)
+#define VCD_EVT_RESP_EOS_DONE          (VCD_EVT_RESP_DDL_BASE + 0x3)
+#define VCD_EVT_RESP_TRANSACTION_PENDING (VCD_EVT_RESP_DDL_BASE + 0x4)
+
+#define VCD_S_DDL_ERR_BASE     0x90000000
+#define VCD_ERR_MAX_NO_CODEC   (VCD_S_DDL_ERR_BASE + 0x1)
+#define VCD_ERR_CLIENT_PRESENT (VCD_S_DDL_ERR_BASE + 0x2)
+#define VCD_ERR_CLIENT_FATAL   (VCD_S_DDL_ERR_BASE + 0x3)
+
+#define VCD_I_CUSTOM_BASE  (VCD_I_RESERVED_BASE)
+#define VCD_I_RC_LEVEL_CONFIG (VCD_I_CUSTOM_BASE + 0x1)
+#define VCD_I_FRAME_LEVEL_RC (VCD_I_CUSTOM_BASE + 0x2)
+#define VCD_I_ADAPTIVE_RC    (VCD_I_CUSTOM_BASE + 0x3)
+#define VCD_I_CUSTOM_DDL_BASE  (VCD_I_RESERVED_BASE + 0x100)
+#define DDL_I_INPUT_BUF_REQ  (VCD_I_CUSTOM_DDL_BASE + 0x1)
+#define DDL_I_OUTPUT_BUF_REQ (VCD_I_CUSTOM_DDL_BASE + 0x2)
+#define DDL_I_DPB       (VCD_I_CUSTOM_DDL_BASE + 0x3)
+#define DDL_I_DPB_RELEASE    (VCD_I_CUSTOM_DDL_BASE + 0x4)
+#define DDL_I_DPB_RETRIEVE  (VCD_I_CUSTOM_DDL_BASE + 0x5)
+#define DDL_I_REQ_OUTPUT_FLUSH   (VCD_I_CUSTOM_DDL_BASE + 0x6)
+#define DDL_I_SEQHDR_ALIGN_BYTES (VCD_I_CUSTOM_DDL_BASE + 0x7)
+#define DDL_I_SEQHDR_PRESENT (VCD_I_CUSTOM_DDL_BASE + 0xb)
+#define DDL_I_CAPABILITY    (VCD_I_CUSTOM_DDL_BASE + 0x8)
+#define DDL_I_FRAME_PROC_UNITS    (VCD_I_CUSTOM_DDL_BASE + 0x9)
+
+struct vcd_property_rc_level {
+	u32 frame_level_rc;
+	u32 mb_level_rc;
+};
+
+struct vcd_property_frame_level_rc_params {
+	u32 reaction_coeff;
+};
+
+struct vcd_property_adaptive_rc_params {
+	u32 dark_region_as_flag;
+	u32 smooth_region_as_flag;
+	u32 static_region_as_flag;
+	u32 activity_region_flag;
+};
+
+struct vcd_property_slice_delivery_info {
+	u32  enable;
+	u32  num_slices;
+	u32  num_slices_enc;
+};
+
+struct ddl_frame_data_tag;
+
+struct ddl_property_dec_pic_buffers {
+	struct ddl_frame_data_tag *dec_pic_buffers;
+	u32 no_of_dec_pic_buf;
+};
+
+struct ddl_property_capability {
+	u32 max_num_client;
+	u32 general_command_depth;
+	u32 frame_command_depth;
+	u32 exclusive;
+	u32   ddl_time_out_in_ms;
+};
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_interrupt_handler.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_interrupt_handler.c
new file mode 100644
index 0000000..817a98e
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_interrupt_handler.c
@@ -0,0 +1,1128 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vidc.h"
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_metadata.h"
+
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
+
+static void ddl_decoder_input_done_callback(
+	struct	ddl_client_context *ddl, u32 frame_transact_end);
+static u32 ddl_decoder_output_done_callback(
+	struct ddl_client_context *ddl, u32 frame_transact_end);
+
+static u32 ddl_get_frame
+    (struct vcd_frame_data *frame, u32 frame_type);
+
+static void ddl_getdec_profilelevel
+(struct ddl_decoder_data   *decoder, u32 profile, u32 level);
+
+static void ddl_dma_done_callback(struct ddl_context *ddl_context)
+{
+	if (!DDLCOMMAND_STATE_IS(ddl_context, DDL_CMD_DMA_INIT)) {
+		VIDC_LOGERR_STRING("UNKWN_DMADONE");
+		return;
+	}
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	VIDC_LOG_STRING("DMA_DONE");
+	ddl_core_start_cpu(ddl_context);
+}
+
+static void ddl_cpu_started_callback(struct ddl_context *ddl_context)
+{
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	VIDC_LOG_STRING("CPU-STARTED");
+
+	if (!vidc_720p_cpu_start()) {
+		ddl_hw_fatal_cb(ddl_context);
+		return;
+	}
+
+	vidc_720p_set_deblock_line_buffer(
+			ddl_context->db_line_buffer.align_physical_addr,
+			ddl_context->db_line_buffer.buffer_size);
+	ddl_context->device_state = DDL_DEVICE_INITED;
+	ddl_context->ddl_callback(VCD_EVT_RESP_DEVICE_INIT, VCD_S_SUCCESS,
+			NULL, 0, NULL, ddl_context->client_data);
+	DDL_IDLE(ddl_context);
+}
+
+
+static u32 ddl_eos_done_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	u32 displaystatus, resl_change;
+
+	if (!DDLCOMMAND_STATE_IS(ddl_context, DDL_CMD_EOS)) {
+		VIDC_LOGERR_STRING("UNKWN_EOSDONE");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+
+	if (!ddl ||
+		!ddl->decoding ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_EOS_DONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-EOSDONE");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	vidc_720p_eos_info(&displaystatus, &resl_change);
+	if ((enum vidc_720p_display_status)displaystatus
+		!= VIDC_720P_EMPTY_BUFFER) {
+		VIDC_LOG_STRING("EOSDONE-EMPTYBUF-ISSUE");
+	}
+
+	ddl_decode_dynamic_property(ddl, false);
+	if (resl_change == 0x1) {
+		ddl->codec_data.decoder.header_in_start = false;
+		ddl->codec_data.decoder.decode_config.sequence_header =
+			ddl->input_frame.vcd_frm.physical;
+		ddl->codec_data.decoder.decode_config.sequence_header_len =
+			ddl->input_frame.vcd_frm.data_len;
+		ddl_decode_init_codec(ddl);
+		return false;
+	}
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+	VIDC_LOG_STRING("EOS_DONE");
+	ddl_context->ddl_callback(VCD_EVT_RESP_EOS_DONE, VCD_S_SUCCESS,
+		NULL, 0, (u32 *) ddl, ddl_context->client_data);
+	DDL_IDLE(ddl_context);
+
+	return true;
+}
+
+static u32 ddl_channel_set_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	u32 return_status = false;
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	VIDC_DEBUG_REGISTER_LOG;
+
+	if (!ddl ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_CHDONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-CHSET");
+		DDL_IDLE(ddl_context);
+		return return_status;
+	}
+	VIDC_LOG_STRING("Channel-set");
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_INITCODEC);
+
+	if (ddl->decoding) {
+		if (vidc_msg_timing)
+			ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+		if (ddl->codec_data.decoder.header_in_start) {
+			ddl_decode_init_codec(ddl);
+		} else {
+			ddl_context->ddl_callback(VCD_EVT_RESP_START,
+				VCD_S_SUCCESS, NULL,
+				0, (u32 *) ddl,
+				ddl_context->client_data);
+
+			DDL_IDLE(ddl_context);
+			return_status = true;
+		}
+	} else {
+		ddl_encode_init_codec(ddl);
+	}
+	return return_status;
+}
+
+static void ddl_init_codec_done_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_encoder_data *encoder;
+
+	if (!ddl ||
+		ddl->decoding ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_INITCODECDONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-INITCODEC");
+		ddl_client_fatal_cb(ddl_context);
+		return;
+	}
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+	VIDC_LOG_STRING("INIT_CODEC_DONE");
+
+	encoder = &ddl->codec_data.encoder;
+	if (encoder->seq_header.virtual_base_addr) {
+		vidc_720p_encode_get_header(&encoder->seq_header.
+			buffer_size);
+	}
+
+	ddl_context->ddl_callback(VCD_EVT_RESP_START, VCD_S_SUCCESS, NULL,
+		0, (u32 *) ddl, ddl_context->client_data);
+
+	DDL_IDLE(ddl_context);
+}
+
+static u32 ddl_header_done_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_decoder_data *decoder;
+	struct vidc_720p_seq_hdr_info seq_hdr_info;
+
+	u32 process_further = true;
+	u32 seq_hdr_only_frame = false;
+	u32 need_reconfig = true;
+	struct vcd_frame_data *input_vcd_frm;
+	struct ddl_frame_data_tag *reconfig_payload = NULL;
+	u32 reconfig_payload_size = 0;
+
+	if (!ddl ||
+		!ddl->decoding ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_INITCODECDONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-HDDONE");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+	if (vidc_msg_timing)
+		ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_DPB);
+	VIDC_LOG_STRING("HEADER_DONE");
+	VIDC_DEBUG_REGISTER_LOG;
+
+	vidc_720p_decode_get_seq_hdr_info(&seq_hdr_info);
+
+	decoder = &(ddl->codec_data.decoder);
+	decoder->frame_size.width = seq_hdr_info.img_size_x;
+	decoder->frame_size.height = seq_hdr_info.img_size_y;
+	decoder->min_dpb_num = seq_hdr_info.min_num_dpb;
+	decoder->y_cb_cr_size = seq_hdr_info.min_dpb_size;
+	decoder->progressive_only = 1 - seq_hdr_info.progressive;
+	if (!seq_hdr_info.img_size_x || !seq_hdr_info.img_size_y) {
+		VIDC_LOGERR_STRING("FATAL: ZeroImageSize");
+		ddl_client_fatal_cb(ddl_context);
+		return process_further;
+	}
+	if (seq_hdr_info.data_partitioned == 0x1 &&
+		decoder->codec.codec == VCD_CODEC_MPEG4 &&
+		seq_hdr_info.img_size_x > DDL_MAX_DP_FRAME_WIDTH &&
+		seq_hdr_info.img_size_y > DDL_MAX_DP_FRAME_HEIGHT)	{
+		ddl_client_fatal_cb(ddl_context);
+		return process_further;
+	}
+	ddl_getdec_profilelevel(decoder, seq_hdr_info.profile,
+		seq_hdr_info.level);
+	ddl_calculate_stride(&decoder->frame_size,
+			!decoder->progressive_only,
+			decoder->codec.codec);
+	if (decoder->buf_format.buffer_format == VCD_BUFFER_FORMAT_TILE_4x2) {
+		decoder->frame_size.stride =
+		DDL_TILE_ALIGN(decoder->frame_size.width,
+					DDL_TILE_ALIGN_WIDTH);
+		decoder->frame_size.scan_lines =
+			DDL_TILE_ALIGN(decoder->frame_size.height,
+						 DDL_TILE_ALIGN_HEIGHT);
+	}
+	if (seq_hdr_info.crop_exists)	{
+		decoder->frame_size.width -=
+		(seq_hdr_info.crop_right_offset
+		+ seq_hdr_info.crop_left_offset);
+		decoder->frame_size.height -=
+		(seq_hdr_info.crop_top_offset +
+		seq_hdr_info.crop_bottom_offset);
+	}
+	ddl_set_default_decoder_buffer_req(decoder, false);
+
+	if (decoder->header_in_start) {
+		decoder->client_frame_size = decoder->frame_size;
+		decoder->client_output_buf_req =
+			decoder->actual_output_buf_req;
+		decoder->client_input_buf_req =
+			decoder->actual_input_buf_req;
+		ddl_context->ddl_callback(VCD_EVT_RESP_START, VCD_S_SUCCESS,
+			NULL, 0, (u32 *) ddl,	ddl_context->client_data);
+		DDL_IDLE(ddl_context);
+	} else {
+		DBG("%s(): Client data: WxH(%u x %u) SxSL(%u x %u) Sz(%u)\n",
+			__func__, decoder->client_frame_size.width,
+			decoder->client_frame_size.height,
+			decoder->client_frame_size.stride,
+			decoder->client_frame_size.scan_lines,
+			decoder->client_output_buf_req.sz);
+		DBG("%s(): DDL data: WxH(%u x %u) SxSL(%u x %u) Sz(%u)\n",
+			__func__, decoder->frame_size.width,
+			decoder->frame_size.height,
+			decoder->frame_size.stride,
+			decoder->frame_size.scan_lines,
+			decoder->actual_output_buf_req.sz);
+		DBG("%s(): min_dpb_num = %d actual_count = %d\n", __func__,
+			decoder->min_dpb_num,
+			decoder->client_output_buf_req.actual_count);
+
+		input_vcd_frm = &(ddl->input_frame.vcd_frm);
+
+		if (decoder->frame_size.width ==
+			decoder->client_frame_size.width
+			&& decoder->frame_size.height ==
+			decoder->client_frame_size.height
+			&& decoder->frame_size.stride ==
+			decoder->client_frame_size.stride
+			&& decoder->frame_size.scan_lines ==
+			decoder->client_frame_size.scan_lines
+			&& decoder->actual_output_buf_req.sz <=
+			decoder->client_output_buf_req.sz
+			&& decoder->actual_output_buf_req.actual_count <=
+			decoder->client_output_buf_req.actual_count
+			&& decoder->progressive_only)
+			need_reconfig = false;
+		if ((input_vcd_frm->data_len <= seq_hdr_info.dec_frm_size ||
+			 (input_vcd_frm->flags & VCD_FRAME_FLAG_CODECCONFIG)) &&
+			(!need_reconfig ||
+			 !(input_vcd_frm->flags & VCD_FRAME_FLAG_EOS))) {
+			input_vcd_frm->flags |=
+				VCD_FRAME_FLAG_CODECCONFIG;
+			seq_hdr_only_frame = true;
+			input_vcd_frm->data_len = 0;
+			ddl->input_frame.frm_trans_end = !need_reconfig;
+			ddl_context->ddl_callback(
+				VCD_EVT_RESP_INPUT_DONE,
+				VCD_S_SUCCESS, &ddl->input_frame,
+				sizeof(struct ddl_frame_data_tag),
+				(u32 *) ddl,
+				ddl->ddl_context->client_data);
+		} else if (decoder->codec.codec != VCD_CODEC_H263) {
+			input_vcd_frm->offset += seq_hdr_info.dec_frm_size;
+			input_vcd_frm->data_len -= seq_hdr_info.dec_frm_size;
+		}
+		if (need_reconfig) {
+			decoder->client_frame_size = decoder->frame_size;
+			decoder->client_output_buf_req =
+				decoder->actual_output_buf_req;
+			decoder->client_input_buf_req =
+				decoder->actual_input_buf_req;
+			if (!seq_hdr_only_frame) {
+				reconfig_payload = &ddl->input_frame;
+				reconfig_payload_size =
+					sizeof(struct ddl_frame_data_tag);
+			}
+			ddl_context->ddl_callback(VCD_EVT_IND_OUTPUT_RECONFIG,
+					VCD_S_SUCCESS, reconfig_payload,
+					reconfig_payload_size,
+					(u32 *) ddl,
+					ddl_context->client_data);
+		}
+		if (!need_reconfig && !seq_hdr_only_frame) {
+			if (ddl_decode_set_buffers(ddl) == VCD_S_SUCCESS)
+				process_further = false;
+			else
+				ddl_client_fatal_cb(ddl_context);
+		} else
+			DDL_IDLE(ddl_context);
+	}
+	return process_further;
+}
+
+static u32 ddl_dpb_buffers_set_done_callback(struct ddl_context
+						  *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	if (!ddl ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_DPBDONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-DPBDONE");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+	if (vidc_msg_timing) {
+		ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+		ddl_reset_core_time_variables(DEC_OP_TIME);
+	}
+	VIDC_LOG_STRING("INTR_DPBDONE");
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+	ddl->codec_data.decoder.dec_disp_info.img_size_x = 0;
+	ddl->codec_data.decoder.dec_disp_info.img_size_y = 0;
+	ddl_decode_frame_run(ddl);
+	return false;
+}
+
+static void ddl_encoder_frame_run_callback(struct ddl_context
+					   *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	u32 eos_present = false;
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-ENCFRMRUN");
+		ddl_client_fatal_cb(ddl_context);
+		return;
+	}
+
+	VIDC_LOG_STRING("ENC_FRM_RUN_DONE");
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	vidc_720p_enc_frame_info(&encoder->enc_frame_info);
+
+	ddl->output_frame.vcd_frm.ip_frm_tag =
+		ddl->input_frame.vcd_frm.ip_frm_tag;
+	ddl->output_frame.vcd_frm.data_len =
+		encoder->enc_frame_info.enc_size;
+	ddl->output_frame.vcd_frm.flags |= VCD_FRAME_FLAG_ENDOFFRAME;
+	ddl_get_frame
+		(&(ddl->output_frame.vcd_frm),
+		 encoder->enc_frame_info.frame);
+	ddl_process_encoder_metadata(ddl);
+
+	ddl_encode_dynamic_property(ddl, false);
+
+	ddl->input_frame.frm_trans_end = false;
+	ddl_context->ddl_callback(VCD_EVT_RESP_INPUT_DONE, VCD_S_SUCCESS,
+		&(ddl->input_frame), sizeof(struct ddl_frame_data_tag),
+		(u32 *) ddl, ddl_context->client_data);
+
+	if (vidc_msg_timing)
+		ddl_calc_core_proc_time(__func__, ENC_OP_TIME);
+
+	/* check the presence of EOS */
+   eos_present =
+	((VCD_FRAME_FLAG_EOS & ddl->input_frame.vcd_frm.flags));
+
+	ddl->output_frame.frm_trans_end = !eos_present;
+	ddl_context->ddl_callback(VCD_EVT_RESP_OUTPUT_DONE, VCD_S_SUCCESS,
+		&(ddl->output_frame),	sizeof(struct ddl_frame_data_tag),
+		(u32 *) ddl, ddl_context->client_data);
+
+	if (eos_present) {
+		VIDC_LOG_STRING("ENC-EOS_DONE");
+		ddl_context->ddl_callback(VCD_EVT_RESP_EOS_DONE,
+				VCD_S_SUCCESS, NULL, 0,	(u32 *)ddl,
+				ddl_context->client_data);
+	}
+
+	ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+	DDL_IDLE(ddl_context);
+}
+
+static u32 ddl_decoder_frame_run_callback(struct ddl_context
+					   *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct vidc_720p_dec_disp_info *dec_disp_info =
+	    &(ddl->codec_data.decoder.dec_disp_info);
+	u32 callback_end = false;
+	u32 status = true, eos_present = false;;
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE)) {
+		VIDC_LOG_STRING("STATE-CRITICAL-DECFRMRUN");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+
+	VIDC_LOG_STRING("DEC_FRM_RUN_DONE");
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	vidc_720p_decode_display_info(dec_disp_info);
+
+	ddl_decode_dynamic_property(ddl, false);
+
+	if (dec_disp_info->resl_change) {
+		VIDC_LOG_STRING
+			("DEC_FRM_RUN_DONE: RECONFIG");
+		ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_EOS_DONE);
+		ddl_move_command_state(ddl_context, DDL_CMD_EOS);
+		vidc_720p_submit_command(ddl->channel_id,
+			VIDC_720P_CMD_FRAMERUN_REALLOCATE);
+		return false;
+	}
+
+	if ((VCD_FRAME_FLAG_EOS & ddl->input_frame.vcd_frm.flags)) {
+		callback_end = false;
+		eos_present = true;
+	}
+
+
+	if (dec_disp_info->disp_status == VIDC_720P_DECODE_ONLY ||
+		dec_disp_info->disp_status
+			== VIDC_720P_DECODE_AND_DISPLAY) {
+		if (!eos_present)
+			callback_end = (dec_disp_info->disp_status
+					== VIDC_720P_DECODE_ONLY);
+
+	  ddl_decoder_input_done_callback(ddl, callback_end);
+	}
+
+	if (dec_disp_info->disp_status == VIDC_720P_DECODE_AND_DISPLAY
+		|| dec_disp_info->disp_status == VIDC_720P_DISPLAY_ONLY) {
+		if (!eos_present)
+			callback_end =
+			(dec_disp_info->disp_status
+				== VIDC_720P_DECODE_AND_DISPLAY);
+
+		if (ddl_decoder_output_done_callback(ddl, callback_end)
+			!= VCD_S_SUCCESS)
+			return true;
+	}
+
+	if (dec_disp_info->disp_status ==  VIDC_720P_DISPLAY_ONLY ||
+		dec_disp_info->disp_status ==  VIDC_720P_EMPTY_BUFFER) {
+		/* send the same input once again for decoding */
+		ddl_decode_frame_run(ddl);
+		/* client need to ignore the interrupt */
+		status = false;
+	} else if (eos_present) {
+		/* send EOS command to HW */
+		ddl_decode_eos_run(ddl);
+		/* client need to ignore the interrupt */
+		status = false;
+	} else {
+		ddl_move_client_state(ddl, DDL_CLIENT_WAIT_FOR_FRAME);
+		/* move to Idle */
+		DDL_IDLE(ddl_context);
+	}
+	return status;
+}
+
+static u32 ddl_eos_frame_done_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl = ddl_context->current_ddl;
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	struct vidc_720p_dec_disp_info *dec_disp_info =
+		&(decoder->dec_disp_info);
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_EOS_DONE)) {
+		VIDC_LOGERR_STRING("STATE-CRITICAL-EOSFRMRUN");
+		ddl_client_fatal_cb(ddl_context);
+		return true;
+	}
+	VIDC_LOG_STRING("EOS_FRM_RUN_DONE");
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+
+	vidc_720p_decode_display_info(dec_disp_info);
+
+	ddl_decode_dynamic_property(ddl, false);
+
+	if (dec_disp_info->disp_status == VIDC_720P_DISPLAY_ONLY) {
+		if (ddl_decoder_output_done_callback(ddl, false)
+			!= VCD_S_SUCCESS)
+			return true;
+	} else
+		VIDC_LOG_STRING("STATE-CRITICAL-WRONG-DISP-STATUS");
+
+	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_SET_MASK);
+	ddl_move_command_state(ddl_context, DDL_CMD_EOS);
+	vidc_720p_submit_command(ddl->channel_id,
+		VIDC_720P_CMD_FRAMERUN);
+	return false;
+}
+
+static void ddl_channel_end_callback(struct ddl_context *ddl_context)
+{
+	struct ddl_client_context *ddl;
+
+	ddl_move_command_state(ddl_context, DDL_CMD_INVALID);
+	VIDC_LOG_STRING("CH_END_DONE");
+
+	ddl = ddl_context->current_ddl;
+	if (!ddl ||
+		!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_CHEND)
+		) {
+		VIDC_LOG_STRING("STATE-CRITICAL-CHEND");
+		DDL_IDLE(ddl_context);
+		return;
+	}
+
+	ddl_release_client_internal_buffers(ddl);
+	ddl_context->ddl_callback(VCD_EVT_RESP_STOP, VCD_S_SUCCESS,
+		NULL, 0, (u32 *) ddl,	ddl_context->client_data);
+	ddl_move_client_state(ddl, DDL_CLIENT_OPEN);
+	DDL_IDLE(ddl_context);
+}
+
+static u32 ddl_operation_done_callback(struct ddl_context *ddl_context)
+{
+	u32 return_status = true;
+
+	switch (ddl_context->cmd_state) {
+	case DDL_CMD_DECODE_FRAME:
+		{
+			return_status = ddl_decoder_frame_run_callback(
+				ddl_context);
+			break;
+		}
+	case DDL_CMD_ENCODE_FRAME:
+		{
+			ddl_encoder_frame_run_callback(ddl_context);
+			break;
+		}
+	case DDL_CMD_CHANNEL_SET:
+		{
+			return_status = ddl_channel_set_callback(
+				ddl_context);
+			break;
+		}
+	case DDL_CMD_INIT_CODEC:
+		{
+			ddl_init_codec_done_callback(ddl_context);
+			break;
+		}
+	case DDL_CMD_HEADER_PARSE:
+		{
+			return_status = ddl_header_done_callback(
+				ddl_context);
+			break;
+		}
+	case DDL_CMD_DECODE_SET_DPB:
+		{
+			return_status = ddl_dpb_buffers_set_done_callback(
+				ddl_context);
+			break;
+		}
+	case DDL_CMD_CHANNEL_END:
+		{
+			ddl_channel_end_callback(ddl_context);
+			break;
+		}
+	case DDL_CMD_EOS:
+		{
+			return_status = ddl_eos_frame_done_callback(
+				ddl_context);
+			break;
+		}
+	case DDL_CMD_CPU_RESET:
+		{
+			ddl_cpu_started_callback(ddl_context);
+			break;
+		}
+	default:
+		{
+			VIDC_LOG_STRING("UNKWN_OPDONE");
+			return_status = false;
+			break;
+		}
+	}
+	return return_status;
+}
+
+static u32 ddl_process_intr_status(struct ddl_context *ddl_context,
+			u32 int_status)
+{
+	u32 status = true;
+	switch (int_status) {
+	case VIDC_720P_INTR_FRAME_DONE:
+		 {
+			status = ddl_operation_done_callback(ddl_context);
+			break;
+		 }
+	case VIDC_720P_INTR_DMA_DONE:
+		 {
+			ddl_dma_done_callback(ddl_context);
+			status = false;
+			break;
+		 }
+	case VIDC_720P_INTR_FW_DONE:
+		 {
+			status = ddl_eos_done_callback(ddl_context);
+			break;
+		 }
+	case VIDC_720P_INTR_BUFFER_FULL:
+		 {
+			VIDC_LOGERR_STRING("BUF_FULL_INTR");
+			ddl_hw_fatal_cb(ddl_context);
+			break;
+		 }
+	default:
+		 {
+			VIDC_LOGERR_STRING("UNKWN_INTR");
+			break;
+		 }
+	}
+	return status;
+}
+
+void ddl_read_and_clear_interrupt(void)
+{
+	struct ddl_context *ddl_context;
+
+	ddl_context = ddl_get_context();
+	if (!ddl_context->core_virtual_base_addr) {
+		VIDC_LOGERR_STRING("SPURIOUS_INTERRUPT");
+		return;
+	}
+	vidc_720p_get_interrupt_status(&ddl_context->intr_status,
+		&ddl_context->cmd_err_status,
+		&ddl_context->disp_pic_err_status,
+		&ddl_context->op_failed
+	);
+
+	vidc_720p_interrupt_done_clear();
+
+}
+
+u32 ddl_process_core_response(void)
+{
+	struct ddl_context *ddl_context;
+	u32 return_status = true;
+
+	ddl_context = ddl_get_context();
+	if (!ddl_context->core_virtual_base_addr) {
+		VIDC_LOGERR_STRING("UNKWN_INTR");
+		return false;
+	}
+
+	if (!ddl_handle_core_errors(ddl_context)) {
+		return_status = ddl_process_intr_status(ddl_context,
+			ddl_context->intr_status);
+	}
+
+	if (ddl_context->interrupt_clr)
+		(*ddl_context->interrupt_clr)();
+
+	return return_status;
+}
+
+static void ddl_decoder_input_done_callback(
+	struct	ddl_client_context *ddl, u32 frame_transact_end)
+{
+	struct vidc_720p_dec_disp_info *dec_disp_info =
+		&(ddl->codec_data.decoder.dec_disp_info);
+	struct vcd_frame_data *input_vcd_frm =
+		&(ddl->input_frame.vcd_frm);
+	ddl_get_frame(input_vcd_frm, dec_disp_info->
+		input_frame);
+
+	input_vcd_frm->interlaced = (dec_disp_info->
+		input_is_interlace);
+
+	input_vcd_frm->offset += dec_disp_info->input_bytes_consumed;
+	input_vcd_frm->data_len -= dec_disp_info->input_bytes_consumed;
+
+	ddl->input_frame.frm_trans_end = frame_transact_end;
+	if (vidc_msg_timing)
+		ddl_calc_core_proc_time(__func__, DEC_IP_TIME);
+	ddl->ddl_context->ddl_callback(
+		VCD_EVT_RESP_INPUT_DONE,
+		VCD_S_SUCCESS,
+		&ddl->input_frame,
+		sizeof(struct ddl_frame_data_tag),
+		(void *)ddl,
+		ddl->ddl_context->client_data);
+}
+
+static u32 ddl_decoder_output_done_callback(
+	struct ddl_client_context *ddl,
+	u32 frame_transact_end)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	struct vidc_720p_dec_disp_info *dec_disp_info =
+		&(decoder->dec_disp_info);
+	struct ddl_frame_data_tag *output_frame =
+		&ddl->output_frame;
+	struct vcd_frame_data *output_vcd_frm =
+		&(output_frame->vcd_frm);
+	u32 vcd_status;
+	u32 free_luma_dpb = 0;
+
+	output_vcd_frm->physical = (u8 *)dec_disp_info->y_addr;
+
+	if (decoder->codec.codec == VCD_CODEC_MPEG4 ||
+		decoder->codec.codec == VCD_CODEC_VC1 ||
+		decoder->codec.codec == VCD_CODEC_VC1_RCV ||
+		(decoder->codec.codec >= VCD_CODEC_DIVX_3 &&
+		 decoder->codec.codec <= VCD_CODEC_XVID)){
+		vidc_720p_decode_skip_frm_details(&free_luma_dpb);
+		if (free_luma_dpb)
+			output_vcd_frm->physical = (u8 *) free_luma_dpb;
+	}
+
+
+	vcd_status = ddl_decoder_dpb_transact(
+			decoder,
+			output_frame,
+			DDL_DPB_OP_MARK_BUSY);
+
+	if (vcd_status != VCD_S_SUCCESS) {
+		VIDC_LOGERR_STRING("CorruptedOutputBufferAddress");
+		ddl_hw_fatal_cb(ddl->ddl_context);
+		return vcd_status;
+	}
+
+	output_vcd_frm->ip_frm_tag =  dec_disp_info->tag_top;
+	if (dec_disp_info->crop_exists == 0x1) {
+		output_vcd_frm->dec_op_prop.disp_frm.left =
+			dec_disp_info->crop_left_offset;
+		output_vcd_frm->dec_op_prop.disp_frm.top =
+			dec_disp_info->crop_top_offset;
+		output_vcd_frm->dec_op_prop.disp_frm.right =
+			dec_disp_info->img_size_x -
+			dec_disp_info->crop_right_offset;
+		output_vcd_frm->dec_op_prop.disp_frm.bottom =
+			dec_disp_info->img_size_y -
+			dec_disp_info->crop_bottom_offset;
+	} else {
+		output_vcd_frm->dec_op_prop.disp_frm.left = 0;
+		output_vcd_frm->dec_op_prop.disp_frm.top = 0;
+		output_vcd_frm->dec_op_prop.disp_frm.right =
+			dec_disp_info->img_size_x;
+		output_vcd_frm->dec_op_prop.disp_frm.bottom =
+			dec_disp_info->img_size_y;
+	}
+	if (!dec_disp_info->disp_is_interlace) {
+		output_vcd_frm->interlaced = false;
+		output_vcd_frm->intrlcd_ip_frm_tag = VCD_FRAMETAG_INVALID;
+	} else {
+		output_vcd_frm->interlaced = true;
+		output_vcd_frm->intrlcd_ip_frm_tag =
+			dec_disp_info->tag_bottom;
+	}
+
+	output_vcd_frm->offset = 0;
+	output_vcd_frm->data_len = decoder->y_cb_cr_size;
+	if (free_luma_dpb) {
+		output_vcd_frm->data_len = 0;
+		output_vcd_frm->flags |= VCD_FRAME_FLAG_DECODEONLY;
+	}
+	output_vcd_frm->flags |= VCD_FRAME_FLAG_ENDOFFRAME;
+	ddl_process_decoder_metadata(ddl);
+	output_frame->frm_trans_end = frame_transact_end;
+
+	if (vidc_msg_timing)
+		ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+
+	ddl->ddl_context->ddl_callback(
+		VCD_EVT_RESP_OUTPUT_DONE,
+		vcd_status,
+		output_frame,
+		sizeof(struct ddl_frame_data_tag),
+		(void *)ddl,
+		ddl->ddl_context->client_data);
+	return vcd_status;
+}
+
+static u32 ddl_get_frame
+	(struct vcd_frame_data *frame, u32 frametype) {
+	enum vidc_720p_frame vidc_frame =
+		(enum vidc_720p_frame)frametype;
+	u32 status = true;
+
+	switch (vidc_frame) {
+	case VIDC_720P_IFRAME:
+		{
+			frame->flags |= VCD_FRAME_FLAG_SYNCFRAME;
+			frame->frame = VCD_FRAME_I;
+			break;
+		}
+	case VIDC_720P_PFRAME:
+		{
+			frame->frame = VCD_FRAME_P;
+			break;
+		}
+	case VIDC_720P_BFRAME:
+		{
+			frame->frame = VCD_FRAME_B;
+			break;
+		}
+	case VIDC_720P_NOTCODED:
+		{
+			frame->frame = VCD_FRAME_NOTCODED;
+			frame->data_len = 0;
+			break;
+		}
+	case VIDC_720P_IDRFRAME:
+		{
+			frame->flags |= VCD_FRAME_FLAG_SYNCFRAME;
+			frame->frame = VCD_FRAME_IDR;
+			break;
+		}
+	default:
+		{
+			VIDC_LOG_STRING("CRITICAL-FRAMETYPE");
+			status = false;
+			break;
+		}
+	}
+	return status;
+}
+
+static void ddl_getmpeg4_declevel(enum vcd_codec_level *codec_level,
+	u32 level)
+{
+	switch (level) {
+	case VIDC_720P_MPEG4_LEVEL0:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_0;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL0b:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_0b;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL1:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_1;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL2:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_2;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL3:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_3;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL3b:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_3b;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL4a:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_4a;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL5:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_5;
+			break;
+		}
+	case VIDC_720P_MPEG4_LEVEL6:
+		{
+			*codec_level = VCD_LEVEL_MPEG4_6;
+			break;
+		}
+	}
+}
+
+static void ddl_geth264_declevel(enum vcd_codec_level *codec_level,
+	u32 level)
+{
+	switch (level) {
+	case VIDC_720P_H264_LEVEL1:
+		{
+			*codec_level = VCD_LEVEL_H264_1;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL1b:
+		{
+			*codec_level = VCD_LEVEL_H264_1b;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL1p1:
+		{
+			*codec_level = VCD_LEVEL_H264_1p1;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL1p2:
+		{
+			*codec_level = VCD_LEVEL_H264_1p2;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL1p3:
+		{
+			*codec_level = VCD_LEVEL_H264_1p3;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL2:
+		{
+			*codec_level = VCD_LEVEL_H264_2;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL2p1:
+		{
+			*codec_level = VCD_LEVEL_H264_2p1;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL2p2:
+		{
+			*codec_level = VCD_LEVEL_H264_2p2;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL3:
+		{
+			*codec_level = VCD_LEVEL_H264_3;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL3p1:
+		{
+			*codec_level = VCD_LEVEL_H264_3p1;
+			break;
+		}
+	case VIDC_720P_H264_LEVEL3p2:
+	{
+		*codec_level = VCD_LEVEL_H264_3p2;
+		break;
+	}
+
+	}
+}
+
+static void ddl_get_vc1_dec_level(
+	enum vcd_codec_level *codec_level, u32 level,
+	enum vcd_codec_profile vc1_profile)
+{
+	if (vc1_profile == VCD_PROFILE_VC1_ADVANCE)	{
+		switch (level) {
+		case VIDC_720P_VC1_LEVEL0:
+			{
+				*codec_level = VCD_LEVEL_VC1_A_0;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL1:
+			{
+				*codec_level = VCD_LEVEL_VC1_A_1;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL2:
+			{
+				*codec_level = VCD_LEVEL_VC1_A_2;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL3:
+			{
+				*codec_level = VCD_LEVEL_VC1_A_3;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL4:
+			{
+				*codec_level = VCD_LEVEL_VC1_A_4;
+				break;
+			}
+		}
+		return;
+	} else if (vc1_profile == VCD_PROFILE_VC1_MAIN) {
+		switch (level) {
+		case VIDC_720P_VC1_LEVEL_LOW:
+			{
+				*codec_level = VCD_LEVEL_VC1_M_LOW;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL_MED:
+			{
+				*codec_level = VCD_LEVEL_VC1_M_MEDIUM;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL_HIGH:
+			{
+				*codec_level = VCD_LEVEL_VC1_M_HIGH;
+				break;
+			}
+		}
+	} else if (vc1_profile == VCD_PROFILE_VC1_SIMPLE) {
+		switch (level) {
+		case VIDC_720P_VC1_LEVEL_LOW:
+			{
+				*codec_level = VCD_LEVEL_VC1_S_LOW;
+				break;
+			}
+		case VIDC_720P_VC1_LEVEL_MED:
+			{
+				*codec_level = VCD_LEVEL_VC1_S_MEDIUM;
+				break;
+			}
+		}
+	}
+}
+
+static void ddl_get_mpeg2_dec_level(enum vcd_codec_level *codec_level,
+								 u32 level)
+{
+	switch (level) {
+	case VIDCL_720P_MPEG2_LEVEL_LOW:
+		{
+			*codec_level = VCD_LEVEL_MPEG2_LOW;
+			break;
+		}
+	case VIDCL_720P_MPEG2_LEVEL_MAIN:
+		{
+			*codec_level = VCD_LEVEL_MPEG2_MAIN;
+			break;
+		}
+	case VIDCL_720P_MPEG2_LEVEL_HIGH14:
+		{
+			*codec_level = VCD_LEVEL_MPEG2_HIGH_14;
+			break;
+		}
+	}
+}
+
+static void ddl_getdec_profilelevel(struct ddl_decoder_data *decoder,
+		u32 profile, u32 level)
+{
+	enum vcd_codec_profile codec_profile = VCD_PROFILE_UNKNOWN;
+	enum vcd_codec_level codec_level = VCD_LEVEL_UNKNOWN;
+
+	switch (decoder->codec.codec) {
+	case VCD_CODEC_MPEG4:
+		{
+			if (profile == VIDC_720P_PROFILE_MPEG4_SP)
+				codec_profile = VCD_PROFILE_MPEG4_SP;
+			else if (profile == VIDC_720P_PROFILE_MPEG4_ASP)
+				codec_profile = VCD_PROFILE_MPEG4_ASP;
+
+			ddl_getmpeg4_declevel(&codec_level, level);
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			if (profile == VIDC_720P_PROFILE_H264_BASELINE)
+				codec_profile = VCD_PROFILE_H264_BASELINE;
+			else if (profile == VIDC_720P_PROFILE_H264_MAIN)
+				codec_profile = VCD_PROFILE_H264_MAIN;
+			else if (profile == VIDC_720P_PROFILE_H264_HIGH)
+				codec_profile = VCD_PROFILE_H264_HIGH;
+			ddl_geth264_declevel(&codec_level, level);
+			break;
+		}
+	default:
+	case VCD_CODEC_H263:
+		{
+			break;
+		}
+	case VCD_CODEC_VC1:
+	case VCD_CODEC_VC1_RCV:
+		{
+			if (profile == VIDC_720P_PROFILE_VC1_SP)
+				codec_profile = VCD_PROFILE_VC1_SIMPLE;
+			else if (profile == VIDC_720P_PROFILE_VC1_MAIN)
+				codec_profile = VCD_PROFILE_VC1_MAIN;
+			else if (profile == VIDC_720P_PROFILE_VC1_ADV)
+				codec_profile = VCD_PROFILE_VC1_ADVANCE;
+			ddl_get_vc1_dec_level(&codec_level, level, profile);
+			break;
+		}
+	case VCD_CODEC_MPEG2:
+		{
+			if (profile == VIDC_720P_PROFILE_MPEG2_MAIN)
+				codec_profile = VCD_PROFILE_MPEG2_MAIN;
+			else if (profile == VIDC_720P_PROFILE_MPEG2_SP)
+				codec_profile = VCD_PROFILE_MPEG2_SIMPLE;
+			ddl_get_mpeg2_dec_level(&codec_level, level);
+			break;
+		}
+	}
+
+	decoder->profile.profile = codec_profile;
+	decoder->level.level = codec_level;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.c
new file mode 100644
index 0000000..5d87533
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.c
@@ -0,0 +1,580 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_metadata.h"
+
+static u32 *ddl_metadata_hdr_entry(struct ddl_client_context *ddl,
+				   u32 meta_data)
+{
+	u32 skip_words = 0;
+	u32 *buffer;
+
+	if (ddl->decoding) {
+		buffer = (u32 *)
+		    ddl->codec_data.decoder.meta_data_input.
+		    align_virtual_addr;
+		skip_words = 32 + 1;
+		buffer += skip_words;
+
+		switch (meta_data) {
+		default:
+		case VCD_METADATA_DATANONE:
+			{
+				skip_words = 0;
+				break;
+			}
+		case VCD_METADATA_QPARRAY:
+			{
+				skip_words = 3;
+				break;
+			}
+		case VCD_METADATA_CONCEALMB:
+			{
+				skip_words = 6;
+				break;
+			}
+		case VCD_METADATA_VC1:
+			{
+				skip_words = 9;
+				break;
+			}
+		case VCD_METADATA_SEI:
+			{
+				skip_words = 12;
+				break;
+			}
+		case VCD_METADATA_VUI:
+			{
+				skip_words = 15;
+				break;
+			}
+		case VCD_METADATA_PASSTHROUGH:
+			{
+				skip_words = 18;
+				break;
+			}
+		case VCD_METADATA_QCOMFILLER:
+			{
+				skip_words = 21;
+				break;
+			}
+		}
+	} else {
+		buffer = (u32 *)
+		    ddl->codec_data.encoder.meta_data_input.
+		    align_virtual_addr;
+		skip_words = 2;
+		buffer += skip_words;
+
+		switch (meta_data) {
+		default:
+		case VCD_METADATA_DATANONE:
+			{
+				skip_words = 0;
+				break;
+			}
+		case VCD_METADATA_ENC_SLICE:
+			{
+				skip_words = 3;
+				break;
+			}
+		case VCD_METADATA_QCOMFILLER:
+			{
+				skip_words = 6;
+				break;
+			}
+		}
+
+	}
+
+	buffer += skip_words;
+	return buffer;
+}
+
+void ddl_set_default_meta_data_hdr(struct ddl_client_context *ddl)
+{
+	struct ddl_buf_addr *main_buffer =
+	    &ddl->ddl_context->metadata_shared_input;
+	struct ddl_buf_addr *client_buffer;
+	u32 *hdr_entry;
+
+	if (ddl->decoding)
+		client_buffer = &(ddl->codec_data.decoder.meta_data_input);
+	else
+		client_buffer = &(ddl->codec_data.encoder.meta_data_input);
+
+	DDL_METADATA_CLIENT_INPUTBUF(main_buffer, client_buffer,
+				     ddl->channel_id);
+
+	hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_QCOMFILLER);
+	hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+	hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+	hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_QCOMFILLER;
+
+	hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_DATANONE);
+	hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+	hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+	hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_DATANONE;
+
+	if (ddl->decoding) {
+		hdr_entry =
+		    ddl_metadata_hdr_entry(ddl, VCD_METADATA_QPARRAY);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_QPARRAY;
+
+		hdr_entry =
+		    ddl_metadata_hdr_entry(ddl, VCD_METADATA_CONCEALMB);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_CONCEALMB;
+
+		hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_SEI);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_SEI;
+
+		hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_VUI);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_VUI;
+
+		hdr_entry = ddl_metadata_hdr_entry(ddl, VCD_METADATA_VC1);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] = VCD_METADATA_VC1;
+
+		hdr_entry =
+		    ddl_metadata_hdr_entry(ddl, VCD_METADATA_PASSTHROUGH);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] =
+		    VCD_METADATA_PASSTHROUGH;
+
+	} else {
+		hdr_entry =
+		    ddl_metadata_hdr_entry(ddl, VCD_METADATA_ENC_SLICE);
+		hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] = 0x00000101;
+		hdr_entry[DDL_METADATA_HDR_PORT_INDEX] = 1;
+		hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] =
+		    VCD_METADATA_ENC_SLICE;
+	}
+}
+
+static u32 ddl_supported_metadata_flag(struct ddl_client_context *ddl)
+{
+	u32 flag = 0;
+
+	if (ddl->decoding) {
+		enum vcd_codec codec =
+		    ddl->codec_data.decoder.codec.codec;
+
+		flag |= (VCD_METADATA_CONCEALMB |
+			   VCD_METADATA_PASSTHROUGH | VCD_METADATA_QPARRAY);
+		if (codec == VCD_CODEC_H264) {
+			flag |= (VCD_METADATA_SEI | VCD_METADATA_VUI);
+		} else if (codec == VCD_CODEC_VC1 ||
+			   codec == VCD_CODEC_VC1_RCV) {
+			flag |= VCD_METADATA_VC1;
+		}
+	} else {
+		flag |= VCD_METADATA_ENC_SLICE;
+	}
+
+	return flag;
+}
+
+void ddl_set_default_metadata_flag(struct ddl_client_context *ddl)
+{
+	if (ddl->decoding)
+		ddl->codec_data.decoder.meta_data_enable_flag = 0;
+	else
+		ddl->codec_data.encoder.meta_data_enable_flag = 0;
+}
+
+void ddl_set_default_decoder_metadata_buffer_size(
+	struct ddl_decoder_data *decoder,
+	struct vcd_property_frame_size *frame_size,
+	struct vcd_buffer_requirement *output_buf_req)
+{
+	u32 flag = decoder->meta_data_enable_flag;
+	u32 suffix = 0;
+	size_t sz = 0;
+
+	if (!flag) {
+		decoder->suffix = 0;
+		return;
+	}
+
+	if (flag & VCD_METADATA_QPARRAY) {
+		u32 num_of_mb =
+		    ((frame_size->width * frame_size->height) >> 8);
+		sz = DDL_METADATA_HDR_SIZE;
+		sz += num_of_mb;
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += sz;
+	}
+	if (flag & VCD_METADATA_CONCEALMB) {
+		u32 num_of_mb =
+		    ((frame_size->width * frame_size->height) >> 8);
+		sz = DDL_METADATA_HDR_SIZE + (num_of_mb >> 3);
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += sz;
+	}
+	if (flag & VCD_METADATA_VC1) {
+		sz = DDL_METADATA_HDR_SIZE;
+		sz += DDL_METADATA_VC1_PAYLOAD_SIZE;
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += sz;
+	}
+	if (flag & VCD_METADATA_SEI) {
+		sz = DDL_METADATA_HDR_SIZE;
+		sz += DDL_METADATA_SEI_PAYLOAD_SIZE;
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += (sz * DDL_METADATA_SEI_MAX);
+	}
+	if (flag & VCD_METADATA_VUI) {
+		sz = DDL_METADATA_HDR_SIZE;
+		sz += DDL_METADATA_VUI_PAYLOAD_SIZE;
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += (sz);
+	}
+	if (flag & VCD_METADATA_PASSTHROUGH) {
+		sz = DDL_METADATA_HDR_SIZE;
+		sz += DDL_METADATA_PASSTHROUGH_PAYLOAD_SIZE;
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += (sz);
+	}
+	sz = DDL_METADATA_EXTRADATANONE_SIZE;
+	DDL_METADATA_ALIGNSIZE(sz);
+	suffix += (sz);
+
+	suffix += DDL_METADATA_EXTRAPAD_SIZE;
+	DDL_METADATA_ALIGNSIZE(suffix);
+
+	decoder->suffix = suffix;
+	output_buf_req->sz += suffix;
+	return;
+}
+
+void ddl_set_default_encoder_metadata_buffer_size(struct ddl_encoder_data
+						  *encoder)
+{
+	u32 flag = encoder->meta_data_enable_flag;
+	u32 suffix = 0;
+	size_t sz = 0;
+
+	if (!flag) {
+		encoder->suffix = 0;
+		return;
+	}
+
+	if (flag & VCD_METADATA_ENC_SLICE) {
+		u32 num_of_mb = (encoder->frame_size.width *
+				   encoder->frame_size.height / 16 / 16);
+		sz = DDL_METADATA_HDR_SIZE;
+
+		sz += 4;
+
+		sz += (8 * num_of_mb);
+		DDL_METADATA_ALIGNSIZE(sz);
+		suffix += sz;
+	}
+
+	sz = DDL_METADATA_EXTRADATANONE_SIZE;
+	DDL_METADATA_ALIGNSIZE(sz);
+	suffix += (sz);
+
+	suffix += DDL_METADATA_EXTRAPAD_SIZE;
+	DDL_METADATA_ALIGNSIZE(suffix);
+
+	encoder->suffix = suffix;
+	encoder->output_buf_req.sz += suffix;
+}
+
+u32 ddl_set_metadata_params(struct ddl_client_context *ddl,
+			    struct vcd_property_hdr *property_hdr,
+			    void *property_value)
+{
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	if (property_hdr->prop_id == VCD_I_METADATA_ENABLE) {
+		struct vcd_property_meta_data_enable *meta_data_enable =
+		    (struct vcd_property_meta_data_enable *)
+		    property_value;
+		u32 *meta_data_enable_flag;
+		enum vcd_codec codec;
+		if (ddl->decoding) {
+			meta_data_enable_flag =
+			    &(ddl->codec_data.decoder.
+			      meta_data_enable_flag);
+			codec = ddl->codec_data.decoder.codec.codec;
+		} else {
+			meta_data_enable_flag =
+			    &(ddl->codec_data.encoder.
+			      meta_data_enable_flag);
+			codec = ddl->codec_data.encoder.codec.codec;
+		}
+		if (sizeof(struct vcd_property_meta_data_enable) ==
+		    property_hdr->sz &&
+		    DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN) &&
+					codec) {
+			u32 flag = ddl_supported_metadata_flag(ddl);
+			flag &= (meta_data_enable->meta_data_enable_flag);
+			if (flag)
+				flag |= DDL_METADATA_MANDATORY;
+			if (flag != *meta_data_enable_flag) {
+				*meta_data_enable_flag = flag;
+				if (ddl->decoding) {
+					ddl_set_default_decoder_buffer_req
+						(&ddl->codec_data.decoder,
+						 true);
+				} else {
+					ddl_set_default_encoder_buffer_req
+						(&ddl->codec_data.encoder);
+				}
+			}
+			vcd_status = VCD_S_SUCCESS;
+		}
+	} else if (property_hdr->prop_id == VCD_I_METADATA_HEADER) {
+		struct vcd_property_metadata_hdr *hdr =
+		    (struct vcd_property_metadata_hdr *)property_value;
+		if (sizeof(struct vcd_property_metadata_hdr) ==
+		    property_hdr->sz) {
+			u32 flag = ddl_supported_metadata_flag(ddl);
+			flag |= DDL_METADATA_MANDATORY;
+			flag &= hdr->meta_data_id;
+			if (!(flag & (flag - 1))) {
+				u32 *hdr_entry =
+				    ddl_metadata_hdr_entry(ddl, flag);
+				hdr_entry[DDL_METADATA_HDR_VERSION_INDEX] =
+				    hdr->version;
+				hdr_entry[DDL_METADATA_HDR_PORT_INDEX] =
+				    hdr->port_index;
+				hdr_entry[DDL_METADATA_HDR_TYPE_INDEX] =
+				    hdr->type;
+				vcd_status = VCD_S_SUCCESS;
+			}
+		}
+	}
+	return vcd_status;
+}
+
+u32 ddl_get_metadata_params(struct ddl_client_context *ddl,
+	struct vcd_property_hdr *property_hdr,
+	void	*property_value)
+{
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM ;
+	if (property_hdr->prop_id == VCD_I_METADATA_ENABLE &&
+		sizeof(struct vcd_property_meta_data_enable)
+		== property_hdr->sz) {
+		struct vcd_property_meta_data_enable *meta_data_enable =
+			(struct vcd_property_meta_data_enable *)
+			property_value;
+		meta_data_enable->meta_data_enable_flag =
+			((ddl->decoding) ?
+			(ddl->codec_data.decoder.meta_data_enable_flag)
+			: (ddl->codec_data.encoder.meta_data_enable_flag));
+		vcd_status = VCD_S_SUCCESS;
+	} else if (property_hdr->prop_id == VCD_I_METADATA_HEADER &&
+		sizeof(struct vcd_property_metadata_hdr) ==
+		property_hdr->sz) {
+		struct vcd_property_metadata_hdr *hdr =
+			(struct vcd_property_metadata_hdr *)
+			property_value;
+		u32 flag = ddl_supported_metadata_flag(ddl);
+		flag |= DDL_METADATA_MANDATORY;
+		flag &= hdr->meta_data_id;
+		if (!(flag & (flag - 1))) {
+			u32 *hdr_entry = ddl_metadata_hdr_entry(ddl,
+				flag);
+			hdr->version =
+			hdr_entry[DDL_METADATA_HDR_VERSION_INDEX];
+			hdr->port_index =
+			hdr_entry[DDL_METADATA_HDR_PORT_INDEX];
+			hdr->type =
+				hdr_entry[DDL_METADATA_HDR_TYPE_INDEX];
+			vcd_status = VCD_S_SUCCESS;
+		}
+	}
+	return vcd_status;
+}
+
+void ddl_metadata_enable(struct ddl_client_context *ddl)
+{
+	u32 flag, hal_flag = 0;
+	u32 *metadata_input;
+	if (ddl->decoding) {
+		flag = ddl->codec_data.decoder.meta_data_enable_flag;
+		metadata_input =
+		    ddl->codec_data.decoder.meta_data_input.
+		    align_physical_addr;
+	} else {
+		flag = ddl->codec_data.encoder.meta_data_enable_flag;
+		metadata_input =
+		    ddl->codec_data.encoder.meta_data_input.
+		    align_physical_addr;
+	}
+	if (flag) {
+		if (flag & VCD_METADATA_QPARRAY)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_QP;
+		if (flag & VCD_METADATA_CONCEALMB)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_CONCEALMB;
+		if (flag & VCD_METADATA_VC1)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_VC1;
+		if (flag & VCD_METADATA_SEI)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_SEI;
+		if (flag & VCD_METADATA_VUI)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_VUI;
+		if (flag & VCD_METADATA_ENC_SLICE)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_ENCSLICE;
+		if (flag & VCD_METADATA_PASSTHROUGH)
+			hal_flag |= VIDC_720P_METADATA_ENABLE_PASSTHROUGH;
+	} else {
+		metadata_input = 0;
+	}
+	vidc_720p_metadata_enable(hal_flag, metadata_input);
+}
+
+u32 ddl_encode_set_metadata_output_buf(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &ddl->codec_data.encoder;
+	u32 *buffer;
+	struct vcd_frame_data *stream = &(ddl->output_frame.vcd_frm);
+	u32 ext_buffer_end, hw_metadata_start;
+
+	ext_buffer_end = (u32) stream->physical + stream->alloc_len;
+	if (!encoder->meta_data_enable_flag) {
+		ext_buffer_end &= ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+		return ext_buffer_end;
+	}
+	hw_metadata_start = (ext_buffer_end - encoder->suffix) &
+	    ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+
+	ext_buffer_end = (hw_metadata_start - 1) &
+	    ~(DDL_STREAMBUF_ALIGN_GUARD_BYTES);
+
+	buffer = encoder->meta_data_input.align_virtual_addr;
+
+	*buffer++ = encoder->suffix;
+
+	*buffer = hw_metadata_start;
+
+	encoder->meta_data_offset =
+	    hw_metadata_start - (u32) stream->physical;
+
+	return ext_buffer_end;
+}
+
+void ddl_decode_set_metadata_output(struct ddl_decoder_data *decoder)
+{
+	u32 *buffer;
+	u32 loopc;
+
+	if (!decoder->meta_data_enable_flag) {
+		decoder->meta_data_offset = 0;
+		return;
+	}
+
+	decoder->meta_data_offset = ddl_get_yuv_buffer_size(
+		&decoder->client_frame_size, &decoder->buf_format,
+		(!decoder->progressive_only), decoder->codec.codec);
+
+	buffer = decoder->meta_data_input.align_virtual_addr;
+
+	*buffer++ = decoder->suffix;
+
+	for (loopc = 0; loopc < decoder->dp_buf.no_of_dec_pic_buf;
+	     ++loopc) {
+		*buffer++ = (u32) (decoder->meta_data_offset + (u8 *)
+				     decoder->dp_buf.
+				     dec_pic_buffers[loopc].vcd_frm.
+				     physical);
+	}
+}
+
+void ddl_process_encoder_metadata(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	struct vcd_frame_data *out_frame =
+	    &(ddl->output_frame.vcd_frm);
+	u32 *qfiller_hdr, *qfiller, start_addr;
+	u32 qfiller_size;
+
+	if (!encoder->meta_data_enable_flag) {
+		out_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
+		return;
+	}
+
+	if (!encoder->enc_frame_info.metadata_exists) {
+		out_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
+		return;
+	}
+	out_frame->flags |= VCD_FRAME_FLAG_EXTRADATA;
+
+	start_addr = (u32) ((u8 *) out_frame->virtual +
+			      out_frame->offset);
+	qfiller = (u32 *) ((out_frame->data_len + start_addr + 3) & ~3);
+
+	qfiller_size = (u32) ((encoder->meta_data_offset +
+				 (u8 *) out_frame->virtual) -
+				(u8 *) qfiller);
+
+	qfiller_hdr = ddl_metadata_hdr_entry(ddl, VCD_METADATA_QCOMFILLER);
+
+	*qfiller++ = qfiller_size;
+	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_VERSION_INDEX];
+	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_PORT_INDEX];
+	*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_TYPE_INDEX];
+	*qfiller = (u32) (qfiller_size - DDL_METADATA_HDR_SIZE);
+}
+
+void ddl_process_decoder_metadata(struct ddl_client_context *ddl)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	struct vcd_frame_data *output_frame =
+	    &(ddl->output_frame.vcd_frm);
+	u32 *qfiller_hdr, *qfiller;
+	u32 qfiller_size;
+
+	if (!decoder->meta_data_enable_flag) {
+		output_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
+		return;
+	}
+
+	if (!decoder->dec_disp_info.metadata_exists) {
+		output_frame->flags &= ~(VCD_FRAME_FLAG_EXTRADATA);
+		return;
+	}
+	output_frame->flags |= VCD_FRAME_FLAG_EXTRADATA;
+
+	if (output_frame->data_len != decoder->meta_data_offset) {
+		qfiller = (u32 *) ((u32) ((output_frame->data_len +
+					     output_frame->offset +
+					     (u8 *) output_frame->virtual) +
+					    3) & ~3);
+
+		qfiller_size = (u32) ((decoder->meta_data_offset +
+					 (u8 *) output_frame->virtual) -
+					(u8 *) qfiller);
+
+		qfiller_hdr =
+		    ddl_metadata_hdr_entry(ddl, VCD_METADATA_QCOMFILLER);
+		*qfiller++ = qfiller_size;
+		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_VERSION_INDEX];
+		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_PORT_INDEX];
+		*qfiller++ = qfiller_hdr[DDL_METADATA_HDR_TYPE_INDEX];
+		*qfiller = (u32) (qfiller_size - DDL_METADATA_HDR_SIZE);
+	}
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.h
new file mode 100644
index 0000000..7c9ac95
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_metadata.h
@@ -0,0 +1,79 @@
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_METADATA_H_
+#define _VCD_DDL_METADATA_H_
+
+#define DDL_MAX_DEC_METADATATYPE  (8)
+#define DDL_MAX_ENC_METADATATYPE  (3)
+
+#define DDL_METADATA_EXTRAPAD_SIZE (256)
+#define DDL_METADATA_HDR_SIZE (20)
+
+#define DDL_METADATA_EXTRADATANONE_SIZE (24)
+
+#define DDL_METADATA_ALIGNSIZE(x) ((x) = (((x) + 0x7) & ~0x7))
+
+#define DDL_METADATA_MANDATORY (VCD_METADATA_DATANONE | \
+				VCD_METADATA_QCOMFILLER)
+
+#define DDL_METADATA_VC1_PAYLOAD_SIZE (38*4)
+
+#define DDL_METADATA_SEI_PAYLOAD_SIZE (100)
+#define DDL_METADATA_SEI_MAX (5)
+
+#define DDL_METADATA_VUI_PAYLOAD_SIZE (256)
+
+#define DDL_METADATA_PASSTHROUGH_PAYLOAD_SIZE  (68)
+
+#define DDL_METADATA_CLIENT_INPUTBUFSIZE  (256)
+#define DDL_METADATA_TOTAL_INPUTBUFSIZE \
+	(DDL_METADATA_CLIENT_INPUTBUFSIZE * VCD_MAX_NO_CLIENT)
+
+#define DDL_METADATA_CLIENT_INPUTBUF(main_buffer, client_buffer, \
+		channel_id) \
+{ \
+  (client_buffer)->align_physical_addr = (u32 *)\
+	((u8 *)(main_buffer)->align_physical_addr + \
+	(DDL_METADATA_CLIENT_INPUTBUFSIZE * (channel_id)) \
+	); \
+  (client_buffer)->align_virtual_addr = (u32 *)\
+	((u8 *)(main_buffer)->align_virtual_addr + \
+	(DDL_METADATA_CLIENT_INPUTBUFSIZE * (channel_id)) \
+	); \
+  (client_buffer)->virtual_base_addr = 0; \
+}
+
+#define DDL_METADATA_HDR_VERSION_INDEX 0
+#define DDL_METADATA_HDR_PORT_INDEX    1
+#define DDL_METADATA_HDR_TYPE_INDEX    2
+
+
+void ddl_set_default_meta_data_hdr(struct ddl_client_context *ddl);
+u32 ddl_get_metadata_params(struct ddl_client_context	*ddl,
+	struct vcd_property_hdr *property_hdr, void *property_value);
+u32 ddl_set_metadata_params(struct ddl_client_context *ddl,
+			    struct vcd_property_hdr *property_hdr,
+			    void *property_value);
+void ddl_set_default_metadata_flag(struct ddl_client_context *ddl);
+void ddl_set_default_decoder_metadata_buffer_size
+    (struct ddl_decoder_data *decoder,
+	struct vcd_property_frame_size *frame_size,
+	struct vcd_buffer_requirement *output_buf_req);
+void ddl_set_default_encoder_metadata_buffer_size(struct ddl_encoder_data
+						  *encoder);
+void ddl_metadata_enable(struct ddl_client_context *ddl);
+u32 ddl_encode_set_metadata_output_buf(struct ddl_client_context *ddl);
+void ddl_decode_set_metadata_output(struct ddl_decoder_data *decoder);
+void ddl_process_encoder_metadata(struct ddl_client_context *ddl);
+void ddl_process_decoder_metadata(struct ddl_client_context *ddl);
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_properties.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_properties.c
new file mode 100644
index 0000000..cdb6313
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_properties.c
@@ -0,0 +1,1943 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+#include "vcd_ddl_metadata.h"
+
+static u32 ddl_set_dec_property(struct ddl_client_context *pddl,
+				struct vcd_property_hdr *property_hdr,
+				void *property_value);
+static u32 ddl_set_enc_property(struct ddl_client_context *pddl,
+				struct vcd_property_hdr *property_hdr,
+				void *property_value);
+static u32 ddl_get_dec_property(struct ddl_client_context *pddl,
+				struct vcd_property_hdr *property_hdr,
+				void *property_value);
+static u32 ddl_get_enc_property(struct ddl_client_context *pddl,
+				struct vcd_property_hdr *property_hdr,
+				void *property_value);
+static u32 ddl_set_enc_dynamic_property(struct ddl_client_context *ddl,
+				struct vcd_property_hdr *property_hdr,
+				void *property_value);
+static void ddl_set_default_enc_property(struct ddl_client_context *ddl);
+static void ddl_set_default_enc_profile(struct ddl_encoder_data
+					*encoder);
+static void ddl_set_default_enc_level(struct ddl_encoder_data *encoder);
+static void ddl_set_default_enc_vop_timing(struct ddl_encoder_data
+					   *encoder);
+static void ddl_set_default_enc_intra_period(struct ddl_encoder_data
+					     *encoder);
+static void ddl_set_default_enc_rc_params(struct ddl_encoder_data
+					  *encoder);
+static u32 ddl_valid_buffer_requirement(struct vcd_buffer_requirement
+					*original_buf_req,
+					struct vcd_buffer_requirement
+					*req_buf_req);
+static u32 ddl_decoder_min_num_dpb(struct ddl_decoder_data *decoder);
+static u32 ddl_set_dec_buffers
+    (struct ddl_decoder_data *decoder,
+     struct ddl_property_dec_pic_buffers *dpb);
+
+u32 ddl_set_property(u32 *ddl_handle,
+     struct vcd_property_hdr *property_hdr, void *property_value)
+{
+	u32 vcd_status;
+	struct ddl_context *ddl_context;
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+
+	if (!property_hdr || !property_value) {
+		VIDC_LOGERR_STRING("ddl_set_prop:Bad_argument");
+		return VCD_ERR_ILLEGAL_PARM;
+	}
+	ddl_context = ddl_get_context();
+
+	if (!DDL_IS_INITIALIZED(ddl_context)) {
+		VIDC_LOGERR_STRING("ddl_set_prop:Not_inited");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	if (!ddl) {
+		VIDC_LOGERR_STRING("ddl_set_prop:Bad_handle");
+		return VCD_ERR_BAD_HANDLE;
+	}
+	if (ddl->decoding) {
+		vcd_status =
+		    ddl_set_dec_property(ddl, property_hdr,
+					 property_value);
+	} else {
+		vcd_status =
+		    ddl_set_enc_property(ddl, property_hdr,
+					 property_value);
+	}
+	if (vcd_status)
+		VIDC_LOGERR_STRING("ddl_set_prop:FAILED");
+
+	return vcd_status;
+}
+
+u32 ddl_get_property(u32 *ddl_handle,
+     struct vcd_property_hdr *property_hdr, void *property_value)
+{
+
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	struct ddl_context *ddl_context;
+	struct ddl_client_context *ddl =
+	    (struct ddl_client_context *)ddl_handle;
+
+	if (!property_hdr || !property_value)
+		return VCD_ERR_ILLEGAL_PARM;
+
+	if (property_hdr->prop_id == DDL_I_CAPABILITY) {
+		if (sizeof(struct ddl_property_capability) ==
+		    property_hdr->sz) {
+			struct ddl_property_capability *ddl_capability =
+			    (struct ddl_property_capability *)
+			    property_value;
+			ddl_capability->max_num_client = VCD_MAX_NO_CLIENT;
+			ddl_capability->exclusive =
+				VCD_COMMAND_EXCLUSIVE;
+			ddl_capability->frame_command_depth =
+				VCD_FRAME_COMMAND_DEPTH;
+			ddl_capability->general_command_depth =
+				VCD_GENERAL_COMMAND_DEPTH;
+			ddl_capability->ddl_time_out_in_ms =
+				DDL_HW_TIMEOUT_IN_MS;
+			vcd_status = VCD_S_SUCCESS;
+		}
+		return vcd_status;
+	}
+	ddl_context = ddl_get_context();
+	if (!DDL_IS_INITIALIZED(ddl_context))
+		return VCD_ERR_ILLEGAL_OP;
+
+	if (!ddl)
+		return VCD_ERR_BAD_HANDLE;
+
+	if (ddl->decoding) {
+		vcd_status =
+		    ddl_get_dec_property(ddl, property_hdr,
+					 property_value);
+	} else {
+		vcd_status =
+		    ddl_get_enc_property(ddl, property_hdr,
+					 property_value);
+	}
+	if (vcd_status)
+		VIDC_LOGERR_STRING("ddl_get_prop:FAILED");
+
+	return vcd_status;
+}
+
+u32 ddl_decoder_ready_to_start(struct ddl_client_context *ddl,
+     struct vcd_sequence_hdr *header)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	if (!decoder->codec.codec) {
+		VIDC_LOGERR_STRING("ddl_dec_start_check:Codec_not_set");
+		return false;
+	}
+	if ((!header) &&
+	    (!decoder->client_frame_size.height ||
+	     !decoder->client_frame_size.width)
+	    ) {
+		VIDC_LOGERR_STRING
+		    ("ddl_dec_start_check:Client_height_width_default");
+		return false;
+	}
+	return true;
+}
+
+u32 ddl_encoder_ready_to_start(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+
+	if (!encoder->codec.codec ||
+	    !encoder->frame_size.height ||
+	    !encoder->frame_size.width ||
+	    !encoder->frame_rate.fps_denominator ||
+	    !encoder->frame_rate.fps_numerator ||
+	    !encoder->target_bit_rate.target_bitrate) {
+		return false;
+	}
+	return true;
+}
+
+static u32 ddl_set_dec_property
+    (struct ddl_client_context *ddl,
+     struct vcd_property_hdr *property_hdr, void *property_value) {
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	switch (property_hdr->prop_id) {
+	case DDL_I_DPB_RELEASE:
+		{
+			if (sizeof(struct ddl_frame_data_tag) ==
+			    property_hdr->sz
+			    && decoder->dp_buf.no_of_dec_pic_buf) {
+				vcd_status =
+				    ddl_decoder_dpb_transact(decoder,
+					     (struct ddl_frame_data_tag *)
+					     property_value,
+					     DDL_DPB_OP_MARK_FREE);
+			}
+			break;
+		}
+	case DDL_I_DPB:
+		{
+			struct ddl_property_dec_pic_buffers *dpb =
+			    (struct ddl_property_dec_pic_buffers *)
+			    property_value;
+
+			if (sizeof(struct ddl_property_dec_pic_buffers) ==
+			    property_hdr->sz &&
+			    (DDLCLIENT_STATE_IS
+			     (ddl, DDL_CLIENT_WAIT_FOR_INITCODEC)
+			     || DDLCLIENT_STATE_IS(ddl,
+						   DDL_CLIENT_WAIT_FOR_DPB)
+			    ) &&
+			    dpb->no_of_dec_pic_buf >=
+			    decoder->client_output_buf_req.actual_count) {
+				vcd_status =
+				    ddl_set_dec_buffers(decoder, dpb);
+			}
+			break;
+		}
+	case DDL_I_REQ_OUTPUT_FLUSH:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				decoder->dynamic_prop_change |=
+				    DDL_DEC_REQ_OUTPUT_FLUSH;
+				decoder->dpb_mask.client_mask = 0;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_INPUT_BUF_REQ:
+		{
+			struct vcd_buffer_requirement *buffer_req =
+			    (struct vcd_buffer_requirement *)
+			    property_value;
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz &&
+			    (ddl_valid_buffer_requirement(
+						&decoder->min_input_buf_req,
+						buffer_req))) {
+				decoder->client_input_buf_req = *buffer_req;
+				decoder->client_input_buf_req.min_count =
+					decoder->min_input_buf_req.min_count;
+				decoder->client_input_buf_req.max_count =
+					decoder->min_input_buf_req.max_count;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_OUTPUT_BUF_REQ:
+		{
+			struct vcd_buffer_requirement *buffer_req =
+			    (struct vcd_buffer_requirement *)
+			    property_value;
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz &&
+			    (ddl_valid_buffer_requirement(
+						&decoder->min_output_buf_req,
+						buffer_req))) {
+				decoder->client_output_buf_req =
+				    *buffer_req;
+				decoder->client_output_buf_req.min_count =
+					decoder->min_output_buf_req.min_count;
+				decoder->client_output_buf_req.max_count =
+					decoder->min_output_buf_req.max_count;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+
+	case VCD_I_CODEC:
+		{
+			struct vcd_property_codec *codec =
+			    (struct vcd_property_codec *)property_value;
+			if (sizeof(struct vcd_property_codec) ==
+			    property_hdr->sz
+			    && DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)
+			    ) {
+				u32 status;
+				vcd_fw_transact(false, true,
+					decoder->codec.codec);
+				status = vcd_fw_transact(true, true,
+					codec->codec);
+				if (status) {
+					decoder->codec = *codec;
+					ddl_set_default_dec_property(ddl);
+					vcd_status = VCD_S_SUCCESS;
+				} else {
+					status = vcd_fw_transact(true, true,
+						decoder->codec.codec);
+					vcd_status = VCD_ERR_NOT_SUPPORTED;
+				}
+			}
+			break;
+		}
+	case VCD_I_POST_FILTER:
+		{
+			if (sizeof(struct vcd_property_post_filter) ==
+			    property_hdr->sz
+			    && DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN) &&
+			    (decoder->codec.codec == VCD_CODEC_MPEG4 ||
+			     decoder->codec.codec == VCD_CODEC_MPEG2)
+			    ) {
+				decoder->post_filter =
+				    *(struct vcd_property_post_filter *)
+				    property_value;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_SIZE:
+		{
+			struct vcd_property_frame_size *frame_size =
+			    (struct vcd_property_frame_size *)
+			    property_value;
+
+			if ((sizeof(struct vcd_property_frame_size) ==
+					property_hdr->sz) &&
+				(DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN))) {
+				if (decoder->client_frame_size.height !=
+				    frame_size->height
+				    || decoder->client_frame_size.width !=
+				    frame_size->width) {
+					decoder->client_frame_size =
+					    *frame_size;
+					ddl_set_default_decoder_buffer_req
+					    (decoder, true);
+				}
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_BUFFER_FORMAT:
+		{
+			struct vcd_property_buffer_format *tile =
+			    (struct vcd_property_buffer_format *)
+			    property_value;
+			if (sizeof(struct vcd_property_buffer_format) ==
+			    property_hdr->sz &&
+			    DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN) &&
+			    (tile->buffer_format == VCD_BUFFER_FORMAT_NV12
+			     || tile->buffer_format ==
+			     VCD_BUFFER_FORMAT_TILE_4x2)
+			    ) {
+				if (tile->buffer_format !=
+				    decoder->buf_format.buffer_format) {
+					decoder->buf_format = *tile;
+					ddl_set_default_decoder_buffer_req
+					    (decoder, true);
+				}
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_METADATA_ENABLE:
+	case VCD_I_METADATA_HEADER:
+		{
+			vcd_status = ddl_set_metadata_params(ddl,
+							     property_hdr,
+							     property_value);
+			break;
+		}
+	case VCD_I_OUTPUT_ORDER:
+		{
+			if (sizeof(u32) == property_hdr->sz &&
+				DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)) {
+					decoder->output_order =
+						*(u32 *)property_value;
+					vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_DEC_PICTYPE:
+		{
+			if ((sizeof(u32) == property_hdr->sz) &&
+				DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)) {
+				decoder->idr_only_decoding =
+					*(u32 *)property_value;
+				ddl_set_default_decoder_buffer_req(
+						decoder, true);
+				vcd_status = VCD_S_SUCCESS;
+			}
+		}
+		break;
+	case VCD_I_FRAME_RATE:
+		{
+			vcd_status = VCD_S_SUCCESS;
+			break;
+		}
+	default:
+		{
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+			break;
+		}
+	}
+	return vcd_status;
+}
+
+static u32 ddl_set_enc_property(struct ddl_client_context *ddl,
+	struct vcd_property_hdr *property_hdr, void *property_value)
+{
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+
+	if (DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME) ||
+	   (DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE) ||
+		DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN)))
+		vcd_status = ddl_set_enc_dynamic_property(ddl,
+			property_hdr, property_value);
+	if (vcd_status == VCD_S_SUCCESS)
+		return vcd_status;
+
+	if (!DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN) ||
+		vcd_status != VCD_ERR_ILLEGAL_OP) {
+		VIDC_LOGERR_STRING
+			("ddl_set_enc_property:Fails_as_not_in_open_state");
+		return VCD_ERR_ILLEGAL_OP;
+	}
+
+	switch (property_hdr->prop_id) {
+	case VCD_I_FRAME_SIZE:
+		{
+			struct vcd_property_frame_size *framesize =
+				(struct vcd_property_frame_size *)
+				property_value;
+
+			if (sizeof(struct vcd_property_frame_size)
+				== property_hdr->sz &&
+				DDL_ALLOW_ENC_FRAMESIZE(framesize->width,
+				framesize->height) &&
+				(encoder->codec.codec == VCD_CODEC_H264 ||
+				 DDL_VALIDATE_ENC_FRAMESIZE(framesize->width,
+				 framesize->height))
+				) {
+				encoder->frame_size = *framesize;
+				ddl_calculate_stride(&encoder->frame_size,
+					false, encoder->codec.codec);
+				ddl_set_default_encoder_buffer_req(encoder);
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_CODEC:
+		{
+			struct vcd_property_codec *codec =
+				(struct vcd_property_codec *)
+				property_value;
+			if (sizeof(struct vcd_property_codec) ==
+				property_hdr->sz) {
+				u32 status;
+
+				vcd_fw_transact(false, false,
+					encoder->codec.codec);
+
+				status = vcd_fw_transact(true, false,
+					codec->codec);
+				if (status) {
+					encoder->codec = *codec;
+					ddl_set_default_enc_property(ddl);
+					vcd_status = VCD_S_SUCCESS;
+				} else {
+					status = vcd_fw_transact(true, false,
+						encoder->codec.codec);
+					vcd_status = VCD_ERR_NOT_SUPPORTED;
+				}
+			}
+			break;
+		}
+	case VCD_I_PROFILE:
+		{
+			struct vcd_property_profile *profile =
+				(struct vcd_property_profile *)
+				property_value;
+			if ((sizeof(struct vcd_property_profile) ==
+				property_hdr->sz) &&
+				((encoder->codec.codec ==
+					VCD_CODEC_MPEG4 &&
+				  (profile->profile ==
+					VCD_PROFILE_MPEG4_SP ||
+					profile->profile ==
+					VCD_PROFILE_MPEG4_ASP)) ||
+				 (encoder->codec.codec ==
+					VCD_CODEC_H264 &&
+				 (profile->profile >=
+					VCD_PROFILE_H264_BASELINE ||
+				  profile->profile <=
+					VCD_PROFILE_H264_HIGH)) ||
+				 (encoder->codec.codec ==
+					VCD_CODEC_H263 &&
+				  profile->profile ==
+					VCD_PROFILE_H263_BASELINE))
+				) {
+				encoder->profile = *profile;
+				vcd_status = VCD_S_SUCCESS;
+
+				if (profile->profile ==
+					VCD_PROFILE_H264_BASELINE)
+					encoder->entropy_control.entropy_sel
+						= VCD_ENTROPY_SEL_CAVLC;
+				else
+					encoder->entropy_control.entropy_sel
+						= VCD_ENTROPY_SEL_CABAC;
+			}
+			break;
+		}
+	case VCD_I_LEVEL:
+		{
+			struct vcd_property_level *level =
+				(struct vcd_property_level *)
+				property_value;
+			if (
+				(sizeof(struct vcd_property_level) ==
+				 property_hdr->sz
+				) &&
+				(
+				(
+				(encoder->codec.
+				 codec == VCD_CODEC_MPEG4) &&
+				(level->level >= VCD_LEVEL_MPEG4_0) &&
+				(level->level <= VCD_LEVEL_MPEG4_6)
+				) ||
+				(
+				(encoder->codec.
+				 codec == VCD_CODEC_H264) &&
+				(level->level >= VCD_LEVEL_H264_1) &&
+				(level->level <= VCD_LEVEL_H264_3p1)
+				) ||
+				(
+				(encoder->codec.
+				 codec == VCD_CODEC_H263) &&
+				(level->level >= VCD_LEVEL_H263_10) &&
+				(level->level <= VCD_LEVEL_H263_70)
+				)
+				)
+				) {
+				encoder->level = *level;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_MULTI_SLICE:
+		{
+			struct vcd_property_multi_slice *multislice =
+				(struct vcd_property_multi_slice *)
+				property_value;
+			switch (multislice->m_slice_sel) {
+			case VCD_MSLICE_OFF:
+				{
+					vcd_status = VCD_S_SUCCESS;
+					break;
+				}
+			case VCD_MSLICE_BY_GOB:
+				{
+					if (encoder->codec.codec ==
+						VCD_CODEC_H263)
+						vcd_status = VCD_S_SUCCESS;
+					 break;
+				}
+			case VCD_MSLICE_BY_MB_COUNT:
+				{
+					if (multislice->m_slice_size
+						>= 1 && (multislice->
+						m_slice_size <=
+						(encoder->frame_size.height
+						* encoder->frame_size.width
+						/ 16 / 16))
+						) {
+						vcd_status = VCD_S_SUCCESS;
+					}
+					break;
+				  }
+			case VCD_MSLICE_BY_BYTE_COUNT:
+				{
+					if (multislice->m_slice_size > 0)
+						vcd_status = VCD_S_SUCCESS;
+					break;
+				}
+			default:
+				{
+					break;
+				}
+			}
+			if (sizeof(struct vcd_property_multi_slice) ==
+				property_hdr->sz &&
+				!vcd_status) {
+				encoder->multi_slice = *multislice;
+				if (multislice->m_slice_sel ==
+						VCD_MSLICE_OFF)
+					encoder->multi_slice.m_slice_size = 0;
+			}
+			break;
+		}
+	case VCD_I_RATE_CONTROL:
+		{
+			struct vcd_property_rate_control
+				*ratecontrol =
+				(struct vcd_property_rate_control *)
+				property_value;
+			if (sizeof(struct vcd_property_rate_control) ==
+				property_hdr->sz &&
+				ratecontrol->
+				rate_control >= VCD_RATE_CONTROL_OFF &&
+				ratecontrol->
+				rate_control <= VCD_RATE_CONTROL_CBR_CFR
+				) {
+				encoder->rc = *ratecontrol;
+				ddl_set_default_enc_rc_params(encoder);
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_SHORT_HEADER:
+		{
+
+		if (sizeof(struct vcd_property_short_header) ==
+			property_hdr->sz &&
+			encoder->codec.codec == VCD_CODEC_MPEG4) {
+			encoder->short_header =
+				*(struct vcd_property_short_header *)
+				property_value;
+			vcd_status = VCD_S_SUCCESS;
+		}
+
+			break;
+		}
+	case VCD_I_VOP_TIMING:
+		{
+			struct vcd_property_vop_timing *voptime =
+				(struct vcd_property_vop_timing *)
+				property_value;
+			if (
+				(sizeof(struct vcd_property_vop_timing) ==
+					  property_hdr->sz
+				) &&
+				(encoder->frame_rate.fps_numerator <=
+					voptime->vop_time_resolution)
+				) {
+				encoder->vop_timing = *voptime;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_HEADER_EXTENSION:
+		{
+			if (sizeof(u32) == property_hdr->sz &&
+				encoder->codec.codec == VCD_CODEC_MPEG4
+				) {
+				encoder->hdr_ext_control = *(u32 *)
+					property_value;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_ENTROPY_CTRL:
+		{
+			struct vcd_property_entropy_control
+				*entropy_control =
+				(struct vcd_property_entropy_control *)
+				property_value;
+			if (sizeof(struct vcd_property_entropy_control) ==
+				property_hdr->sz &&
+				encoder->codec.codec == VCD_CODEC_H264
+				&& entropy_control->
+				entropy_sel >= VCD_ENTROPY_SEL_CAVLC &&
+				entropy_control->entropy_sel <=
+				VCD_ENTROPY_SEL_CABAC) {
+				encoder->entropy_control = *entropy_control;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_DEBLOCKING:
+		{
+			struct vcd_property_db_config *dbconfig =
+				(struct vcd_property_db_config *)
+				property_value;
+			if (sizeof(struct vcd_property_db_config) ==
+				property_hdr->sz &&
+				encoder->codec.codec == VCD_CODEC_H264
+				&& dbconfig->db_config >=
+				VCD_DB_ALL_BLOCKING_BOUNDARY
+				&& dbconfig->db_config <=
+				VCD_DB_SKIP_SLICE_BOUNDARY
+				) {
+				encoder->db_control = *dbconfig;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_QP_RANGE:
+		{
+			struct vcd_property_qp_range *qp =
+				(struct vcd_property_qp_range *)
+				property_value;
+			if ((sizeof(struct vcd_property_qp_range) ==
+				property_hdr->sz) &&
+				(qp->min_qp <= qp->max_qp) &&
+				(
+				(encoder->codec.codec == VCD_CODEC_H264
+				&& qp->max_qp <= DDL_MAX_H264_QP) ||
+				(qp->max_qp <= DDL_MAX_MPEG4_QP)
+				)
+				) {
+				encoder->qp_range = *qp;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_SESSION_QP:
+		{
+			struct vcd_property_session_qp *qp =
+				(struct vcd_property_session_qp *)
+				property_value;
+
+		if ((sizeof(struct vcd_property_session_qp) ==
+			property_hdr->sz) &&
+			(qp->i_frame_qp >= encoder->qp_range.min_qp) &&
+			(qp->i_frame_qp <= encoder->qp_range.max_qp) &&
+			(qp->p_frame_qp >= encoder->qp_range.min_qp) &&
+			(qp->p_frame_qp <= encoder->qp_range.max_qp)
+			) {
+			encoder->session_qp = *qp;
+			vcd_status = VCD_S_SUCCESS;
+		}
+
+			break;
+		}
+	case VCD_I_RC_LEVEL_CONFIG:
+		{
+			struct vcd_property_rc_level *rc_level =
+				(struct vcd_property_rc_level *)
+				property_value;
+			if (sizeof(struct vcd_property_rc_level) ==
+				property_hdr->sz &&
+				(
+				encoder->rc.
+				rate_control >= VCD_RATE_CONTROL_VBR_VFR ||
+				encoder->rc.
+				rate_control <= VCD_RATE_CONTROL_CBR_VFR
+				) &&
+				(!rc_level->mb_level_rc ||
+				encoder->codec.codec == VCD_CODEC_H264
+				)
+				) {
+				encoder->rc_level = *rc_level;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_LEVEL_RC:
+		{
+
+		struct vcd_property_frame_level_rc_params
+			*frame_levelrc =
+			(struct vcd_property_frame_level_rc_params *)
+			property_value;
+
+			if ((sizeof(struct
+				vcd_property_frame_level_rc_params)
+				== property_hdr->sz) &&
+				(frame_levelrc->reaction_coeff) &&
+				(encoder->rc_level.frame_level_rc)
+				) {
+				encoder->frame_level_rc = *frame_levelrc;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_ADAPTIVE_RC:
+		{
+
+		if ((sizeof(struct
+			vcd_property_adaptive_rc_params)
+			== property_hdr->sz) &&
+			(encoder->codec.
+			codec == VCD_CODEC_H264) &&
+			(encoder->rc_level.mb_level_rc)) {
+
+			encoder->adaptive_rc =
+				*(struct vcd_property_adaptive_rc_params *)
+				property_value;
+
+			vcd_status = VCD_S_SUCCESS;
+		}
+
+			break;
+		}
+	case VCD_I_BUFFER_FORMAT:
+		{
+			struct vcd_property_buffer_format *tile =
+				(struct vcd_property_buffer_format *)
+				property_value;
+			if (sizeof(struct vcd_property_buffer_format) ==
+				property_hdr->sz &&
+				tile->buffer_format ==
+				VCD_BUFFER_FORMAT_NV12) {
+				encoder->buf_format = *tile;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_INPUT_BUF_REQ:
+		{
+			struct vcd_buffer_requirement *buffer_req =
+				(struct vcd_buffer_requirement *)
+				property_value;
+			if (sizeof(struct vcd_buffer_requirement) ==
+				property_hdr->sz &&
+				(ddl_valid_buffer_requirement(
+				&encoder->input_buf_req, buffer_req))
+				) {
+				encoder->client_input_buf_req = *buffer_req;
+				encoder->client_input_buf_req.min_count =
+					encoder->input_buf_req.min_count;
+				encoder->client_input_buf_req.max_count =
+					encoder->input_buf_req.max_count;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_OUTPUT_BUF_REQ:
+		{
+			struct vcd_buffer_requirement *buffer_req =
+				(struct vcd_buffer_requirement *)
+				property_value;
+			if (sizeof(struct vcd_buffer_requirement) ==
+				property_hdr->sz &&
+				(ddl_valid_buffer_requirement(
+				&encoder->output_buf_req, buffer_req))
+				) {
+				encoder->client_output_buf_req =
+					*buffer_req;
+				encoder->client_output_buf_req.min_count =
+					encoder->output_buf_req.min_count;
+				encoder->client_output_buf_req.max_count =
+					encoder->output_buf_req.max_count;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_METADATA_ENABLE:
+	case VCD_I_METADATA_HEADER:
+		{
+			vcd_status = ddl_set_metadata_params(
+				ddl, property_hdr, property_value);
+			break;
+		}
+	case VCD_I_META_BUFFER_MODE:
+		{
+			vcd_status = VCD_S_SUCCESS;
+			break;
+		}
+	default:
+		{
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+			break;
+		}
+	}
+	return vcd_status;
+}
+
+static u32 ddl_get_dec_property
+    (struct ddl_client_context *ddl,
+     struct vcd_property_hdr *property_hdr, void *property_value) {
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+
+	switch (property_hdr->prop_id) {
+	case VCD_I_FRAME_SIZE:
+		{
+			struct vcd_property_frame_size *fz_size;
+			if (sizeof(struct vcd_property_frame_size) ==
+			    property_hdr->sz) {
+					ddl_calculate_stride(
+					&decoder->client_frame_size,
+					!decoder->progressive_only,
+					decoder->codec.codec);
+					if (decoder->buf_format.buffer_format
+						== VCD_BUFFER_FORMAT_TILE_4x2) {
+						fz_size =
+						&decoder->client_frame_size;
+						fz_size->stride =
+						DDL_TILE_ALIGN(fz_size->width,
+							DDL_TILE_ALIGN_WIDTH);
+						fz_size->scan_lines =
+						DDL_TILE_ALIGN(fz_size->height,
+							DDL_TILE_ALIGN_HEIGHT);
+					}
+					*(struct vcd_property_frame_size *)
+						property_value =
+						decoder->client_frame_size;
+					vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_PROFILE:
+		{
+			if (sizeof(struct vcd_property_profile) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_profile *)
+				    property_value = decoder->profile;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_LEVEL:
+		{
+			if (sizeof(struct vcd_property_level) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_level *)
+				    property_value = decoder->level;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_PROGRESSIVE_ONLY:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				*(u32 *) property_value =
+				    decoder->progressive_only;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_INPUT_BUF_REQ:
+		{
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz) {
+				*(struct vcd_buffer_requirement *)
+				    property_value =
+						decoder->client_input_buf_req;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_OUTPUT_BUF_REQ:
+		{
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz) {
+				*(struct vcd_buffer_requirement *)
+				    property_value =
+						decoder->client_output_buf_req;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_CODEC:
+		{
+			if (sizeof(struct vcd_property_codec) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_codec *)
+				    property_value = decoder->codec;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_BUFFER_FORMAT:
+		{
+			if (sizeof(struct vcd_property_buffer_format) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_buffer_format *)
+				    property_value = decoder->buf_format;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_POST_FILTER:
+		{
+			if (sizeof(struct vcd_property_post_filter) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_post_filter *)
+				    property_value = decoder->post_filter;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_SEQHDR_ALIGN_BYTES:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				*(u32 *) property_value =
+				    DDL_LINEAR_BUFFER_ALIGN_BYTES;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_FRAME_PROC_UNITS:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				struct vcd_property_frame_size frame_sz =
+					decoder->client_frame_size;
+				ddl_calculate_stride(&frame_sz,
+					!decoder->progressive_only,
+					decoder->codec.codec);
+				*(u32 *) property_value =
+				    ((frame_sz.stride >> 4) *
+				     (frame_sz.scan_lines >> 4));
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_DPB_RETRIEVE:
+		{
+			if (sizeof(struct ddl_frame_data_tag) ==
+			    property_hdr->sz) {
+				vcd_status =
+				    ddl_decoder_dpb_transact(decoder,
+					 (struct ddl_frame_data_tag *)
+					     property_value,
+					     DDL_DPB_OP_RETRIEVE);
+			}
+			break;
+		}
+	case VCD_I_OUTPUT_ORDER:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				*(u32 *)property_value = decoder->output_order;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_METADATA_ENABLE:
+	case VCD_I_METADATA_HEADER:
+		{
+			vcd_status = ddl_get_metadata_params(
+						   ddl,
+						   property_hdr,
+						   property_value);
+			break;
+		}
+	default:
+		{
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+			break;
+		}
+	}
+	return vcd_status;
+}
+
+static u32 ddl_get_enc_property
+    (struct ddl_client_context *ddl,
+     struct vcd_property_hdr *property_hdr, void *property_value) {
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM;
+	struct ddl_encoder_data *encoder = &ddl->codec_data.encoder;
+
+	struct vcd_property_entropy_control *entropy_control;
+	struct vcd_property_intra_refresh_mb_number *intra_refresh;
+
+	switch (property_hdr->prop_id) {
+	case VCD_I_CODEC:
+		{
+			if (sizeof(struct vcd_property_codec) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_codec *)
+					property_value =
+					encoder->codec;
+		    vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_SIZE:
+		{
+			if (sizeof(struct vcd_property_frame_size) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_frame_size *)
+					property_value =
+					encoder->frame_size;
+
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_RATE:
+		{
+			if (sizeof(struct vcd_property_frame_rate) ==
+				property_hdr->sz) {
+
+				*(struct vcd_property_frame_rate *)
+					property_value =
+					encoder->frame_rate;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_TARGET_BITRATE:
+		{
+
+			if (sizeof(struct vcd_property_target_bitrate) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_target_bitrate *)
+					property_value =
+					encoder->target_bit_rate;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_RATE_CONTROL:
+		{
+			if (sizeof(struct vcd_property_rate_control) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_rate_control *)
+				    property_value = encoder->rc;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_PROFILE:
+		{
+			if (sizeof(struct vcd_property_profile) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_profile *)
+				    property_value = encoder->profile;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_LEVEL:
+		{
+			if (sizeof(struct vcd_property_level) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_level *)
+				    property_value = encoder->level;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_MULTI_SLICE:
+		{
+			if (sizeof(struct vcd_property_multi_slice) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_multi_slice *)
+				    property_value = encoder->multi_slice;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_SEQ_HEADER:
+		{
+			struct vcd_sequence_hdr *seq_hdr =
+			    (struct vcd_sequence_hdr *)property_value;
+			if (encoder->seq_header.buffer_size &&
+			    sizeof(struct vcd_sequence_hdr) ==
+			    property_hdr->sz
+			    && encoder->seq_header.buffer_size <=
+			    seq_hdr->sequence_header_len) {
+				DDL_MEMCPY(seq_hdr->sequence_header,
+					   encoder->seq_header.
+					   align_virtual_addr,
+					   encoder->seq_header.buffer_size);
+				seq_hdr->sequence_header_len =
+				    encoder->seq_header.buffer_size;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_SEQHDR_PRESENT:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				if ((encoder->codec.
+					codec == VCD_CODEC_MPEG4 &&
+					!encoder->short_header.short_header)
+					|| encoder->codec.codec ==
+					VCD_CODEC_H264) {
+					*(u32 *)property_value = 0x1;
+				} else {
+					*(u32 *)property_value = 0x0;
+				}
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_VOP_TIMING:
+		{
+			if (sizeof(struct vcd_property_vop_timing) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_vop_timing *)
+				    property_value = encoder->vop_timing;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_SHORT_HEADER:
+		{
+			if (sizeof(struct vcd_property_short_header) ==
+			    property_hdr->sz) {
+				if (encoder->codec.codec ==
+					VCD_CODEC_MPEG4) {
+					*(struct vcd_property_short_header
+					  *)property_value =
+						encoder->short_header;
+					vcd_status = VCD_S_SUCCESS;
+				} else {
+					vcd_status = VCD_ERR_ILLEGAL_OP;
+				}
+			}
+			break;
+		}
+	case VCD_I_ENTROPY_CTRL:
+		{
+			entropy_control = property_value;
+			if (sizeof(struct vcd_property_entropy_control) ==
+			    property_hdr->sz) {
+				if (encoder->codec.codec ==
+					VCD_CODEC_H264) {
+					*entropy_control =
+				     encoder->entropy_control;
+					vcd_status = VCD_S_SUCCESS;
+				} else {
+					vcd_status = VCD_ERR_ILLEGAL_OP;
+				}
+			}
+			break;
+		}
+	case VCD_I_DEBLOCKING:
+		{
+			if (sizeof(struct vcd_property_db_config) ==
+			    property_hdr->sz) {
+				if (encoder->codec.codec ==
+					VCD_CODEC_H264) {
+					*(struct vcd_property_db_config *)
+					    property_value =
+					    encoder->db_control;
+					vcd_status = VCD_S_SUCCESS;
+				} else {
+					vcd_status = VCD_ERR_ILLEGAL_OP;
+				}
+			}
+			break;
+		}
+	case VCD_I_INTRA_PERIOD:
+		{
+			if (sizeof(struct vcd_property_i_period) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_i_period *)
+				    property_value = encoder->i_period;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_QP_RANGE:
+		{
+			if (sizeof(struct vcd_property_qp_range) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_qp_range *)
+				    property_value = encoder->qp_range;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_SESSION_QP:
+		{
+			if (sizeof(struct vcd_property_session_qp) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_session_qp *)
+				    property_value = encoder->session_qp;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_RC_LEVEL_CONFIG:
+		{
+			if (sizeof(struct vcd_property_rc_level) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_rc_level *)
+				    property_value = encoder->rc_level;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_LEVEL_RC:
+		{
+			if (sizeof
+			    (struct vcd_property_frame_level_rc_params) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_frame_level_rc_params
+				 *)property_value =
+				 encoder->frame_level_rc;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_ADAPTIVE_RC:
+		{
+			if (sizeof(struct vcd_property_adaptive_rc_params)
+			    == property_hdr->sz) {
+				*(struct vcd_property_adaptive_rc_params *)
+				    property_value = encoder->adaptive_rc;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_INTRA_REFRESH:
+		{
+			intra_refresh = property_value;
+			if (sizeof
+			    (struct vcd_property_intra_refresh_mb_number)
+			    == property_hdr->sz) {
+				*intra_refresh = encoder->intra_refresh;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_INPUT_BUF_REQ:
+		{
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz) {
+				*(struct vcd_buffer_requirement *)
+				    property_value =
+						encoder->client_input_buf_req;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_OUTPUT_BUF_REQ:
+		{
+			if (sizeof(struct vcd_buffer_requirement) ==
+			    property_hdr->sz) {
+				*(struct vcd_buffer_requirement *)
+				    property_value =
+						encoder->client_output_buf_req;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_BUFFER_FORMAT:
+		{
+			if (sizeof(struct vcd_property_buffer_format) ==
+			    property_hdr->sz) {
+				*(struct vcd_property_buffer_format *)
+				    property_value = encoder->buf_format;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case DDL_I_FRAME_PROC_UNITS:
+		{
+			if (sizeof(u32) == property_hdr->sz) {
+				*(u32 *) property_value =
+				    ((encoder->frame_size.width >> 4) *
+				     (encoder->frame_size.height >> 4)
+				    );
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_HEADER_EXTENSION:
+		{
+			if (sizeof(u32) == property_hdr->sz &&
+			    encoder->codec.codec == VCD_CODEC_MPEG4) {
+				*(u32 *) property_value =
+				    encoder->hdr_ext_control;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_METADATA_ENABLE:
+	case VCD_I_METADATA_HEADER:
+		{
+			vcd_status = ddl_get_metadata_params(
+						   ddl,
+						   property_hdr,
+						   property_value);
+			break;
+		}
+	default:
+		{
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+			break;
+		}
+	}
+	return vcd_status;
+}
+
+static u32 ddl_set_enc_dynamic_property
+    (struct ddl_client_context *ddl,
+     struct vcd_property_hdr *property_hdr, void *property_value) {
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+	u32 vcd_status = VCD_ERR_ILLEGAL_PARM, dynamic_prop_change = 0x0;
+	switch (property_hdr->prop_id) {
+	case VCD_I_REQ_IFRAME:
+		{
+			if (sizeof(struct vcd_property_req_i_frame) ==
+			    property_hdr->sz) {
+				dynamic_prop_change = DDL_ENC_REQ_IFRAME;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_TARGET_BITRATE:
+		{
+		    struct vcd_property_target_bitrate *bitrate =
+				(struct vcd_property_target_bitrate *)
+				property_value;
+			if (sizeof(struct vcd_property_target_bitrate) ==
+			 property_hdr->sz && bitrate->target_bitrate > 0
+			 && bitrate->target_bitrate <= DDL_MAX_BIT_RATE) {
+				encoder->target_bit_rate = *bitrate;
+				dynamic_prop_change = DDL_ENC_CHANGE_BITRATE;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_INTRA_PERIOD:
+		{
+			struct vcd_property_i_period *iperiod =
+				(struct vcd_property_i_period *)
+				property_value;
+			if (sizeof(struct vcd_property_i_period) ==
+				property_hdr->sz &&
+				!iperiod->b_frames) {
+				encoder->i_period = *iperiod;
+				dynamic_prop_change = DDL_ENC_CHANGE_IPERIOD;
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_FRAME_RATE:
+		{
+			struct vcd_property_frame_rate *frame_rate =
+			    (struct vcd_property_frame_rate *)
+			    property_value;
+			if (sizeof(struct vcd_property_frame_rate)
+			    == property_hdr->sz &&
+			    frame_rate->fps_denominator &&
+			    frame_rate->fps_numerator &&
+			    frame_rate->fps_denominator <=
+			    frame_rate->fps_numerator) {
+				encoder->frame_rate = *frame_rate;
+				dynamic_prop_change = DDL_ENC_CHANGE_FRAMERATE;
+				if (DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_OPEN) &&
+					(encoder->codec.codec != VCD_CODEC_MPEG4
+					 || encoder->short_header.short_header))
+					ddl_set_default_enc_vop_timing(encoder);
+				vcd_status = VCD_S_SUCCESS;
+			}
+			break;
+		}
+	case VCD_I_INTRA_REFRESH:
+		{
+			struct vcd_property_intra_refresh_mb_number
+				*intra_refresh_mbnum = (
+				struct vcd_property_intra_refresh_mb_number *)
+					property_value;
+			u32 frame_mbnum =
+				(encoder->frame_size.width >> 4) *
+				(encoder->frame_size.height >> 4);
+			if (sizeof(struct
+				vcd_property_intra_refresh_mb_number)
+				== property_hdr->sz &&
+				intra_refresh_mbnum->cir_mb_number <=
+				frame_mbnum) {
+				encoder->intra_refresh =
+					*intra_refresh_mbnum;
+				dynamic_prop_change = DDL_ENC_CHANGE_CIR;
+				vcd_status = VCD_S_SUCCESS;
+			}
+
+			break;
+		}
+	default:
+		{
+			vcd_status = VCD_ERR_ILLEGAL_OP;
+			break;
+		}
+	}
+	if (vcd_status == VCD_S_SUCCESS &&
+	(DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME) ||
+	DDLCLIENT_STATE_IS(ddl, DDL_CLIENT_WAIT_FOR_FRAME_DONE)))
+		encoder->dynamic_prop_change |= dynamic_prop_change;
+	return vcd_status;
+}
+
+void ddl_set_default_dec_property(struct ddl_client_context *ddl)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+
+	if (decoder->codec.codec >= VCD_CODEC_MPEG2 &&
+		decoder->codec.codec <=  VCD_CODEC_XVID)
+		decoder->post_filter.post_filter = true;
+	else
+		decoder->post_filter.post_filter = false;
+	decoder->buf_format.buffer_format = VCD_BUFFER_FORMAT_NV12;
+	decoder->client_frame_size.height = 144;
+	decoder->client_frame_size.width = 176;
+	decoder->client_frame_size.stride = 176;
+	decoder->client_frame_size.scan_lines = 144;
+	decoder->progressive_only = 1;
+	decoder->idr_only_decoding = 0;
+	decoder->profile.profile = VCD_PROFILE_UNKNOWN;
+	decoder->level.level = VCD_LEVEL_UNKNOWN;
+	decoder->output_order = VCD_DEC_ORDER_DISPLAY;
+	ddl_set_default_metadata_flag(ddl);
+	ddl_set_default_decoder_buffer_req(decoder, true);
+}
+
+static void ddl_set_default_enc_property(struct ddl_client_context *ddl)
+{
+	struct ddl_encoder_data *encoder = &(ddl->codec_data.encoder);
+
+	ddl_set_default_enc_profile(encoder);
+	ddl_set_default_enc_level(encoder);
+
+	encoder->rc.rate_control = VCD_RATE_CONTROL_VBR_VFR;
+	ddl_set_default_enc_rc_params(encoder);
+
+	ddl_set_default_enc_intra_period(encoder);
+
+	encoder->intra_refresh.cir_mb_number = 0;
+	ddl_set_default_enc_vop_timing(encoder);
+
+	encoder->multi_slice.m_slice_sel = VCD_MSLICE_OFF;
+	encoder->multi_slice.m_slice_size = 0;
+	encoder->short_header.short_header = false;
+
+	encoder->entropy_control.entropy_sel = VCD_ENTROPY_SEL_CAVLC;
+	encoder->entropy_control.cabac_model = VCD_CABAC_MODEL_NUMBER_0;
+	encoder->db_control.db_config = VCD_DB_ALL_BLOCKING_BOUNDARY;
+	encoder->db_control.slice_alpha_offset = 0;
+	encoder->db_control.slice_beta_offset = 0;
+
+	encoder->re_con_buf_format.buffer_format =
+		VCD_BUFFER_FORMAT_TILE_4x2;
+
+	encoder->buf_format.buffer_format = VCD_BUFFER_FORMAT_NV12;
+
+	encoder->hdr_ext_control = 0;
+
+	ddl_set_default_metadata_flag(ddl);
+
+	ddl_set_default_encoder_buffer_req(encoder);
+}
+
+static void ddl_set_default_enc_profile(struct ddl_encoder_data *encoder)
+{
+	enum vcd_codec codec = encoder->codec.codec;
+	if (codec == VCD_CODEC_MPEG4)
+		encoder->profile.profile = VCD_PROFILE_MPEG4_SP;
+	else if (codec == VCD_CODEC_H264)
+		encoder->profile.profile = VCD_PROFILE_H264_BASELINE;
+	else
+		encoder->profile.profile = VCD_PROFILE_H263_BASELINE;
+}
+
+static void ddl_set_default_enc_level(struct ddl_encoder_data *encoder)
+{
+	enum vcd_codec codec = encoder->codec.codec;
+	if (codec == VCD_CODEC_MPEG4)
+		encoder->level.level = VCD_LEVEL_MPEG4_1;
+	else if (codec == VCD_CODEC_H264)
+		encoder->level.level = VCD_LEVEL_H264_1;
+	else
+		encoder->level.level = VCD_LEVEL_H263_10;
+}
+
+static void ddl_set_default_enc_vop_timing
+    (struct ddl_encoder_data *encoder)
+{
+	if (encoder->codec.codec == VCD_CODEC_MPEG4)
+		encoder->vop_timing.vop_time_resolution =
+		    (2 * encoder->frame_rate.fps_numerator) /
+		    encoder->frame_rate.fps_denominator;
+	else
+		encoder->vop_timing.vop_time_resolution = 0x7530;
+}
+
+static void ddl_set_default_enc_intra_period(
+		struct ddl_encoder_data *encoder)
+{
+	switch (encoder->rc.rate_control) {
+	default:
+	case VCD_RATE_CONTROL_VBR_VFR:
+	case VCD_RATE_CONTROL_VBR_CFR:
+	case VCD_RATE_CONTROL_CBR_VFR:
+	case VCD_RATE_CONTROL_OFF:
+		{
+			encoder->i_period.p_frames =
+			    ((encoder->frame_rate.fps_numerator << 1) /
+			     encoder->frame_rate.fps_denominator) - 1;
+			break;
+		}
+	case VCD_RATE_CONTROL_CBR_CFR:
+		{
+			encoder->i_period.p_frames =
+			    ((encoder->frame_rate.fps_numerator >> 1) /
+			     encoder->frame_rate.fps_denominator) - 1;
+			break;
+		}
+	}
+	encoder->i_period.b_frames = 0;
+}
+
+static void ddl_set_default_enc_rc_params(
+		struct ddl_encoder_data *encoder)
+{
+	enum vcd_codec codec = encoder->codec.codec;
+
+	encoder->rc_level.frame_level_rc = true;
+	encoder->qp_range.min_qp = 0x1;
+
+	if (codec == VCD_CODEC_H264) {
+		encoder->qp_range.max_qp = 0x33;
+		encoder->session_qp.i_frame_qp = 0x14;
+		encoder->session_qp.p_frame_qp = 0x14;
+
+		encoder->rc_level.mb_level_rc = true;
+		encoder->adaptive_rc.activity_region_flag = true;
+		encoder->adaptive_rc.dark_region_as_flag = true;
+		encoder->adaptive_rc.smooth_region_as_flag = true;
+		encoder->adaptive_rc.static_region_as_flag = true;
+	} else {
+		encoder->qp_range.max_qp = 0x1f;
+		encoder->session_qp.i_frame_qp = 0xd;
+		encoder->session_qp.p_frame_qp = 0xd;
+		encoder->rc_level.mb_level_rc = false;
+	}
+
+	switch (encoder->rc.rate_control) {
+	default:
+	case VCD_RATE_CONTROL_VBR_VFR:
+		{
+			encoder->r_cframe_skip = 1;
+			encoder->frame_level_rc.reaction_coeff = 0x1f4;
+			break;
+		}
+	case VCD_RATE_CONTROL_VBR_CFR:
+		{
+			encoder->r_cframe_skip = 0;
+			encoder->frame_level_rc.reaction_coeff = 0x1f4;
+			break;
+		}
+	case VCD_RATE_CONTROL_CBR_VFR:
+		{
+			encoder->r_cframe_skip = 1;
+			if (codec != VCD_CODEC_H264) {
+				encoder->session_qp.i_frame_qp = 0xf;
+				encoder->session_qp.p_frame_qp = 0xf;
+			}
+
+			encoder->frame_level_rc.reaction_coeff = 0x14;
+			break;
+		}
+	case VCD_RATE_CONTROL_CBR_CFR:
+		{
+			encoder->r_cframe_skip = 0;
+			encoder->frame_level_rc.reaction_coeff = 0x6;
+			break;
+		}
+	case VCD_RATE_CONTROL_OFF:
+		{
+			encoder->r_cframe_skip = 0;
+			encoder->rc_level.frame_level_rc = false;
+			encoder->rc_level.mb_level_rc = false;
+			break;
+		}
+	}
+}
+
+void ddl_set_default_encoder_buffer_req(struct ddl_encoder_data *encoder)
+{
+	u32 y_cb_cr_size;
+
+	y_cb_cr_size = ddl_get_yuv_buffer_size(&encoder->frame_size,
+		&encoder->buf_format, false, encoder->codec.codec);
+
+	memset(&encoder->input_buf_req, 0,
+	       sizeof(struct vcd_buffer_requirement));
+
+	encoder->input_buf_req.min_count = 1;
+	encoder->input_buf_req.actual_count =
+	    encoder->input_buf_req.min_count + 8;
+	encoder->input_buf_req.max_count = DDL_MAX_BUFFER_COUNT;
+	encoder->input_buf_req.sz = y_cb_cr_size;
+	encoder->input_buf_req.align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
+
+	encoder->client_input_buf_req = encoder->input_buf_req;
+
+	memset(&encoder->output_buf_req, 0,
+	       sizeof(struct vcd_buffer_requirement));
+
+	encoder->output_buf_req.min_count = 2;
+	encoder->output_buf_req.actual_count =
+	    encoder->output_buf_req.min_count + 3;
+	encoder->output_buf_req.max_count = DDL_MAX_BUFFER_COUNT;
+	encoder->output_buf_req.align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
+	encoder->output_buf_req.sz = y_cb_cr_size;
+	ddl_set_default_encoder_metadata_buffer_size(encoder);
+	encoder->client_output_buf_req = encoder->output_buf_req;
+}
+
+void ddl_set_default_decoder_buffer_req(struct ddl_decoder_data *decoder,
+		u32 estimate)
+{
+	u32 y_cb_cr_size, min_dpb, num_mb;
+	struct vcd_property_frame_size  *frame_size;
+	struct vcd_buffer_requirement *output_buf_req, *input_buf_req;
+
+	if (!decoder->codec.codec)
+		return;
+
+	if (estimate) {
+		frame_size = &decoder->client_frame_size;
+		output_buf_req = &decoder->client_output_buf_req;
+		input_buf_req = &decoder->client_input_buf_req;
+		min_dpb = ddl_decoder_min_num_dpb(decoder);
+		 y_cb_cr_size = ddl_get_yuv_buffer_size(frame_size,
+			&decoder->buf_format, (!decoder->progressive_only),
+			decoder->codec.codec);
+	} else {
+		frame_size = &decoder->frame_size;
+		output_buf_req = &decoder->actual_output_buf_req;
+		input_buf_req = &decoder->actual_input_buf_req;
+		y_cb_cr_size = decoder->y_cb_cr_size;
+		min_dpb = decoder->min_dpb_num;
+	}
+
+	if (decoder->idr_only_decoding)
+		min_dpb = 1;
+
+	memset(output_buf_req, 0, sizeof(struct vcd_buffer_requirement));
+
+	output_buf_req->min_count = min_dpb;
+
+	num_mb = DDL_NO_OF_MB(frame_size->width, frame_size->height);
+	if (decoder->idr_only_decoding) {
+		output_buf_req->actual_count = output_buf_req->min_count;
+	} else {
+		if (num_mb >= DDL_WVGA_MBS) {
+			output_buf_req->actual_count = min_dpb + 2;
+			if (output_buf_req->actual_count < 10)
+				output_buf_req->actual_count = 10;
+		} else
+			output_buf_req->actual_count = min_dpb + 5;
+	}
+	output_buf_req->max_count = DDL_MAX_BUFFER_COUNT;
+	output_buf_req->sz = y_cb_cr_size;
+	if (decoder->buf_format.buffer_format != VCD_BUFFER_FORMAT_NV12)
+		output_buf_req->align = DDL_TILE_BUFFER_ALIGN_BYTES;
+	else
+		output_buf_req->align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
+
+	ddl_set_default_decoder_metadata_buffer_size(decoder,
+		frame_size, output_buf_req);
+
+	decoder->min_output_buf_req = *output_buf_req;
+
+	memset(input_buf_req, 0, sizeof(struct vcd_buffer_requirement));
+
+	input_buf_req->min_count = 1;
+	input_buf_req->actual_count = input_buf_req->min_count + 3;
+	input_buf_req->max_count = DDL_MAX_BUFFER_COUNT;
+	input_buf_req->sz = (1280*720*3*3) >> 3;
+	input_buf_req->align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
+
+	decoder->min_input_buf_req = *input_buf_req;
+
+}
+
+u32 ddl_get_yuv_buffer_size(struct vcd_property_frame_size *frame_size,
+     struct vcd_property_buffer_format *buf_format, u32 inter_lace,
+     enum vcd_codec codec)
+{
+	struct vcd_property_frame_size frame_sz = *frame_size;
+	u32 total_memory_size;
+	ddl_calculate_stride(&frame_sz, inter_lace, codec);
+
+	if (buf_format->buffer_format != VCD_BUFFER_FORMAT_NV12) {
+		u32 component_mem_size;
+		u32 width_round_up;
+		u32 height_round_up;
+		u32 height_chroma = (frame_sz.scan_lines >> 1);
+
+		width_round_up =
+		    DDL_TILE_ALIGN(frame_sz.stride, DDL_TILE_ALIGN_WIDTH);
+		height_round_up =
+		    DDL_TILE_ALIGN(frame_sz.scan_lines, DDL_TILE_ALIGN_HEIGHT);
+
+		component_mem_size = width_round_up * height_round_up;
+		component_mem_size = DDL_TILE_ALIGN(component_mem_size,
+						      DDL_TILE_MULTIPLY_FACTOR);
+
+		total_memory_size = ((component_mem_size +
+					 DDL_TILE_BUF_ALIGN_GUARD_BYTES) &
+					DDL_TILE_BUF_ALIGN_MASK);
+
+		height_round_up =
+		    DDL_TILE_ALIGN(height_chroma, DDL_TILE_ALIGN_HEIGHT);
+		component_mem_size = width_round_up * height_round_up;
+		component_mem_size = DDL_TILE_ALIGN(component_mem_size,
+						      DDL_TILE_MULTIPLY_FACTOR);
+		total_memory_size += component_mem_size;
+	} else {
+		total_memory_size = frame_sz.scan_lines * frame_sz.stride;
+		total_memory_size += (total_memory_size >> 1);
+	}
+	return total_memory_size;
+}
+
+void ddl_calculate_stride(struct vcd_property_frame_size *frame_size,
+	u32 interlace, enum vcd_codec codec)
+{
+	frame_size->stride = ((frame_size->width + 15) >> 4) << 4;
+	if (!interlace || codec == VCD_CODEC_MPEG4 ||
+		codec == VCD_CODEC_DIVX_4 ||
+		codec == VCD_CODEC_DIVX_5 ||
+		codec == VCD_CODEC_DIVX_6 ||
+		codec == VCD_CODEC_XVID) {
+		frame_size->scan_lines =
+			((frame_size->height + 15) >> 4) << 4;
+	} else {
+		frame_size->scan_lines =
+			((frame_size->height + 31) >> 5) << 5;
+	}
+
+}
+
+static u32 ddl_valid_buffer_requirement
+	(struct vcd_buffer_requirement *original_buf_req,
+	struct vcd_buffer_requirement *req_buf_req)
+{
+	u32 status = false;
+	if (original_buf_req->max_count >= req_buf_req->actual_count &&
+		original_buf_req->min_count <= req_buf_req->actual_count &&
+		original_buf_req->align <= req_buf_req->align &&
+		original_buf_req->sz <= req_buf_req->sz) {
+		status = true;
+	} else {
+		VIDC_LOGERR_STRING("ddl_valid_buf_req:Failed");
+	}
+	return status;
+}
+
+static u32 ddl_decoder_min_num_dpb(struct ddl_decoder_data *decoder)
+{
+	u32 min_dpb = 0, yuv_size = 0;
+	struct vcd_property_frame_size frame_sz = decoder->client_frame_size;
+	switch (decoder->codec.codec) {
+	default:
+	case VCD_CODEC_MPEG4:
+	case VCD_CODEC_MPEG2:
+	case VCD_CODEC_DIVX_4:
+	case VCD_CODEC_DIVX_5:
+	case VCD_CODEC_DIVX_6:
+	case VCD_CODEC_XVID:
+		{
+			min_dpb = 3;
+			break;
+		}
+	case VCD_CODEC_H263:
+		{
+			min_dpb = 2;
+			break;
+		}
+	case VCD_CODEC_VC1:
+	case VCD_CODEC_VC1_RCV:
+		{
+			min_dpb = 4;
+			break;
+		}
+	case VCD_CODEC_H264:
+		{
+			ddl_calculate_stride(&frame_sz,
+				!decoder->progressive_only,
+				decoder->codec.codec);
+			yuv_size =
+			    ((frame_sz.scan_lines *
+			      frame_sz.stride * 3) >> 1);
+			min_dpb = 6912000 / yuv_size;
+			if (min_dpb > 16)
+				min_dpb = 16;
+
+			min_dpb += 2;
+			break;
+		}
+	}
+	return min_dpb;
+}
+
+static u32 ddl_set_dec_buffers
+    (struct ddl_decoder_data *decoder,
+     struct ddl_property_dec_pic_buffers *dpb) {
+	u32 vcd_status = VCD_S_SUCCESS;
+	u32 loopc;
+	for (loopc = 0; !vcd_status &&
+	     loopc < dpb->no_of_dec_pic_buf; ++loopc) {
+		if ((!DDL_ADDR_IS_ALIGNED
+		     (dpb->dec_pic_buffers[loopc].vcd_frm.physical,
+		      decoder->client_output_buf_req.align)
+		    )
+		    || (dpb->dec_pic_buffers[loopc].vcd_frm.alloc_len <
+			decoder->client_output_buf_req.sz)
+		    ) {
+			vcd_status = VCD_ERR_ILLEGAL_PARM;
+		}
+	}
+	if (vcd_status) {
+		VIDC_LOGERR_STRING
+		    ("ddl_set_prop:Dpb_align_fail_or_alloc_size_small");
+		return vcd_status;
+	}
+	if (decoder->dp_buf.no_of_dec_pic_buf) {
+		DDL_FREE(decoder->dp_buf.dec_pic_buffers);
+		decoder->dp_buf.no_of_dec_pic_buf = 0;
+	}
+	decoder->dp_buf.dec_pic_buffers =
+	    DDL_MALLOC(dpb->no_of_dec_pic_buf *
+		       sizeof(struct ddl_frame_data_tag));
+
+	if (!decoder->dp_buf.dec_pic_buffers) {
+		VIDC_LOGERR_STRING
+		    ("ddl_dec_set_prop:Dpb_container_alloc_failed");
+		return VCD_ERR_ALLOC_FAIL;
+	}
+	decoder->dp_buf.no_of_dec_pic_buf = dpb->no_of_dec_pic_buf;
+	for (loopc = 0; loopc < dpb->no_of_dec_pic_buf; ++loopc) {
+		decoder->dp_buf.dec_pic_buffers[loopc] =
+		    dpb->dec_pic_buffers[loopc];
+	}
+	decoder->dpb_mask.client_mask = 0;
+	decoder->dpb_mask.hw_mask = 0;
+	decoder->dynamic_prop_change = 0;
+	return VCD_S_SUCCESS;
+}
+
+void ddl_set_initial_default_values(struct ddl_client_context *ddl)
+{
+	if (ddl->decoding) {
+		ddl->codec_data.decoder.codec.codec = VCD_CODEC_MPEG4;
+		vcd_fw_transact(true, true,
+			ddl->codec_data.decoder.codec.codec);
+		ddl_set_default_dec_property(ddl);
+	} else {
+		struct ddl_encoder_data *encoder =
+		    &(ddl->codec_data.encoder);
+		encoder->codec.codec = VCD_CODEC_MPEG4;
+		vcd_fw_transact(true, false,
+			encoder->codec.codec);
+
+		encoder->target_bit_rate.target_bitrate = 64000;
+		encoder->frame_size.width = 176;
+		encoder->frame_size.height = 144;
+		encoder->frame_size.stride = 176;
+		encoder->frame_size.scan_lines = 144;
+		encoder->frame_rate.fps_numerator = 30;
+		encoder->frame_rate.fps_denominator = 1;
+		ddl_set_default_enc_property(ddl);
+	}
+
+	return;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c
new file mode 100644
index 0000000..f5f5d7f
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c
@@ -0,0 +1,317 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/memory_alloc.h>
+#include <media/msm/vidc_type.h>
+#include "vcd_ddl_utils.h"
+#include "vcd_res_tracker_api.h"
+
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
+
+#define DBG_TIME(x...) printk(KERN_DEBUG x)
+#define ERR(x...) printk(KERN_ERR x)
+
+struct time_data {
+	unsigned int ddl_t1;
+	unsigned int ddl_ttotal;
+	unsigned int ddl_count;
+};
+
+static struct time_data proc_time[MAX_TIME_DATA];
+
+#ifdef NO_IN_KERNEL_PMEM
+
+void ddl_pmem_alloc(struct ddl_buf_addr *buff_addr, size_t sz, u32 align)
+{
+	u32 guard_bytes, align_mask;
+	u32 physical_addr, align_offset;
+	dma_addr_t phy_addr;
+
+	if (align == DDL_LINEAR_BUFFER_ALIGN_BYTES) {
+
+		guard_bytes = 31;
+		align_mask = 0xFFFFFFE0U;
+
+	} else {
+
+		guard_bytes = DDL_TILE_BUF_ALIGN_GUARD_BYTES;
+		align_mask = DDL_TILE_BUF_ALIGN_MASK;
+	}
+
+	buff_addr->virtual_base_addr =
+		kmalloc((sz + guard_bytes), GFP_KERNEL);
+
+	if (!buff_addr->virtual_base_addr) {
+		ERR("\n ERROR %s:%u kamlloc fails to allocate"
+			" sz + guard_bytes = %u\n", __func__, __LINE__,
+			(sz + guard_bytes));
+		return;
+	}
+
+	phy_addr = dma_map_single(NULL, buff_addr->virtual_base_addr,
+				  sz + guard_bytes, DMA_TO_DEVICE);
+
+	buff_addr->buffer_size = sz;
+	physical_addr = (u32) phy_addr;
+	buff_addr->align_physical_addr =
+	    (u32 *) ((physical_addr + guard_bytes) & align_mask);
+	align_offset =
+	    (u32) (buff_addr->align_physical_addr) - physical_addr;
+	buff_addr->align_virtual_addr =
+	    (u32 *) ((u32) (buff_addr->virtual_base_addr)
+		     + align_offset);
+}
+
+void ddl_pmem_free(struct ddl_buf_addr *buff_addr)
+{
+	kfree(buff_addr->virtual_base_addr);
+	buff_addr->buffer_size = 0;
+	buff_addr->virtual_base_addr = NULL;
+}
+
+#else
+
+void ddl_pmem_alloc(struct ddl_buf_addr *buff_addr, size_t sz, u32 align)
+{
+	u32 guard_bytes, align_mask;
+	u32 physical_addr;
+	u32 align_offset;
+	u32 alloc_size, flags = 0;
+	struct ddl_context *ddl_context;
+	struct msm_mapped_buffer *mapped_buffer = NULL;
+	unsigned long *kernel_vaddr = NULL;
+	ion_phys_addr_t phyaddr = 0;
+	size_t len = 0;
+	int ret = -EINVAL;
+
+	if (!buff_addr) {
+		ERR("\n%s() Invalid Parameters\n", __func__);
+		return;
+	}
+	if (align == DDL_LINEAR_BUFFER_ALIGN_BYTES) {
+		guard_bytes = 31;
+		align_mask = 0xFFFFFFE0U;
+	} else {
+		guard_bytes = DDL_TILE_BUF_ALIGN_GUARD_BYTES;
+		align_mask = DDL_TILE_BUF_ALIGN_MASK;
+	}
+	ddl_context = ddl_get_context();
+	alloc_size = sz + guard_bytes;
+	if (res_trk_get_enable_ion()) {
+		if (!ddl_context->video_ion_client)
+			ddl_context->video_ion_client =
+				res_trk_get_ion_client();
+		if (!ddl_context->video_ion_client) {
+			ERR("\n%s(): DDL ION Client Invalid handle\n",
+				__func__);
+			goto bailout;
+		}
+		buff_addr->mem_type = res_trk_get_mem_type();
+		buff_addr->alloc_handle = ion_alloc(
+					ddl_context->video_ion_client,
+					alloc_size,
+					SZ_4K,
+					buff_addr->mem_type, 0);
+		if (!buff_addr->alloc_handle) {
+			ERR("\n%s(): DDL ION alloc failed\n",
+					__func__);
+			goto bailout;
+		}
+		ret = ion_phys(ddl_context->video_ion_client,
+					buff_addr->alloc_handle,
+					&phyaddr,
+					&len);
+		if (ret || !phyaddr) {
+			ERR("\n%s(): DDL ION client physical failed\n",
+					__func__);
+			goto free_ion_buffer;
+		}
+		buff_addr->physical_base_addr = (u32 *)phyaddr;
+		kernel_vaddr = (unsigned long *) ion_map_kernel(
+					ddl_context->video_ion_client,
+					buff_addr->alloc_handle);
+		if (IS_ERR_OR_NULL(kernel_vaddr)) {
+			ERR("\n%s(): DDL ION map failed\n", __func__);
+			goto unmap_ion_buffer;
+		}
+		buff_addr->virtual_base_addr = (u32 *)kernel_vaddr;
+		DBG("ddl_ion_alloc: handle(0x%x), mem_type(0x%x), "\
+			"phys(0x%x), virt(0x%x), size(%u), align(%u), "\
+			"alloced_len(%u)", (u32)buff_addr->alloc_handle,
+			(u32)buff_addr->mem_type,
+			(u32)buff_addr->physical_base_addr,
+			(u32)buff_addr->virtual_base_addr,
+			alloc_size, align, len);
+	} else {
+		physical_addr = (u32)
+			allocate_contiguous_memory_nomap(alloc_size,
+						ddl_context->memtype, SZ_4K);
+		if (!physical_addr) {
+			ERR("\n%s(): DDL pmem allocate failed\n",
+			       __func__);
+			goto bailout;
+		}
+		buff_addr->physical_base_addr = (u32 *) physical_addr;
+		flags = MSM_SUBSYSTEM_MAP_KADDR;
+		buff_addr->mapped_buffer =
+		msm_subsystem_map_buffer((unsigned long)physical_addr,
+		alloc_size, flags, NULL, 0);
+		if (IS_ERR(buff_addr->mapped_buffer)) {
+			ERR("\n%s() buffer map failed\n", __func__);
+			goto free_pmem_buffer;
+		}
+		mapped_buffer = buff_addr->mapped_buffer;
+		if (!mapped_buffer->vaddr) {
+			ERR("\n%s() mapped virtual address is NULL\n",
+				__func__);
+			goto unmap_pmem_buffer;
+		}
+		buff_addr->virtual_base_addr = mapped_buffer->vaddr;
+		DBG("ddl_pmem_alloc: mem_type(0x%x), phys(0x%x),"\
+			" virt(0x%x), sz(%u), align(%u)",
+			(u32)buff_addr->mem_type,
+			(u32)buff_addr->physical_base_addr,
+			(u32)buff_addr->virtual_base_addr,
+			alloc_size, SZ_4K);
+	}
+
+	memset(buff_addr->virtual_base_addr, 0 , sz + guard_bytes);
+	buff_addr->buffer_size = sz;
+	buff_addr->align_physical_addr = (u32 *)
+		(((u32)buff_addr->physical_base_addr + guard_bytes) &
+		align_mask);
+	align_offset = (u32) (buff_addr->align_physical_addr) -
+		(u32)buff_addr->physical_base_addr;
+	buff_addr->align_virtual_addr =
+	    (u32 *) ((u32) (buff_addr->virtual_base_addr)
+		     + align_offset);
+	DBG("%s(): phys(0x%x) align_phys(0x%x), virt(0x%x),"\
+		" align_virt(0x%x)", __func__,
+		(u32)buff_addr->physical_base_addr,
+		(u32)buff_addr->align_physical_addr,
+		(u32)buff_addr->virtual_base_addr,
+		(u32)buff_addr->align_virtual_addr);
+	return;
+
+unmap_pmem_buffer:
+	if (buff_addr->mapped_buffer)
+		msm_subsystem_unmap_buffer(buff_addr->mapped_buffer);
+free_pmem_buffer:
+	if (buff_addr->physical_base_addr)
+		free_contiguous_memory_by_paddr((unsigned long)
+			buff_addr->physical_base_addr);
+	memset(buff_addr, 0, sizeof(struct ddl_buf_addr));
+	return;
+
+unmap_ion_buffer:
+	if (ddl_context->video_ion_client) {
+		if (buff_addr->alloc_handle)
+			ion_unmap_kernel(ddl_context->video_ion_client,
+				buff_addr->alloc_handle);
+	}
+free_ion_buffer:
+	if (ddl_context->video_ion_client) {
+		if (buff_addr->alloc_handle)
+			ion_free(ddl_context->video_ion_client,
+				buff_addr->alloc_handle);
+	}
+bailout:
+	memset(buff_addr, 0, sizeof(struct ddl_buf_addr));
+}
+
+void ddl_pmem_free(struct ddl_buf_addr *buff_addr)
+{
+	struct ddl_context *ddl_context;
+	ddl_context = ddl_get_context();
+	if (!buff_addr) {
+		ERR("\n %s() invalid arguments %p", __func__, buff_addr);
+		return;
+	}
+	DBG("ddl_pmem_free: phys(0x%x) align_phys(0x%x), "\
+		"virt(0x%x), align_virt(0x%x), size(%u)",
+		(u32)buff_addr->physical_base_addr,
+		(u32)buff_addr->align_physical_addr,
+		(u32)buff_addr->virtual_base_addr,
+		(u32)buff_addr->align_virtual_addr,
+		buff_addr->buffer_size);
+	if (ddl_context->video_ion_client) {
+		if (buff_addr->alloc_handle) {
+			ion_unmap_kernel(ddl_context->video_ion_client,
+				buff_addr->alloc_handle);
+			ion_free(ddl_context->video_ion_client,
+				buff_addr->alloc_handle);
+		}
+	} else {
+		if (buff_addr->mapped_buffer)
+			msm_subsystem_unmap_buffer(
+				buff_addr->mapped_buffer);
+		if (buff_addr->physical_base_addr)
+			free_contiguous_memory_by_paddr((unsigned long)
+				buff_addr->physical_base_addr);
+	}
+	memset(buff_addr, 0, sizeof(struct ddl_buf_addr));
+}
+#endif
+
+void ddl_set_core_start_time(const char *func_name, u32 index)
+{
+	u32 act_time;
+	struct timeval ddl_tv;
+	struct time_data *time_data = &proc_time[index];
+	do_gettimeofday(&ddl_tv);
+	act_time = (ddl_tv.tv_sec * 1000) + (ddl_tv.tv_usec / 1000);
+	if (!time_data->ddl_t1) {
+		time_data->ddl_t1 = act_time;
+		DBG("\n%s(): Start Time (%u)", func_name, act_time);
+	} else {
+		DBG_TIME("\n%s(): Timer already started! St(%u) Act(%u)",
+			func_name, time_data->ddl_t1, act_time);
+	}
+}
+
+void ddl_calc_core_proc_time(const char *func_name, u32 index)
+{
+	struct time_data *time_data = &proc_time[index];
+	if (time_data->ddl_t1) {
+		int ddl_t2;
+		struct timeval ddl_tv;
+		do_gettimeofday(&ddl_tv);
+		ddl_t2 = (ddl_tv.tv_sec * 1000) + (ddl_tv.tv_usec / 1000);
+		time_data->ddl_ttotal += (ddl_t2 - time_data->ddl_t1);
+		time_data->ddl_count++;
+		DBG_TIME("\n%s(): cnt(%u) Diff(%u) Avg(%u)",
+			func_name, time_data->ddl_count,
+			ddl_t2 - time_data->ddl_t1,
+			time_data->ddl_ttotal/time_data->ddl_count);
+		time_data->ddl_t1 = 0;
+	}
+}
+
+void ddl_reset_core_time_variables(u32 index)
+{
+	proc_time[index].ddl_t1 = 0;
+	proc_time[index].ddl_ttotal = 0;
+	proc_time[index].ddl_count = 0;
+}
+int ddl_get_core_decode_proc_time(u32 *ddl_handle)
+{
+	return 0;
+}
+
+void ddl_reset_avg_dec_time(u32 *ddl_handle)
+{
+	return;
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h
new file mode 100644
index 0000000..633292b
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h
@@ -0,0 +1,60 @@
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VCD_DDL_UTILS_H_
+#define _VCD_DDL_UTILS_H_
+
+#include "vcd_ddl_core.h"
+#include "vcd_ddl.h"
+
+extern u32 vidc_msg_pmem;
+extern u32 vidc_msg_timing;
+
+enum timing_data {
+	DEC_OP_TIME,
+	DEC_IP_TIME,
+	ENC_OP_TIME,
+	MAX_TIME_DATA
+};
+
+#define DDL_INLINE
+
+#define DDL_ALIGN_SIZE(sz, guard_bytes, align_mask) \
+  (((u32)(sz) + guard_bytes) & align_mask)
+
+#define DDL_MALLOC(x)  kmalloc(x, GFP_KERNEL)
+#define DDL_FREE(x)   { if ((x)) kfree((x)); (x) = NULL; }
+
+#define DBG_PMEM(x...) \
+do { \
+	if (vidc_msg_pmem) \
+		printk(KERN_DEBUG x); \
+} while (0)
+
+void ddl_set_core_start_time(const char *func_name, u32 index);
+
+void ddl_calc_core_proc_time(const char *func_name, u32 index);
+
+void ddl_reset_core_time_variables(u32 index);
+
+int ddl_get_core_decode_proc_time(u32 *ddl_handle);
+
+void ddl_reset_avg_dec_time(u32 *ddl_handle);
+
+#define DDL_ASSERT(x)
+#define DDL_MEMSET(src, value, len) memset((src), (value), (len))
+#define DDL_MEMCPY(dest, src, len)  memcpy((dest), (src), (len))
+
+#define DDL_ADDR_IS_ALIGNED(addr, align_bytes) \
+(!((u32)(addr) & ((align_bytes) - 1)))
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/ddl/vidc.c b/drivers/video/msm/vidc/720p/ddl/vidc.c
new file mode 100644
index 0000000..da969ef
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vidc.c
@@ -0,0 +1,804 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/unistd.h>
+#include <media/msm/vidc_type.h>
+#include "vidc.h"
+
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
+
+#define VIDC_720P_VERSION_STRING "VIDC_V1.0"
+u8 *vidc_base_addr;
+
+#ifdef VIDC_REGISTER_LOG_INTO_BUFFER
+char vidclog[VIDC_REGLOG_BUFSIZE];
+unsigned int vidclog_index;
+#endif
+
+void vidc_720p_set_device_virtual_base(u8 *core_virtual_base_addr)
+{
+	vidc_base_addr = core_virtual_base_addr;
+}
+
+void vidc_720p_init(char **ppsz_version, u32 i_firmware_size,
+		     u32 *pi_firmware_address,
+		     enum vidc_720p_endian dma_endian,
+		     u32 interrupt_off,
+		     enum vidc_720p_interrupt_level_selection
+		     interrupt_sel, u32 interrupt_mask)
+{
+	if (ppsz_version)
+		*ppsz_version = VIDC_720P_VERSION_STRING;
+
+	if (interrupt_sel == VIDC_720P_INTERRUPT_LEVEL_SEL)
+		VIDC_IO_OUT(REG_491082, 0);
+	else
+		VIDC_IO_OUT(REG_491082, 1);
+
+	if (interrupt_off)
+		VIDC_IO_OUT(REG_609676, 1);
+	else
+		VIDC_IO_OUT(REG_609676, 0);
+
+	VIDC_IO_OUT(REG_614776, 1);
+
+	VIDC_IO_OUT(REG_418173, 0);
+
+	VIDC_IO_OUT(REG_418173, interrupt_mask);
+
+	VIDC_IO_OUT(REG_736316, dma_endian);
+
+	VIDC_IO_OUT(REG_215724, 0);
+
+	VIDC_IO_OUT(REG_361582, 1);
+
+	VIDC_IO_OUT(REG_591577, i_firmware_size);
+
+	VIDC_IO_OUT(REG_203921, pi_firmware_address);
+
+	VIDC_IO_OUT(REG_531515_ADDR, 0);
+
+	VIDC_IO_OUT(REG_614413, 1);
+}
+
+u32 vidc_720p_do_sw_reset(void)
+{
+
+	u32 fw_start = 0;
+	VIDC_BUSY_WAIT(5);
+	VIDC_IO_OUT(REG_224135, 0);
+	VIDC_BUSY_WAIT(5);
+	VIDC_IO_OUT(REG_193553, 0);
+	VIDC_BUSY_WAIT(5);
+	VIDC_IO_OUT(REG_141269, 1);
+	VIDC_BUSY_WAIT(15);
+	VIDC_IO_OUT(REG_141269, 0);
+	VIDC_BUSY_WAIT(5);
+	VIDC_IO_IN(REG_193553, &fw_start);
+
+	if (!fw_start) {
+		DBG("\n VIDC-SW-RESET-FAILS!");
+		return false;
+	}
+	return true;
+}
+
+u32 vidc_720p_reset_is_success()
+{
+	u32 stagecounter = 0;
+	VIDC_IO_IN(REG_352831, &stagecounter);
+	stagecounter &= 0xff;
+	if (stagecounter != 0xe5) {
+		DBG("\n VIDC-CPU_RESET-FAILS!");
+		VIDC_IO_OUT(REG_224135, 0);
+		msleep(10);
+		return false;
+	}
+	return true;
+}
+
+void vidc_720p_start_cpu(enum vidc_720p_endian dma_endian,
+						  u32 *icontext_bufferstart,
+						  u32 *debug_core_dump_addr,
+						  u32  debug_buffer_size)
+{
+	u32 dbg_info_input0_reg = 0x1;
+	VIDC_IO_OUT(REG_361582, 0);
+	VIDC_IO_OUT(REG_958768, icontext_bufferstart);
+	VIDC_IO_OUT(REG_736316, dma_endian);
+	if (debug_buffer_size) {
+		dbg_info_input0_reg = (debug_buffer_size << 0x10)
+			| (0x2 << 1) | 0x1;
+		VIDC_IO_OUT(REG_166247, debug_core_dump_addr);
+	}
+	VIDC_IO_OUT(REG_699747, dbg_info_input0_reg);
+	VIDC_IO_OUT(REG_224135, 1);
+}
+
+u32 vidc_720p_cpu_start()
+{
+	u32 fw_status = 0x0;
+	VIDC_IO_IN(REG_381535, &fw_status);
+	if (fw_status != 0x02)
+		return false;
+	return true;
+}
+
+
+void vidc_720p_stop_fw(void)
+{
+   VIDC_IO_OUT(REG_193553, 0);
+   VIDC_IO_OUT(REG_224135, 0);
+}
+
+void vidc_720p_get_interrupt_status(u32 *interrupt_status,
+	u32 *cmd_err_status, u32 *disp_pic_err_status, u32 *op_failed)
+{
+	u32 err_status;
+	VIDC_IO_IN(REG_512143, interrupt_status);
+	VIDC_IO_IN(REG_300310, &err_status);
+	*cmd_err_status = err_status & 0xffff;
+	*disp_pic_err_status = (err_status & 0xffff0000) >> 16;
+	VIDC_IO_INF(REG_724381, OPERATION_FAILED, \
+				 op_failed);
+}
+
+void vidc_720p_interrupt_done_clear(void)
+{
+	VIDC_IO_OUT(REG_614776, 1);
+	VIDC_IO_OUT(REG_97293, 4);
+}
+
+void vidc_720p_submit_command(u32 ch_id, u32 cmd_id)
+{
+	u32 fw_status;
+	VIDC_IO_OUT(REG_97293, ch_id);
+	VIDC_IO_OUT(REG_62325, cmd_id);
+	VIDC_DEBUG_REGISTER_LOG;
+	VIDC_IO_IN(REG_381535, &fw_status);
+	VIDC_IO_OUT(REG_926519, fw_status);
+}
+
+u32 vidc_720p_engine_reset(u32 ch_id,
+	enum vidc_720p_endian dma_endian,
+	enum vidc_720p_interrupt_level_selection interrupt_sel,
+	u32 interrupt_mask
+)
+{
+	u32 op_done = 0;
+	u32 counter = 0;
+
+	VIDC_LOGERR_STRING("ENG-RESET!!");
+	/* issue the engine reset command */
+	vidc_720p_submit_command(ch_id, VIDC_720P_CMD_MFC_ENGINE_RESET);
+
+	do {
+		VIDC_BUSY_WAIT(20);
+		VIDC_IO_IN(REG_982553, &op_done);
+		counter++;
+	} while (!op_done && counter < 10);
+
+	if (!op_done) {
+		/* Reset fails */
+		return  false ;
+	}
+
+	/* write invalid channel id */
+	VIDC_IO_OUT(REG_97293, 4);
+
+	/* Set INT_PULSE_SEL */
+	if (interrupt_sel == VIDC_720P_INTERRUPT_LEVEL_SEL)
+		VIDC_IO_OUT(REG_491082, 0);
+	else
+		VIDC_IO_OUT(REG_491082, 1);
+
+	if (!interrupt_mask) {
+		/* Disable interrupt */
+		VIDC_IO_OUT(REG_609676, 1);
+	} else {
+	  /* Enable interrupt */
+		VIDC_IO_OUT(REG_609676, 0);
+	}
+
+	/* Clear any pending interrupt */
+	VIDC_IO_OUT(REG_614776, 1);
+
+	/* Set INT_ENABLE_REG */
+	VIDC_IO_OUT(REG_418173, interrupt_mask);
+
+	/*Sets the DMA endianness */
+	VIDC_IO_OUT(REG_736316, dma_endian);
+
+	/*Restore ARM endianness */
+	VIDC_IO_OUT(REG_215724, 0);
+
+	/* retun engine reset success */
+	return true ;
+}
+
+void vidc_720p_set_channel(u32 i_ch_id,
+			    enum vidc_720p_enc_dec_selection
+			    enc_dec_sel, enum vidc_720p_codec codec,
+			    u32 *pi_fw, u32 i_firmware_size)
+{
+	u32 std_sel = 0;
+	VIDC_IO_OUT(REG_661565, 0);
+
+	if (enc_dec_sel)
+		std_sel = VIDC_REG_713080_ENC_ON_BMSK;
+
+	std_sel |= (u32) codec;
+
+	VIDC_IO_OUT(REG_713080, std_sel);
+
+	switch (codec) {
+	default:
+	case VIDC_720P_DIVX:
+	case VIDC_720P_XVID:
+	case VIDC_720P_MPEG4:
+		{
+			if (enc_dec_sel == VIDC_720P_ENCODER)
+				VIDC_IO_OUT(REG_765787, pi_fw);
+			else
+				VIDC_IO_OUT(REG_225040, pi_fw);
+			break;
+		}
+	case VIDC_720P_H264:
+		{
+			if (enc_dec_sel == VIDC_720P_ENCODER)
+				VIDC_IO_OUT(REG_942456, pi_fw);
+			else
+				VIDC_IO_OUT(REG_942170_ADDR_3, pi_fw);
+			break;
+		}
+	case VIDC_720P_H263:
+		{
+			if (enc_dec_sel == VIDC_720P_ENCODER)
+				VIDC_IO_OUT(REG_765787, pi_fw);
+			else
+				VIDC_IO_OUT(REG_942170_ADDR_6, pi_fw);
+			break;
+		}
+	case VIDC_720P_VC1:
+		{
+			VIDC_IO_OUT(REG_880188, pi_fw);
+			break;
+		}
+	case VIDC_720P_MPEG2:
+		{
+			VIDC_IO_OUT(REG_40293, pi_fw);
+			break;
+		}
+	}
+	VIDC_IO_OUT(REG_591577, i_firmware_size);
+
+	vidc_720p_submit_command(i_ch_id, VIDC_720P_CMD_CHSET);
+}
+
+void vidc_720p_encode_set_profile(u32 i_profile, u32 i_level)
+{
+	u32 profile_level = i_profile|(i_level << 0x8);
+	VIDC_IO_OUT(REG_839021, profile_level);
+}
+
+void vidc_720p_set_frame_size(u32 i_size_x, u32 i_size_y)
+{
+	VIDC_IO_OUT(REG_999267, i_size_x);
+
+	VIDC_IO_OUT(REG_345712, i_size_y);
+}
+
+void vidc_720p_encode_set_fps(u32 i_rc_frame_rate)
+{
+	VIDC_IO_OUT(REG_625444, i_rc_frame_rate);
+}
+
+void vidc_720p_encode_set_short_header(u32 i_short_header)
+{
+	VIDC_IO_OUT(REG_314290, i_short_header);
+}
+
+void vidc_720p_encode_set_vop_time(u32 vop_time_resolution,
+				    u32 vop_time_increment)
+{
+	u32 enable_vop, vop_timing_reg;
+	if (!vop_time_resolution)
+		VIDC_IO_OUT(REG_64895, 0x0);
+	else {
+		enable_vop = 0x1;
+		vop_timing_reg = (enable_vop << 0x1f) |
+		(vop_time_resolution << 0x10) | vop_time_increment;
+		VIDC_IO_OUT(REG_64895, vop_timing_reg);
+	}
+}
+
+void vidc_720p_encode_set_hec_period(u32 hec_period)
+{
+	VIDC_IO_OUT(REG_407718, hec_period);
+}
+
+void vidc_720p_encode_set_qp_params(u32 i_max_qp, u32 i_min_qp)
+{
+	u32 qp = i_min_qp | (i_max_qp << 0x8);
+	VIDC_IO_OUT(REG_734318, qp);
+}
+
+void vidc_720p_encode_set_rc_config(u32 enable_frame_level_rc,
+				     u32 enable_mb_level_rc_flag,
+				     u32 i_frame_qp, u32 pframe_qp)
+{
+   u32 rc_config = i_frame_qp;
+
+	if (enable_frame_level_rc)
+		rc_config |= (0x1 << 0x9);
+
+	if (enable_mb_level_rc_flag)
+		rc_config |= (0x1 << 0x8);
+
+	VIDC_IO_OUT(REG_58211, rc_config);
+	VIDC_IO_OUT(REG_548359, pframe_qp);
+}
+
+void vidc_720p_encode_set_bit_rate(u32 i_target_bitrate)
+{
+	VIDC_IO_OUT(REG_174150, i_target_bitrate);
+}
+
+void vidc_720p_encoder_set_param_change(u32 enc_param_change)
+{
+	VIDC_IO_OUT(REG_804959, enc_param_change);
+}
+
+void vidc_720p_encode_set_control_param(u32 param_val)
+{
+	VIDC_IO_OUT(REG_128234, param_val);
+}
+
+void vidc_720p_encode_set_frame_level_rc_params(u32 i_reaction_coeff)
+{
+	VIDC_IO_OUT(REG_677784, i_reaction_coeff);
+}
+
+void vidc_720p_encode_set_mb_level_rc_params(u32 dark_region_as_flag,
+					      u32 smooth_region_as_flag,
+					      u32 static_region_as_flag,
+					      u32 activity_region_flag)
+{
+	u32 mb_level_rc = 0x0;
+	if (activity_region_flag)
+		mb_level_rc |= 0x1;
+	if (static_region_as_flag)
+		mb_level_rc |= (0x1 << 0x1);
+	if (smooth_region_as_flag)
+		mb_level_rc |= (0x1 << 0x2);
+	if (dark_region_as_flag)
+		mb_level_rc |= (0x1 << 0x3);
+	/* Write MB level rate control */
+	VIDC_IO_OUT(REG_995041, mb_level_rc);
+}
+
+void vidc_720p_encode_set_entropy_control(enum vidc_720p_entropy_sel
+					   entropy_sel,
+					   enum vidc_720p_cabac_model
+					   cabac_model_number)
+{
+	u32 num;
+	u32 entropy_params = (u32)entropy_sel;
+	/* Set Model Number */
+	if (entropy_sel == VIDC_720P_ENTROPY_SEL_CABAC) {
+		num = (u32)cabac_model_number;
+		entropy_params |= (num << 0x2);
+	}
+	/* Set Entropy parameters */
+	VIDC_IO_OUT(REG_504878, entropy_params);
+}
+
+void vidc_720p_encode_set_db_filter_control(enum vidc_720p_DBConfig
+					     db_config,
+					     u32 i_slice_alpha_offset,
+					     u32 i_slice_beta_offset)
+{
+	u32 deblock_params;
+	deblock_params = (u32)db_config;
+	deblock_params |=
+		((i_slice_beta_offset << 0x2) | (i_slice_alpha_offset << 0x7));
+
+	/* Write deblocking control settings */
+	VIDC_IO_OUT(REG_458130, deblock_params);
+}
+
+void vidc_720p_encode_set_intra_refresh_mb_number(u32 i_cir_mb_number)
+{
+	VIDC_IO_OUT(REG_857491, i_cir_mb_number);
+}
+
+void vidc_720p_encode_set_multi_slice_info(enum
+					    vidc_720p_MSlice_selection
+					    m_slice_sel,
+					    u32 multi_slice_size)
+{
+	switch (m_slice_sel) {
+	case VIDC_720P_MSLICE_BY_MB_COUNT:
+		{
+			VIDC_IO_OUT(REG_588301, 0x1);
+			VIDC_IO_OUT(REG_1517, m_slice_sel);
+			VIDC_IO_OUT(REG_105335, multi_slice_size);
+			break;
+		}
+	case VIDC_720P_MSLICE_BY_BYTE_COUNT:
+		{
+			VIDC_IO_OUT(REG_588301, 0x1);
+			VIDC_IO_OUT(REG_1517, m_slice_sel);
+			VIDC_IO_OUT(REG_561679, multi_slice_size);
+			break;
+		}
+	case VIDC_720P_MSLICE_BY_GOB:
+		{
+			VIDC_IO_OUT(REG_588301, 0x1);
+			break;
+		}
+	default:
+	case VIDC_720P_MSLICE_OFF:
+		{
+			VIDC_IO_OUT(REG_588301, 0x0);
+			break;
+		}
+	}
+}
+
+void vidc_720p_encode_set_dpb_buffer(u32 *pi_enc_dpb_addr, u32 alloc_len)
+{
+	VIDC_IO_OUT(REG_341928_ADDR, pi_enc_dpb_addr);
+	VIDC_IO_OUT(REG_319934, alloc_len);
+}
+
+void vidc_720p_encode_set_i_period(u32 i_i_period)
+{
+	VIDC_IO_OUT(REG_950374, i_i_period);
+}
+
+void vidc_720p_encode_init_codec(u32 i_ch_id,
+				  enum vidc_720p_memory_access_method
+				  memory_access_model)
+{
+
+	VIDC_IO_OUT(REG_841539, memory_access_model);
+	vidc_720p_submit_command(i_ch_id, VIDC_720P_CMD_INITCODEC);
+}
+
+void vidc_720p_encode_unalign_bitstream(u32 upper_unalign_word,
+					 u32 lower_unalign_word)
+{
+	VIDC_IO_OUT(REG_792026, upper_unalign_word);
+	VIDC_IO_OUT(REG_844152, lower_unalign_word);
+}
+
+void vidc_720p_encode_set_seq_header_buffer(u32 ext_buffer_start,
+					     u32 ext_buffer_end,
+					     u32 start_byte_num)
+{
+	VIDC_IO_OUT(REG_275113_ADDR, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_87912, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_988007_ADDR, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_66693, start_byte_num);
+}
+
+void vidc_720p_encode_frame(u32 ch_id,
+			     u32 ext_buffer_start,
+			     u32 ext_buffer_end,
+			     u32 start_byte_number, u32 y_addr,
+			     u32 c_addr)
+{
+	VIDC_IO_OUT(REG_275113_ADDR, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_988007_ADDR, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_87912, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_66693, start_byte_number);
+
+	VIDC_IO_OUT(REG_99105, y_addr);
+
+	VIDC_IO_OUT(REG_777113_ADDR, c_addr);
+
+	vidc_720p_submit_command(ch_id, VIDC_720P_CMD_FRAMERUN);
+}
+
+void vidc_720p_encode_get_header(u32 *pi_enc_header_size)
+{
+	VIDC_IO_IN(REG_114286, pi_enc_header_size);
+}
+
+void vidc_720p_enc_frame_info(struct vidc_720p_enc_frame_info
+			       *enc_frame_info)
+{
+	VIDC_IO_IN(REG_782249, &enc_frame_info->enc_size);
+
+	VIDC_IO_IN(REG_441270, &enc_frame_info->frame);
+
+	enc_frame_info->frame &= 0x03;
+
+	VIDC_IO_IN(REG_613254,
+		    &enc_frame_info->metadata_exists);
+}
+
+void vidc_720p_decode_bitstream_header(u32 ch_id,
+					u32 dec_unit_size,
+					u32 start_byte_num,
+					u32 ext_buffer_start,
+					u32 ext_buffer_end,
+					enum
+					vidc_720p_memory_access_method
+					memory_access_model,
+					u32 decode_order)
+{
+	VIDC_IO_OUT(REG_965480, decode_order);
+
+	VIDC_IO_OUT(REG_639999, 0x8080);
+
+	VIDC_IO_OUT(REG_275113_ADDR, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_988007_ADDR, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_87912, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_761892, dec_unit_size);
+
+	VIDC_IO_OUT(REG_66693, start_byte_num);
+
+	VIDC_IO_OUT(REG_841539, memory_access_model);
+
+	vidc_720p_submit_command(ch_id, VIDC_720P_CMD_INITCODEC);
+}
+
+void vidc_720p_decode_get_seq_hdr_info(struct vidc_720p_seq_hdr_info
+					*seq_hdr_info)
+{
+	u32 display_status;
+	VIDC_IO_IN(REG_999267, &seq_hdr_info->img_size_x);
+
+	VIDC_IO_IN(REG_345712, &seq_hdr_info->img_size_y);
+
+	VIDC_IO_IN(REG_257463, &seq_hdr_info->min_num_dpb);
+
+	VIDC_IO_IN(REG_854281, &seq_hdr_info->min_dpb_size);
+
+	VIDC_IO_IN(REG_580603, &seq_hdr_info->dec_frm_size);
+
+	VIDC_IO_INF(REG_606447, DISP_PIC_PROFILE,
+				 &seq_hdr_info->profile);
+
+	VIDC_IO_INF(REG_606447, DIS_PIC_LEVEL,
+				 &seq_hdr_info->level);
+
+	VIDC_IO_INF(REG_612715, DISPLAY_STATUS,
+				&display_status);
+	seq_hdr_info->progressive =
+			((display_status & 0x4) >> 2);
+	/* bit 3 is for crop existence */
+	seq_hdr_info->crop_exists = ((display_status & 0x8) >> 3);
+
+	if (seq_hdr_info->crop_exists) {
+		/* read the cropping information */
+		VIDC_IO_INF(REG_881638, CROP_RIGHT_OFFSET, \
+			&seq_hdr_info->crop_right_offset);
+		VIDC_IO_INF(REG_881638, CROP_LEFT_OFFSET, \
+			&seq_hdr_info->crop_left_offset);
+		VIDC_IO_INF(REG_161486, CROP_BOTTOM_OFFSET, \
+			&seq_hdr_info->crop_bottom_offset);
+		VIDC_IO_INF(REG_161486, CROP_TOP_OFFSET, \
+			&seq_hdr_info->crop_top_offset);
+	}
+	/* Read the MPEG4 data partitioning indication */
+	VIDC_IO_INF(REG_441270, DATA_PARTITIONED, \
+				&seq_hdr_info->data_partitioned);
+
+}
+
+void vidc_720p_decode_set_dpb_release_buffer_mask(u32
+						   i_dpb_release_buffer_mask)
+{
+	VIDC_IO_OUT(REG_603032, i_dpb_release_buffer_mask);
+}
+
+void vidc_720p_decode_set_dpb_buffers(u32 i_buf_index, u32 *pi_dpb_buffer)
+{
+	VIDC_IO_OUTI(REG_615716, i_buf_index, pi_dpb_buffer);
+}
+
+void vidc_720p_decode_set_comv_buffer(u32 *pi_dpb_comv_buffer,
+				       u32 alloc_len)
+{
+	VIDC_IO_OUT(REG_456376_ADDR, pi_dpb_comv_buffer);
+
+	VIDC_IO_OUT(REG_490443, alloc_len);
+}
+
+void vidc_720p_decode_set_dpb_details(u32 num_dpb, u32 alloc_len,
+				       u32 *ref_buffer)
+{
+	VIDC_IO_OUT(REG_518133, ref_buffer);
+
+	VIDC_IO_OUT(REG_267567, 0);
+
+	VIDC_IO_OUT(REG_883500, num_dpb);
+
+	VIDC_IO_OUT(REG_319934, alloc_len);
+}
+
+void vidc_720p_decode_set_mpeg4Post_filter(u32 enable_post_filter)
+{
+	if (enable_post_filter)
+		VIDC_IO_OUT(REG_443811, 0x1);
+	else
+		VIDC_IO_OUT(REG_443811, 0x0);
+}
+
+void vidc_720p_decode_set_error_control(u32 enable_error_control)
+{
+	if (enable_error_control)
+		VIDC_IO_OUT(REG_846346, 0);
+	else
+		VIDC_IO_OUT(REG_846346, 1);
+}
+
+void vidc_720p_set_deblock_line_buffer(u32 *pi_deblock_line_buffer_start,
+					u32 alloc_len)
+{
+	VIDC_IO_OUT(REG_979942, pi_deblock_line_buffer_start);
+
+	VIDC_IO_OUT(REG_101184, alloc_len);
+}
+
+void vidc_720p_decode_set_mpeg4_data_partitionbuffer(u32 *vsp_buf_start)
+{
+    VIDC_IO_OUT(REG_958768, vsp_buf_start);
+}
+
+void vidc_720p_decode_setH264VSPBuffer(u32 *pi_vsp_temp_buffer_start)
+{
+	VIDC_IO_OUT(REG_958768, pi_vsp_temp_buffer_start);
+}
+
+void vidc_720p_decode_frame(u32 ch_id, u32 ext_buffer_start,
+			     u32 ext_buffer_end, u32 dec_unit_size,
+			     u32 start_byte_num, u32 input_frame_tag)
+{
+	VIDC_IO_OUT(REG_275113_ADDR, ext_buffer_start);
+
+	VIDC_IO_OUT(REG_988007_ADDR, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_87912, ext_buffer_end);
+
+	VIDC_IO_OUT(REG_66693, start_byte_num);
+
+	VIDC_IO_OUT(REG_94750, input_frame_tag);
+
+	VIDC_IO_OUT(REG_761892, dec_unit_size);
+
+	vidc_720p_submit_command(ch_id, VIDC_720P_CMD_FRAMERUN);
+}
+
+void vidc_720p_issue_eos(u32 i_ch_id)
+{
+    VIDC_IO_OUT(REG_896825, 0x1);
+
+    VIDC_IO_OUT(REG_761892, 0);
+
+    vidc_720p_submit_command(i_ch_id, VIDC_720P_CMD_FRAMERUN);
+}
+
+void vidc_720p_eos_info(u32 *disp_status, u32 *resl_change)
+{
+   VIDC_IO_INF(REG_612715, DISPLAY_STATUS, disp_status);
+   (*disp_status) = (*disp_status) & 0x3;
+   VIDC_IO_INF(REG_724381, RESOLUTION_CHANGE, resl_change);
+}
+
+void vidc_720p_decode_display_info(struct vidc_720p_dec_disp_info
+				    *disp_info)
+{
+	u32 display_status = 0;
+	VIDC_IO_INF(REG_612715, DISPLAY_STATUS, &display_status);
+
+	disp_info->disp_status =
+	    (enum vidc_720p_display_status)((display_status & 0x3));
+
+	disp_info->disp_is_interlace = ((display_status & 0x4) >> 2);
+	disp_info->crop_exists = ((display_status & 0x8) >> 3);
+
+	disp_info->resl_change = ((display_status & 0x30) >> 4);
+
+	VIDC_IO_INF(REG_724381, RESOLUTION_CHANGE,
+		     &disp_info->reconfig_flush_done);
+
+	VIDC_IO_IN(REG_999267, &disp_info->img_size_x);
+
+	VIDC_IO_IN(REG_345712, &disp_info->img_size_y);
+	VIDC_IO_IN(REG_151345, &disp_info->y_addr);
+	VIDC_IO_IN(REG_293983, &disp_info->c_addr);
+	VIDC_IO_IN(REG_370409, &disp_info->tag_top);
+	VIDC_IO_IN(REG_438677, &disp_info->tag_bottom);
+	VIDC_IO_IN(REG_679165, &disp_info->pic_time_top);
+	VIDC_IO_IN(REG_374150, &disp_info->pic_time_bottom);
+
+	if (disp_info->crop_exists) {
+		VIDC_IO_INF(REG_881638, CROP_RIGHT_OFFSET,
+			&disp_info->crop_right_offset);
+		VIDC_IO_INF(REG_881638, CROP_LEFT_OFFSET,
+			&disp_info->crop_left_offset);
+		VIDC_IO_INF(REG_161486, CROP_BOTTOM_OFFSET,
+			&disp_info->crop_bottom_offset);
+		VIDC_IO_INF(REG_161486, CROP_TOP_OFFSET,
+			&disp_info->crop_top_offset);
+	}
+	VIDC_IO_IN(REG_613254, &disp_info->metadata_exists);
+
+	VIDC_IO_IN(REG_580603,
+		    &disp_info->input_bytes_consumed);
+
+	VIDC_IO_IN(REG_757835, &disp_info->input_frame_num);
+
+	VIDC_IO_INF(REG_441270, FRAME_TYPE,
+			   &disp_info->input_frame);
+
+	disp_info->input_is_interlace =
+	    ((disp_info->input_frame & 0x4) >> 2);
+
+	if (disp_info->input_frame & 0x10)
+		disp_info->input_frame = VIDC_720P_IDRFRAME;
+	else
+		disp_info->input_frame &= 0x3;
+}
+
+void vidc_720p_decode_skip_frm_details(u32 *free_luma_dpb)
+{
+	u32 disp_frm;
+	VIDC_IO_IN(REG_697961, &disp_frm);
+
+	if (disp_frm == VIDC_720P_NOTCODED)
+		VIDC_IO_IN(REG_347105, free_luma_dpb);
+}
+
+void vidc_720p_metadata_enable(u32 flag, u32 *input_buffer)
+{
+	VIDC_IO_OUT(REG_854681, flag);
+	VIDC_IO_OUT(REG_988552, input_buffer);
+}
+
+void vidc_720p_decode_dynamic_req_reset(void)
+{
+	VIDC_IO_OUT(REG_76706, 0x0);
+	VIDC_IO_OUT(REG_147682, 0x0);
+	VIDC_IO_OUT(REG_896825, 0x0);
+}
+
+void vidc_720p_decode_dynamic_req_set(u32 property)
+{
+	if (property == VIDC_720P_FLUSH_REQ)
+		VIDC_IO_OUT(REG_76706, 0x1);
+	else if (property == VIDC_720P_EXTRADATA)
+		VIDC_IO_OUT(REG_147682, 0x1);
+}
+
+void vidc_720p_decode_setpassthrough_start(u32 pass_startaddr)
+{
+	VIDC_IO_OUT(REG_486169, pass_startaddr);
+}
diff --git a/drivers/video/msm/vidc/720p/ddl/vidc.h b/drivers/video/msm/vidc/720p/ddl/vidc.h
new file mode 100644
index 0000000..a09034f
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/ddl/vidc.h
@@ -0,0 +1,2705 @@
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef VIDC_H
+#define VIDC_H
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+
+#define VIDC_720P_IN(reg)                       VIDC_##reg##_IN
+#define VIDC_720P_INM(reg,  mask)                VIDC_##reg##_INM(mask)
+#define VIDC_720P_OUT(reg,  val)                 VIDC_##reg##_OUT(val)
+#define VIDC_720P_OUTI(reg,  index,  val)         VIDC_##reg##_OUTI(index, val)
+#define VIDC_720P_OUTM(reg,  mask,  val)          VIDC_##reg##_OUTM(mask,  val)
+#define VIDC_720P_SHFT(reg,  field)              VIDC_##reg##_##field##_SHFT
+#define VIDC_720P_FMSK(reg,  field)              VIDC_##reg##_##field##_BMSK
+
+#define VIDC_720P_INF(io, field) (VIDC_720P_INM(io, VIDC_720P_FMSK(io, field)) \
+		>> VIDC_720P_SHFT(io,  field))
+#define VIDC_720P_OUTF(io, field, val) \
+		VIDC_720P_OUTM(io, VIDC_720P_FMSK(io, field), \
+		val << VIDC_720P_SHFT(io,  field))
+
+#define __inpdw(port)	ioread32(port)
+#define __outpdw(port,  val) iowrite32(val, port)
+
+#define in_dword_masked(addr,  mask) (__inpdw(addr) & (mask))
+
+#define out_dword(addr,  val)        __outpdw(addr, val)
+
+#define out_dword_masked(io,  mask,  val,  shadow)  \
+do { \
+	shadow = (shadow & (u32)(~(mask))) | ((u32)((val) & (mask))); \
+	(void) out_dword(io,  shadow); \
+} while (0)
+
+#define out_dword_masked_ns(io,  mask,  val,  current_reg_content) \
+	(void) out_dword(io,  ((current_reg_content & (u32)(~(mask))) | \
+				((u32)((val) & (mask)))))
+
+extern u8 *vidc_base_addr;
+
+#define VIDC720P_BASE  vidc_base_addr
+#define VIDC_720P_WRAPPER_REG_BASE               (VIDC720P_BASE + \
+		0x00000000)
+#define VIDC_720P_WRAPPER_REG_BASE_PHYS          VIDC_720P_BASE_PHYS
+
+#define VIDC_REG_614413_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 00000000)
+#define VIDC_REG_614413_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 00000000)
+#define VIDC_REG_614413_RMSK                            0x1
+#define VIDC_REG_614413_SHFT                              0
+#define VIDC_REG_614413_IN                       \
+	in_dword_masked(VIDC_REG_614413_ADDR,        \
+		VIDC_REG_614413_RMSK)
+#define VIDC_REG_614413_INM(m)                   \
+	in_dword_masked(VIDC_REG_614413_ADDR,  m)
+#define VIDC_REG_614413_OUT(v)                   \
+	out_dword(VIDC_REG_614413_ADDR, v)
+#define VIDC_REG_614413_OUTM(m, v)                \
+do { \
+	out_dword_masked_ns(VIDC_REG_614413_ADDR, m, v, \
+			VIDC_REG_614413_IN); \
+} while (0)
+#define VIDC_REG_614413_DMA_START_BMSK                  0x1
+#define VIDC_REG_614413_DMA_START_SHFT                    0
+
+#define VIDC_REG_591577_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000000c)
+#define VIDC_REG_591577_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000000c)
+#define VIDC_REG_591577_RMSK                 0xffffffff
+#define VIDC_REG_591577_SHFT                          0
+#define VIDC_REG_591577_IN                   \
+	in_dword_masked(VIDC_REG_591577_ADDR,  \
+			VIDC_REG_591577_RMSK)
+#define VIDC_REG_591577_INM(m)               \
+	in_dword_masked(VIDC_REG_591577_ADDR,  m)
+#define VIDC_REG_591577_OUT(v)               \
+	out_dword(VIDC_REG_591577_ADDR, v)
+#define VIDC_REG_591577_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_591577_ADDR, m, v, \
+			VIDC_REG_591577_IN); \
+} while (0)
+#define VIDC_REG_591577_BOOTCODE_SIZE_BMSK   0xffffffff
+#define VIDC_REG_591577_BOOTCODE_SIZE_SHFT            0
+
+#define VIDC_REG_203921_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000014)
+#define VIDC_REG_203921_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000014)
+#define VIDC_REG_203921_RMSK                   0xffffffff
+#define VIDC_REG_203921_SHFT                            0
+#define VIDC_REG_203921_IN                     \
+	in_dword_masked(VIDC_REG_203921_ADDR,  \
+			VIDC_REG_203921_RMSK)
+#define VIDC_REG_203921_INM(m)                 \
+	in_dword_masked(VIDC_REG_203921_ADDR,  m)
+#define VIDC_REG_203921_OUT(v)                 \
+	out_dword(VIDC_REG_203921_ADDR, v)
+#define VIDC_REG_203921_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_203921_ADDR, m, v, \
+			VIDC_REG_203921_IN); \
+} while (0)
+#define VIDC_REG_203921_DMA_EXTADDR_BMSK       0xffffffff
+#define VIDC_REG_203921_DMA_EXTADDR_SHFT                0
+
+#define VIDC_REG_275113_ADDR_ADDR            \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000018)
+#define VIDC_REG_275113_ADDR_PHYS            \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000018)
+#define VIDC_REG_275113_ADDR_RMSK            0xffffffff
+#define VIDC_REG_275113_ADDR_SHFT                     0
+#define VIDC_REG_275113_ADDR_IN              \
+	in_dword_masked(VIDC_REG_275113_ADDR_ADDR,  \
+			VIDC_REG_275113_ADDR_RMSK)
+#define VIDC_REG_275113_ADDR_INM(m)          \
+	in_dword_masked(VIDC_REG_275113_ADDR_ADDR,  m)
+#define VIDC_REG_275113_ADDR_OUT(v)          \
+	out_dword(VIDC_REG_275113_ADDR_ADDR, v)
+#define VIDC_REG_275113_ADDR_OUTM(m, v)       \
+do { \
+	out_dword_masked_ns(VIDC_REG_275113_ADDR_ADDR, m, v, \
+			VIDC_REG_275113_ADDR_IN); \
+} while (0)
+#define VIDC_REG_742076_ADDR_BMSK 0xffffffff
+#define VIDC_REG_742076_ADDR_SHFT          0
+
+#define VIDC_REG_988007_ADDR_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000001c)
+#define VIDC_REG_988007_ADDR_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000001c)
+#define VIDC_REG_988007_ADDR_RMSK              0xffffffff
+#define VIDC_REG_988007_ADDR_SHFT                       0
+#define VIDC_REG_988007_ADDR_IN                \
+	in_dword_masked(VIDC_REG_988007_ADDR_ADDR,  \
+			VIDC_REG_988007_ADDR_RMSK)
+#define VIDC_REG_988007_ADDR_INM(m)            \
+	in_dword_masked(VIDC_REG_988007_ADDR_ADDR,  m)
+#define VIDC_REG_988007_ADDR_OUT(v)            \
+	out_dword(VIDC_REG_988007_ADDR_ADDR, v)
+#define VIDC_REG_988007_ADDR_OUTM(m, v)         \
+do { \
+	out_dword_masked_ns(VIDC_REG_988007_ADDR_ADDR, m, v, \
+			VIDC_REG_988007_ADDR_IN); \
+} while (0)
+#define VIDC_REG_988007_ADDR_EXT_BUF_END_ADDR_BMSK 0xffffffff
+#define VIDC_REG_988007_ADDR_EXT_BUF_END_ADDR_SHFT          0
+
+#define VIDC_REG_531515_ADDR_ADDR                  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000020)
+#define VIDC_REG_531515_ADDR_PHYS                  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000020)
+#define VIDC_REG_531515_ADDR_RMSK                  0xffffffff
+#define VIDC_REG_531515_ADDR_SHFT                           0
+#define VIDC_REG_531515_ADDR_IN                    \
+	in_dword_masked(VIDC_REG_531515_ADDR_ADDR,  \
+			VIDC_REG_531515_ADDR_RMSK)
+#define VIDC_REG_531515_ADDR_INM(m)                \
+	in_dword_masked(VIDC_REG_531515_ADDR_ADDR,  m)
+#define VIDC_REG_531515_ADDR_OUT(v)                \
+	out_dword(VIDC_REG_531515_ADDR_ADDR, v)
+#define VIDC_REG_531515_ADDR_OUTM(m, v)             \
+do { \
+	out_dword_masked_ns(VIDC_REG_531515_ADDR_ADDR, m, v, \
+			VIDC_REG_531515_ADDR_IN); \
+} while (0)
+#define VIDC_REG_531515_ADDR_DMA_INT_ADDR_BMSK     0xffffffff
+#define VIDC_REG_531515_ADDR_DMA_INT_ADDR_SHFT              0
+
+#define VIDC_REG_87912_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000024)
+#define VIDC_REG_87912_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000024)
+#define VIDC_REG_87912_RMSK                 0xffffffff
+#define VIDC_REG_87912_SHFT                          0
+#define VIDC_REG_87912_IN                   \
+	in_dword_masked(VIDC_REG_87912_ADDR,  \
+			VIDC_REG_87912_RMSK)
+#define VIDC_REG_87912_INM(m)               \
+	in_dword_masked(VIDC_REG_87912_ADDR,  m)
+#define VIDC_REG_87912_OUT(v)               \
+	out_dword(VIDC_REG_87912_ADDR, v)
+#define VIDC_REG_87912_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_87912_ADDR, m, v, \
+			VIDC_REG_87912_IN); \
+} while (0)
+#define VIDC_REG_87912_HOST_PTR_ADDR_BMSK   0xffffffff
+#define VIDC_REG_87912_HOST_PTR_ADDR_SHFT            0
+
+#define VIDC_REG_896825_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000028)
+#define VIDC_REG_896825_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000028)
+#define VIDC_REG_896825_RMSK                             0x1
+#define VIDC_REG_896825_SHFT                               0
+#define VIDC_REG_896825_IN                        \
+	in_dword_masked(VIDC_REG_896825_ADDR,         \
+	VIDC_REG_896825_RMSK)
+#define VIDC_REG_896825_INM(m)                    \
+	in_dword_masked(VIDC_REG_896825_ADDR,  m)
+#define VIDC_REG_896825_OUT(v)                    \
+	out_dword(VIDC_REG_896825_ADDR, v)
+#define VIDC_REG_896825_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_896825_ADDR, m, v, \
+			VIDC_REG_896825_IN); \
+} while (0)
+#define VIDC_REG_896825_LAST_DEC_BMSK                    0x1
+#define VIDC_REG_896825_LAST_DEC_SHFT                      0
+
+#define VIDC_REG_174526_ADDR                        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000002c)
+#define VIDC_REG_174526_PHYS                        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000002c)
+#define VIDC_REG_174526_RMSK                               0x1
+#define VIDC_REG_174526_SHFT                                 0
+#define VIDC_REG_174526_IN                          \
+	in_dword_masked(VIDC_REG_174526_ADDR,  VIDC_REG_174526_RMSK)
+#define VIDC_REG_174526_INM(m)                      \
+	in_dword_masked(VIDC_REG_174526_ADDR,  m)
+#define VIDC_REG_174526_DONE_M_BMSK                        0x1
+#define VIDC_REG_174526_DONE_M_SHFT                          0
+
+#define VIDC_REG_736316_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000044)
+#define VIDC_REG_736316_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000044)
+#define VIDC_REG_736316_RMSK                          0x1
+#define VIDC_REG_736316_SHFT                            0
+#define VIDC_REG_736316_IN                     \
+	in_dword_masked(VIDC_REG_736316_ADDR,  \
+			VIDC_REG_736316_RMSK)
+#define VIDC_REG_736316_INM(m)                 \
+	in_dword_masked(VIDC_REG_736316_ADDR,  m)
+#define VIDC_REG_736316_OUT(v)                 \
+	out_dword(VIDC_REG_736316_ADDR, v)
+#define VIDC_REG_736316_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_736316_ADDR, m, v, \
+			VIDC_REG_736316_IN); \
+} while (0)
+#define VIDC_REG_736316_BITS_ENDIAN_BMSK              0x1
+#define VIDC_REG_736316_BITS_ENDIAN_SHFT                0
+
+#define VIDC_REG_761892_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000054)
+#define VIDC_REG_761892_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000054)
+#define VIDC_REG_761892_RMSK                 0xffffffff
+#define VIDC_REG_761892_SHFT                          0
+#define VIDC_REG_761892_IN                   \
+	in_dword_masked(VIDC_REG_761892_ADDR,  \
+			VIDC_REG_761892_RMSK)
+#define VIDC_REG_761892_INM(m)               \
+	in_dword_masked(VIDC_REG_761892_ADDR,  m)
+#define VIDC_REG_761892_OUT(v)               \
+	out_dword(VIDC_REG_761892_ADDR, v)
+#define VIDC_REG_761892_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_761892_ADDR, m, v, \
+			VIDC_REG_761892_IN); \
+} while (0)
+#define VIDC_REG_761892_DEC_UNIT_SIZE_BMSK   0xffffffff
+#define VIDC_REG_761892_DEC_UNIT_SIZE_SHFT            0
+
+#define VIDC_REG_782249_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000058)
+#define VIDC_REG_782249_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000058)
+#define VIDC_REG_782249_RMSK                 0xffffffff
+#define VIDC_REG_782249_SHFT                          0
+#define VIDC_REG_782249_IN                   \
+	in_dword_masked(VIDC_REG_782249_ADDR,  \
+			VIDC_REG_782249_RMSK)
+#define VIDC_REG_782249_INM(m)               \
+	in_dword_masked(VIDC_REG_782249_ADDR,  m)
+#define VIDC_REG_782249_ENC_UNIT_SIZE_BMSK   0xffffffff
+#define VIDC_REG_782249_ENC_UNIT_SIZE_SHFT            0
+
+#define VIDC_REG_66693_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000005c)
+#define VIDC_REG_66693_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000005c)
+#define VIDC_REG_66693_RMSK                       0xf
+#define VIDC_REG_66693_SHFT                         0
+#define VIDC_REG_66693_IN                  \
+	in_dword_masked(VIDC_REG_66693_ADDR,  \
+			VIDC_REG_66693_RMSK)
+#define VIDC_REG_66693_INM(m)              \
+	in_dword_masked(VIDC_REG_66693_ADDR,  m)
+#define VIDC_REG_66693_OUT(v)              \
+	out_dword(VIDC_REG_66693_ADDR, v)
+#define VIDC_REG_66693_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_66693_ADDR, m, v, \
+			VIDC_REG_66693_IN); \
+} while (0)
+#define VIDC_REG_66693_START_BYTE_NUM_BMSK        0xf
+#define VIDC_REG_66693_START_BYTE_NUM_SHFT          0
+
+#define VIDC_REG_114286_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000060)
+#define VIDC_REG_114286_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000060)
+#define VIDC_REG_114286_RMSK               0xffffffff
+#define VIDC_REG_114286_SHFT                        0
+#define VIDC_REG_114286_IN                 \
+	in_dword_masked(VIDC_REG_114286_ADDR,  \
+			VIDC_REG_114286_RMSK)
+#define VIDC_REG_114286_INM(m)             \
+	in_dword_masked(VIDC_REG_114286_ADDR,  m)
+#define VIDC_REG_114286_ENC_HEADER_SIZE_BMSK 0xffffffff
+#define VIDC_REG_114286_ENC_HEADER_SIZE_SHFT          0
+
+#define VIDC_REG_713080_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000100)
+#define VIDC_REG_713080_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000100)
+#define VIDC_REG_713080_RMSK                         0x1f
+#define VIDC_REG_713080_SHFT                            0
+#define VIDC_REG_713080_IN                     \
+	in_dword_masked(VIDC_REG_713080_ADDR,  \
+			VIDC_REG_713080_RMSK)
+#define VIDC_REG_713080_INM(m)                 \
+	in_dword_masked(VIDC_REG_713080_ADDR,  m)
+#define VIDC_REG_713080_OUT(v)                 \
+	out_dword(VIDC_REG_713080_ADDR, v)
+#define VIDC_REG_713080_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_713080_ADDR, m, v, \
+			VIDC_REG_713080_IN); \
+} while (0)
+#define VIDC_REG_713080_ENC_ON_BMSK                  0x10
+#define VIDC_REG_713080_ENC_ON_SHFT                   0x4
+#define VIDC_REG_713080_STANDARD_SEL_BMSK             0xf
+#define VIDC_REG_713080_STANDARD_SEL_SHFT               0
+
+#define VIDC_REG_97293_ADDR                         \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000104)
+#define VIDC_REG_97293_PHYS                         \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000104)
+#define VIDC_REG_97293_RMSK                               0x1f
+#define VIDC_REG_97293_SHFT                                  0
+#define VIDC_REG_97293_IN                           \
+	in_dword_masked(VIDC_REG_97293_ADDR,  VIDC_REG_97293_RMSK)
+#define VIDC_REG_97293_INM(m)                       \
+	in_dword_masked(VIDC_REG_97293_ADDR,  m)
+#define VIDC_REG_97293_OUT(v)                       \
+	out_dword(VIDC_REG_97293_ADDR, v)
+#define VIDC_REG_97293_OUTM(m, v)                    \
+do { \
+	out_dword_masked_ns(VIDC_REG_97293_ADDR, m, v, \
+			VIDC_REG_97293_IN); \
+} while (0)
+#define VIDC_REG_97293_CH_ID_BMSK                         0x1f
+#define VIDC_REG_97293_CH_ID_SHFT                            0
+
+#define VIDC_REG_224135_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000108)
+#define VIDC_REG_224135_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000108)
+#define VIDC_REG_224135_RMSK                            0x1
+#define VIDC_REG_224135_SHFT                              0
+#define VIDC_REG_224135_IN                       \
+	in_dword_masked(VIDC_REG_224135_ADDR,        \
+	VIDC_REG_224135_RMSK)
+#define VIDC_REG_224135_INM(m)                   \
+	in_dword_masked(VIDC_REG_224135_ADDR,  m)
+#define VIDC_REG_224135_OUT(v)                   \
+	out_dword(VIDC_REG_224135_ADDR, v)
+#define VIDC_REG_224135_OUTM(m, v)                \
+do { \
+	out_dword_masked_ns(VIDC_REG_224135_ADDR, m, v, \
+			VIDC_REG_224135_IN); \
+} while (0)
+#define VIDC_REG_224135_CPU_RESET_BMSK                  0x1
+#define VIDC_REG_224135_CPU_RESET_SHFT                    0
+
+#define VIDC_REG_832522_ADDR                        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000010c)
+#define VIDC_REG_832522_PHYS                        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000010c)
+#define VIDC_REG_832522_RMSK                               0x1
+#define VIDC_REG_832522_SHFT                                 0
+#define VIDC_REG_832522_IN                          \
+	in_dword_masked(VIDC_REG_832522_ADDR,  VIDC_REG_832522_RMSK)
+#define VIDC_REG_832522_INM(m)                      \
+	in_dword_masked(VIDC_REG_832522_ADDR,  m)
+#define VIDC_REG_832522_OUT(v)                      \
+	out_dword(VIDC_REG_832522_ADDR, v)
+#define VIDC_REG_832522_OUTM(m, v)                   \
+do { \
+	out_dword_masked_ns(VIDC_REG_832522_ADDR, m, v, \
+			VIDC_REG_832522_IN); \
+} while (0)
+#define VIDC_REG_832522_FW_END_BMSK                        0x1
+#define VIDC_REG_832522_FW_END_SHFT                          0
+
+#define VIDC_REG_361582_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000110)
+#define VIDC_REG_361582_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000110)
+#define VIDC_REG_361582_RMSK                           0x1
+#define VIDC_REG_361582_SHFT                             0
+#define VIDC_REG_361582_IN                      \
+	in_dword_masked(VIDC_REG_361582_ADDR,  \
+			VIDC_REG_361582_RMSK)
+#define VIDC_REG_361582_INM(m)                  \
+	in_dword_masked(VIDC_REG_361582_ADDR,  m)
+#define VIDC_REG_361582_OUT(v)                  \
+	out_dword(VIDC_REG_361582_ADDR, v)
+#define VIDC_REG_361582_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_361582_ADDR, m, v, \
+			VIDC_REG_361582_IN); \
+} while (0)
+#define VIDC_REG_361582_BUS_MASTER_BMSK                0x1
+#define VIDC_REG_361582_BUS_MASTER_SHFT                  0
+
+#define VIDC_REG_314435_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000114)
+#define VIDC_REG_314435_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000114)
+#define VIDC_REG_314435_RMSK                          0x1
+#define VIDC_REG_314435_SHFT                            0
+#define VIDC_REG_314435_IN                     \
+	in_dword_masked(VIDC_REG_314435_ADDR,  \
+			VIDC_REG_314435_RMSK)
+#define VIDC_REG_314435_INM(m)                 \
+	in_dword_masked(VIDC_REG_314435_ADDR,  m)
+#define VIDC_REG_314435_OUT(v)                 \
+	out_dword(VIDC_REG_314435_ADDR, v)
+#define VIDC_REG_314435_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_314435_ADDR, m, v, \
+			VIDC_REG_314435_IN); \
+} while (0)
+#define VIDC_REG_314435_FRAME_START_BMSK              0x1
+#define VIDC_REG_314435_FRAME_START_SHFT                0
+
+#define VIDC_REG_999267_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000118)
+#define VIDC_REG_999267_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000118)
+#define VIDC_REG_999267_RMSK                        0xffff
+#define VIDC_REG_999267_SHFT                             0
+#define VIDC_REG_999267_IN                      \
+	in_dword_masked(VIDC_REG_999267_ADDR,  \
+			VIDC_REG_999267_RMSK)
+#define VIDC_REG_999267_INM(m)                  \
+	in_dword_masked(VIDC_REG_999267_ADDR,  m)
+#define VIDC_REG_999267_OUT(v)                  \
+	out_dword(VIDC_REG_999267_ADDR, v)
+#define VIDC_REG_999267_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_999267_ADDR, m, v, \
+			VIDC_REG_999267_IN); \
+} while (0)
+#define VIDC_REG_999267_IMG_SIZE_X_BMSK             0xffff
+#define VIDC_REG_999267_IMG_SIZE_X_SHFT                  0
+
+#define VIDC_REG_345712_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000011c)
+#define VIDC_REG_345712_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000011c)
+#define VIDC_REG_345712_RMSK                        0xffff
+#define VIDC_REG_345712_SHFT                             0
+#define VIDC_REG_345712_IN                      \
+	in_dword_masked(VIDC_REG_345712_ADDR,  \
+			VIDC_REG_345712_RMSK)
+#define VIDC_REG_345712_INM(m)                  \
+	in_dword_masked(VIDC_REG_345712_ADDR,  m)
+#define VIDC_REG_345712_OUT(v)                  \
+	out_dword(VIDC_REG_345712_ADDR, v)
+#define VIDC_REG_345712_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_345712_ADDR, m, v, \
+			VIDC_REG_345712_IN); \
+} while (0)
+#define VIDC_REG_345712_IMG_SIZE_Y_BMSK             0xffff
+#define VIDC_REG_345712_IMG_SIZE_Y_SHFT                  0
+
+#define VIDC_REG_443811_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000124)
+#define VIDC_REG_443811_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000124)
+#define VIDC_REG_443811_RMSK                              0x1
+#define VIDC_REG_443811_SHFT                                0
+#define VIDC_REG_443811_IN                         \
+	in_dword_masked(VIDC_REG_443811_ADDR,  VIDC_REG_443811_RMSK)
+#define VIDC_REG_443811_INM(m)                     \
+	in_dword_masked(VIDC_REG_443811_ADDR,  m)
+#define VIDC_REG_443811_OUT(v)                     \
+	out_dword(VIDC_REG_443811_ADDR, v)
+#define VIDC_REG_443811_OUTM(m, v)                  \
+do { \
+	out_dword_masked_ns(VIDC_REG_443811_ADDR, m, v, \
+			VIDC_REG_443811_IN); \
+} while (0)
+#define VIDC_REG_443811_POST_ON_BMSK                      0x1
+#define VIDC_REG_443811_POST_ON_SHFT                        0
+
+#define VIDC_REG_538267_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000128)
+#define VIDC_REG_538267_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000128)
+#define VIDC_REG_538267_RMSK                    0xffffffff
+#define VIDC_REG_538267_SHFT                             0
+#define VIDC_REG_538267_IN                      \
+	in_dword_masked(VIDC_REG_538267_ADDR,  \
+			VIDC_REG_538267_RMSK)
+#define VIDC_REG_538267_INM(m)                  \
+	in_dword_masked(VIDC_REG_538267_ADDR,  m)
+#define VIDC_REG_538267_OUT(v)                  \
+	out_dword(VIDC_REG_538267_ADDR, v)
+#define VIDC_REG_538267_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_538267_ADDR, m, v, \
+			VIDC_REG_538267_IN); \
+} while (0)
+#define VIDC_REG_538267_QUOTIENT_VAL_BMSK       0xffff0000
+#define VIDC_REG_538267_QUOTIENT_VAL_SHFT             0x10
+#define VIDC_REG_538267_REMAINDER_VAL_BMSK          0xffff
+#define VIDC_REG_538267_REMAINDER_VAL_SHFT               0
+
+#define VIDC_REG_661565_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000012c)
+#define VIDC_REG_661565_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000012c)
+#define VIDC_REG_661565_RMSK                       0x1
+#define VIDC_REG_661565_SHFT                         0
+#define VIDC_REG_661565_IN                  \
+	in_dword_masked(VIDC_REG_661565_ADDR,  \
+			VIDC_REG_661565_RMSK)
+#define VIDC_REG_661565_INM(m)              \
+	in_dword_masked(VIDC_REG_661565_ADDR,  m)
+#define VIDC_REG_661565_OUT(v)              \
+	out_dword(VIDC_REG_661565_ADDR, v)
+#define VIDC_REG_661565_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_661565_ADDR, m, v, \
+			VIDC_REG_661565_IN); \
+} while (0)
+#define VIDC_REG_661565_SEQUENCE_START_BMSK        0x1
+#define VIDC_REG_661565_SEQUENCE_START_SHFT          0
+
+#define VIDC_REG_141269_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000130)
+#define VIDC_REG_141269_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000130)
+#define VIDC_REG_141269_RMSK                             0x1
+#define VIDC_REG_141269_SHFT                               0
+#define VIDC_REG_141269_IN                        \
+	in_dword_masked(VIDC_REG_141269_ADDR,         \
+	VIDC_REG_141269_RMSK)
+#define VIDC_REG_141269_INM(m)                    \
+	in_dword_masked(VIDC_REG_141269_ADDR,  m)
+#define VIDC_REG_141269_OUT(v)                    \
+	out_dword(VIDC_REG_141269_ADDR, v)
+#define VIDC_REG_141269_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_141269_ADDR, m, v, \
+			VIDC_REG_141269_IN); \
+} while (0)
+#define VIDC_REG_141269_SW_RESET_BMSK                    0x1
+#define VIDC_REG_141269_SW_RESET_SHFT                      0
+
+#define VIDC_REG_193553_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000134)
+#define VIDC_REG_193553_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000134)
+#define VIDC_REG_193553_RMSK                             0x1
+#define VIDC_REG_193553_SHFT                               0
+#define VIDC_REG_193553_IN                        \
+	in_dword_masked(VIDC_REG_193553_ADDR,         \
+	VIDC_REG_193553_RMSK)
+#define VIDC_REG_193553_INM(m)                    \
+	in_dword_masked(VIDC_REG_193553_ADDR,  m)
+#define VIDC_REG_193553_OUT(v)                    \
+	out_dword(VIDC_REG_193553_ADDR, v)
+#define VIDC_REG_193553_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_193553_ADDR, m, v, \
+			VIDC_REG_193553_IN); \
+} while (0)
+#define VIDC_REG_193553_FW_START_BMSK                    0x1
+#define VIDC_REG_193553_FW_START_SHFT                      0
+
+#define VIDC_REG_215724_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000138)
+#define VIDC_REG_215724_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000138)
+#define VIDC_REG_215724_RMSK                           0x1
+#define VIDC_REG_215724_SHFT                             0
+#define VIDC_REG_215724_IN                      \
+	in_dword_masked(VIDC_REG_215724_ADDR,  \
+			VIDC_REG_215724_RMSK)
+#define VIDC_REG_215724_INM(m)                  \
+	in_dword_masked(VIDC_REG_215724_ADDR,  m)
+#define VIDC_REG_215724_OUT(v)                  \
+	out_dword(VIDC_REG_215724_ADDR, v)
+#define VIDC_REG_215724_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_215724_ADDR, m, v, \
+			VIDC_REG_215724_IN); \
+} while (0)
+#define VIDC_REG_215724_ARM_ENDIAN_BMSK                0x1
+#define VIDC_REG_215724_ARM_ENDIAN_SHFT                  0
+
+#define VIDC_REG_846346_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000013c)
+#define VIDC_REG_846346_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000013c)
+#define VIDC_REG_846346_RMSK                             0x1
+#define VIDC_REG_846346_SHFT                               0
+#define VIDC_REG_846346_IN                        \
+	in_dword_masked(VIDC_REG_846346_ADDR,         \
+	VIDC_REG_846346_RMSK)
+#define VIDC_REG_846346_INM(m)                    \
+	in_dword_masked(VIDC_REG_846346_ADDR,  m)
+#define VIDC_REG_846346_OUT(v)                    \
+	out_dword(VIDC_REG_846346_ADDR, v)
+#define VIDC_REG_846346_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_846346_ADDR, m, v, \
+			VIDC_REG_846346_IN); \
+} while (0)
+#define VIDC_REG_846346_ERR_CTRL_BMSK                    0x1
+#define VIDC_REG_846346_ERR_CTRL_SHFT                      0
+
+#define VIDC_REG_765787_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000200)
+#define VIDC_REG_765787_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000200)
+#define VIDC_REG_765787_RMSK                 0xffffffff
+#define VIDC_REG_765787_SHFT                          0
+#define VIDC_REG_765787_IN                   \
+	in_dword_masked(VIDC_REG_765787_ADDR,  \
+			VIDC_REG_765787_RMSK)
+#define VIDC_REG_765787_INM(m)               \
+	in_dword_masked(VIDC_REG_765787_ADDR,  m)
+#define VIDC_REG_765787_OUT(v)               \
+	out_dword(VIDC_REG_765787_ADDR, v)
+#define VIDC_REG_765787_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_765787_ADDR, m, v, \
+			VIDC_REG_765787_IN); \
+} while (0)
+#define VIDC_REG_765787_FW_STT_ADDR_0_BMSK   0xffffffff
+#define VIDC_REG_765787_FW_STT_ADDR_0_SHFT            0
+
+#define VIDC_REG_225040_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000204)
+#define VIDC_REG_225040_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000204)
+#define VIDC_REG_225040_RMSK                 0xffffffff
+#define VIDC_REG_225040_SHFT                          0
+#define VIDC_REG_225040_IN                   \
+	in_dword_masked(VIDC_REG_225040_ADDR,  \
+			VIDC_REG_225040_RMSK)
+#define VIDC_REG_225040_INM(m)               \
+	in_dword_masked(VIDC_REG_225040_ADDR,  m)
+#define VIDC_REG_225040_OUT(v)               \
+	out_dword(VIDC_REG_225040_ADDR, v)
+#define VIDC_REG_225040_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_225040_ADDR, m, v, \
+			VIDC_REG_225040_IN); \
+} while (0)
+#define VIDC_REG_225040_FW_STT_ADDR_1_BMSK   0xffffffff
+#define VIDC_REG_225040_FW_STT_ADDR_1_SHFT            0
+
+#define VIDC_REG_942456_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000208)
+#define VIDC_REG_942456_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000208)
+#define VIDC_REG_942456_RMSK                 0xffffffff
+#define VIDC_REG_942456_SHFT                          0
+#define VIDC_REG_942456_IN                   \
+	in_dword_masked(VIDC_REG_942456_ADDR,  \
+			VIDC_REG_942456_RMSK)
+#define VIDC_REG_942456_INM(m)               \
+	in_dword_masked(VIDC_REG_942456_ADDR,  m)
+#define VIDC_REG_942456_OUT(v)               \
+	out_dword(VIDC_REG_942456_ADDR, v)
+#define VIDC_REG_942456_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_942456_ADDR, m, v, \
+			VIDC_REG_942456_IN); \
+} while (0)
+#define VIDC_REG_942456_FW_STT_ADDR_2_BMSK   0xffffffff
+#define VIDC_REG_942456_FW_STT_ADDR_2_SHFT            0
+
+#define VIDC_REG_942170_ADDR_3_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000020c)
+#define VIDC_REG_942170_ADDR_3_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000020c)
+#define VIDC_REG_942170_ADDR_3_RMSK                 0xffffffff
+#define VIDC_REG_942170_ADDR_3_SHFT                          0
+#define VIDC_REG_942170_ADDR_3_IN                   \
+	in_dword_masked(VIDC_REG_942170_ADDR_3_ADDR,  \
+			VIDC_REG_942170_ADDR_3_RMSK)
+#define VIDC_REG_942170_ADDR_3_INM(m)               \
+	in_dword_masked(VIDC_REG_942170_ADDR_3_ADDR,  m)
+#define VIDC_REG_942170_ADDR_3_OUT(v)               \
+	out_dword(VIDC_REG_942170_ADDR_3_ADDR, v)
+#define VIDC_REG_942170_ADDR_3_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_942170_ADDR_3_ADDR, m, v, \
+			VIDC_REG_942170_ADDR_3_IN); \
+} while (0)
+#define VIDC_REG_942170_ADDR_3_FW_STT_ADDR_3_BMSK   0xffffffff
+#define VIDC_REG_942170_ADDR_3_FW_STT_ADDR_3_SHFT            0
+
+#define VIDC_REG_880188_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000210)
+#define VIDC_REG_880188_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000210)
+#define VIDC_REG_880188_RMSK                 0xffffffff
+#define VIDC_REG_880188_SHFT                          0
+#define VIDC_REG_880188_IN                   \
+	in_dword_masked(VIDC_REG_880188_ADDR,  \
+			VIDC_REG_880188_RMSK)
+#define VIDC_REG_880188_INM(m)               \
+	in_dword_masked(VIDC_REG_880188_ADDR,  m)
+#define VIDC_REG_880188_OUT(v)               \
+	out_dword(VIDC_REG_880188_ADDR, v)
+#define VIDC_REG_880188_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_880188_ADDR, m, v, \
+			VIDC_REG_880188_IN); \
+} while (0)
+#define VIDC_REG_880188_FW_STT_ADDR_4_BMSK   0xffffffff
+#define VIDC_REG_880188_FW_STT_ADDR_4_SHFT            0
+
+#define VIDC_REG_40293_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000214)
+#define VIDC_REG_40293_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000214)
+#define VIDC_REG_40293_RMSK                 0xffffffff
+#define VIDC_REG_40293_SHFT                          0
+#define VIDC_REG_40293_IN                   \
+	in_dword_masked(VIDC_REG_40293_ADDR,  \
+			VIDC_REG_40293_RMSK)
+#define VIDC_REG_40293_INM(m)               \
+	in_dword_masked(VIDC_REG_40293_ADDR,  m)
+#define VIDC_REG_40293_OUT(v)               \
+	out_dword(VIDC_REG_40293_ADDR, v)
+#define VIDC_REG_40293_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_40293_ADDR, m, v, \
+			VIDC_REG_40293_IN); \
+} while (0)
+#define VIDC_REG_40293_FW_STT_ADDR_5_BMSK   0xffffffff
+#define VIDC_REG_40293_FW_STT_ADDR_5_SHFT            0
+
+#define VIDC_REG_942170_ADDR_6_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000218)
+#define VIDC_REG_942170_ADDR_6_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000218)
+#define VIDC_REG_942170_ADDR_6_RMSK                 0xffffffff
+#define VIDC_REG_942170_ADDR_6_SHFT                          0
+#define VIDC_REG_942170_ADDR_6_IN                   \
+	in_dword_masked(VIDC_REG_942170_ADDR_6_ADDR,  \
+			VIDC_REG_942170_ADDR_6_RMSK)
+#define VIDC_REG_942170_ADDR_6_INM(m)               \
+	in_dword_masked(VIDC_REG_942170_ADDR_6_ADDR,  m)
+#define VIDC_REG_942170_ADDR_6_OUT(v)               \
+	out_dword(VIDC_REG_942170_ADDR_6_ADDR, v)
+#define VIDC_REG_942170_ADDR_6_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_942170_ADDR_6_ADDR, m, v, \
+			VIDC_REG_942170_ADDR_6_IN); \
+} while (0)
+#define VIDC_REG_942170_ADDR_6_FW_STT_ADDR_6_BMSK   0xffffffff
+#define VIDC_REG_942170_ADDR_6_FW_STT_ADDR_6_SHFT            0
+
+#define VIDC_REG_958768_ADDR                  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000230)
+#define VIDC_REG_958768_PHYS                  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000230)
+#define VIDC_REG_958768_RMSK                  0xffffffff
+#define VIDC_REG_958768_SHFT                           0
+#define VIDC_REG_958768_IN                    \
+	in_dword_masked(VIDC_REG_958768_ADDR,  \
+			VIDC_REG_958768_RMSK)
+#define VIDC_REG_958768_INM(m)                \
+	in_dword_masked(VIDC_REG_958768_ADDR,  m)
+#define VIDC_REG_958768_OUT(v)                \
+	out_dword(VIDC_REG_958768_ADDR, v)
+#define VIDC_REG_958768_OUTM(m, v)             \
+do { \
+	out_dword_masked_ns(VIDC_REG_958768_ADDR, m, v, \
+			VIDC_REG_958768_IN); \
+} while (0)
+#define VIDC_REG_699384_ADDR_BMSK     0xffffffff
+#define VIDC_REG_699384_ADDR_SHFT              0
+
+#define VIDC_REG_979942_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000234)
+#define VIDC_REG_979942_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000234)
+#define VIDC_REG_979942_RMSK                   0xffffffff
+#define VIDC_REG_979942_SHFT                            0
+#define VIDC_REG_979942_IN                     \
+	in_dword_masked(VIDC_REG_979942_ADDR,  \
+			VIDC_REG_979942_RMSK)
+#define VIDC_REG_979942_INM(m)                 \
+	in_dword_masked(VIDC_REG_979942_ADDR,  m)
+#define VIDC_REG_979942_OUT(v)                 \
+	out_dword(VIDC_REG_979942_ADDR, v)
+#define VIDC_REG_979942_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_979942_ADDR, m, v, \
+			VIDC_REG_979942_IN); \
+} while (0)
+#define VIDC_REG_979942_DB_STT_ADDR_BMSK       0xffffffff
+#define VIDC_REG_979942_DB_STT_ADDR_SHFT                0
+
+#define VIDC_REG_839021_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000300)
+#define VIDC_REG_839021_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000300)
+#define VIDC_REG_839021_RMSK                           0xff1f
+#define VIDC_REG_839021_SHFT                                0
+#define VIDC_REG_839021_IN                         \
+	in_dword_masked(VIDC_REG_839021_ADDR,  VIDC_REG_839021_RMSK)
+#define VIDC_REG_839021_INM(m)                     \
+	in_dword_masked(VIDC_REG_839021_ADDR,  m)
+#define VIDC_REG_839021_OUT(v)                     \
+	out_dword(VIDC_REG_839021_ADDR, v)
+#define VIDC_REG_839021_OUTM(m, v)                  \
+do { \
+	out_dword_masked_ns(VIDC_REG_839021_ADDR, m, v, \
+			VIDC_REG_839021_IN); \
+} while (0)
+#define VIDC_REG_839021_LEVEL_BMSK                     0xff00
+#define VIDC_REG_839021_LEVEL_SHFT                        0x8
+#define VIDC_REG_839021_PROFILE_BMSK                     0x1f
+#define VIDC_REG_839021_PROFILE_SHFT                        0
+
+#define VIDC_REG_950374_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000308)
+#define VIDC_REG_950374_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000308)
+#define VIDC_REG_950374_RMSK                          0xffff
+#define VIDC_REG_950374_SHFT                               0
+#define VIDC_REG_950374_IN                        \
+	in_dword_masked(VIDC_REG_950374_ADDR,         \
+	VIDC_REG_950374_RMSK)
+#define VIDC_REG_950374_INM(m)                    \
+	in_dword_masked(VIDC_REG_950374_ADDR,  m)
+#define VIDC_REG_950374_OUT(v)                    \
+	out_dword(VIDC_REG_950374_ADDR, v)
+#define VIDC_REG_950374_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_950374_ADDR, m, v, \
+			VIDC_REG_950374_IN); \
+} while (0)
+#define VIDC_REG_950374_I_PERIOD_BMSK                 0xffff
+#define VIDC_REG_950374_I_PERIOD_SHFT                      0
+
+#define VIDC_REG_504878_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000310)
+#define VIDC_REG_504878_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000310)
+#define VIDC_REG_504878_RMSK                      0xd
+#define VIDC_REG_504878_SHFT                        0
+#define VIDC_REG_504878_IN                 \
+	in_dword_masked(VIDC_REG_504878_ADDR,  \
+			VIDC_REG_504878_RMSK)
+#define VIDC_REG_504878_INM(m)             \
+	in_dword_masked(VIDC_REG_504878_ADDR,  m)
+#define VIDC_REG_504878_OUT(v)             \
+	out_dword(VIDC_REG_504878_ADDR, v)
+#define VIDC_REG_504878_OUTM(m, v)          \
+do { \
+	out_dword_masked_ns(VIDC_REG_504878_ADDR, m, v, \
+			VIDC_REG_504878_IN); \
+} while (0)
+#define VIDC_REG_504878_FIXED_NUMBER_BMSK         0xc
+#define VIDC_REG_504878_FIXED_NUMBER_SHFT         0x2
+#define VIDC_REG_504878_ENTROPY_SEL_BMSK          0x1
+#define VIDC_REG_504878_ENTROPY_SEL_SHFT            0
+
+#define VIDC_REG_458130_ADDR            \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000314)
+#define VIDC_REG_458130_PHYS            \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000314)
+#define VIDC_REG_458130_RMSK                 0xfff
+#define VIDC_REG_458130_SHFT                     0
+#define VIDC_REG_458130_IN              \
+	in_dword_masked(VIDC_REG_458130_ADDR,  \
+			VIDC_REG_458130_RMSK)
+#define VIDC_REG_458130_INM(m)          \
+	in_dword_masked(VIDC_REG_458130_ADDR,  m)
+#define VIDC_REG_458130_OUT(v)          \
+	out_dword(VIDC_REG_458130_ADDR, v)
+#define VIDC_REG_458130_OUTM(m, v)       \
+do { \
+	out_dword_masked_ns(VIDC_REG_458130_ADDR, m, v, \
+			VIDC_REG_458130_IN); \
+} while (0)
+#define VIDC_REG_458130_SLICE_ALPHA_C0_OFFSET_DIV2_BMSK      \
+	0xf80
+#define VIDC_REG_458130_SLICE_ALPHA_C0_OFFSET_DIV2_SHFT      \
+	0x7
+#define VIDC_REG_458130_SLICE_BETA_OFFSET_DIV2_BMSK       0x7c
+#define VIDC_REG_458130_SLICE_BETA_OFFSET_DIV2_SHFT        0x2
+#define \
+	\
+VIDC_REG_458130_DISABLE_DEBLOCKING_FILTER_IDC_BMSK        0x3
+#define \
+	\
+VIDC_REG_458130_DISABLE_DEBLOCKING_FILTER_IDC_SHFT          0
+
+#define VIDC_REG_314290_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000318)
+#define VIDC_REG_314290_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000318)
+#define VIDC_REG_314290_RMSK                          0x1
+#define VIDC_REG_314290_SHFT                            0
+#define VIDC_REG_314290_IN                     \
+	in_dword_masked(VIDC_REG_314290_ADDR,  \
+			VIDC_REG_314290_RMSK)
+#define VIDC_REG_314290_INM(m)                 \
+	in_dword_masked(VIDC_REG_314290_ADDR,  m)
+#define VIDC_REG_314290_OUT(v)                 \
+	out_dword(VIDC_REG_314290_ADDR, v)
+#define VIDC_REG_314290_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_314290_ADDR, m, v, \
+			VIDC_REG_314290_IN); \
+} while (0)
+#define VIDC_REG_314290_SHORT_HD_ON_BMSK              0x1
+#define VIDC_REG_314290_SHORT_HD_ON_SHFT                0
+
+#define VIDC_REG_588301_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000031c)
+#define VIDC_REG_588301_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000031c)
+#define VIDC_REG_588301_RMSK                           0x1
+#define VIDC_REG_588301_SHFT                             0
+#define VIDC_REG_588301_IN                      \
+	in_dword_masked(VIDC_REG_588301_ADDR,  \
+			VIDC_REG_588301_RMSK)
+#define VIDC_REG_588301_INM(m)                  \
+	in_dword_masked(VIDC_REG_588301_ADDR,  m)
+#define VIDC_REG_588301_OUT(v)                  \
+	out_dword(VIDC_REG_588301_ADDR, v)
+#define VIDC_REG_588301_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_588301_ADDR, m, v, \
+			VIDC_REG_588301_IN); \
+} while (0)
+#define VIDC_REG_588301_MSLICE_ENA_BMSK                0x1
+#define VIDC_REG_588301_MSLICE_ENA_SHFT                  0
+
+#define VIDC_REG_1517_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000320)
+#define VIDC_REG_1517_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000320)
+#define VIDC_REG_1517_RMSK                           0x3
+#define VIDC_REG_1517_SHFT                             0
+#define VIDC_REG_1517_IN                      \
+	in_dword_masked(VIDC_REG_1517_ADDR,  \
+			VIDC_REG_1517_RMSK)
+#define VIDC_REG_1517_INM(m)                  \
+	in_dword_masked(VIDC_REG_1517_ADDR,  m)
+#define VIDC_REG_1517_OUT(v)                  \
+	out_dword(VIDC_REG_1517_ADDR, v)
+#define VIDC_REG_1517_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_1517_ADDR, m, v, \
+			VIDC_REG_1517_IN); \
+} while (0)
+#define VIDC_REG_1517_MSLICE_SEL_BMSK                0x3
+#define VIDC_REG_1517_MSLICE_SEL_SHFT                  0
+
+#define VIDC_REG_105335_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000324)
+#define VIDC_REG_105335_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000324)
+#define VIDC_REG_105335_RMSK                     0xffffffff
+#define VIDC_REG_105335_SHFT                              0
+#define VIDC_REG_105335_IN                       \
+	in_dword_masked(VIDC_REG_105335_ADDR,        \
+	VIDC_REG_105335_RMSK)
+#define VIDC_REG_105335_INM(m)                   \
+	in_dword_masked(VIDC_REG_105335_ADDR,  m)
+#define VIDC_REG_105335_OUT(v)                   \
+	out_dword(VIDC_REG_105335_ADDR, v)
+#define VIDC_REG_105335_OUTM(m, v)                \
+do { \
+	out_dword_masked_ns(VIDC_REG_105335_ADDR, m, v, \
+			VIDC_REG_105335_IN); \
+} while (0)
+#define VIDC_REG_105335_MSLICE_MB_BMSK           0xffffffff
+#define VIDC_REG_105335_MSLICE_MB_SHFT                    0
+
+#define VIDC_REG_561679_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000328)
+#define VIDC_REG_561679_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000328)
+#define VIDC_REG_561679_RMSK                   0xffffffff
+#define VIDC_REG_561679_SHFT                            0
+#define VIDC_REG_561679_IN                     \
+	in_dword_masked(VIDC_REG_561679_ADDR,  \
+			VIDC_REG_561679_RMSK)
+#define VIDC_REG_561679_INM(m)                 \
+	in_dword_masked(VIDC_REG_561679_ADDR,  m)
+#define VIDC_REG_561679_OUT(v)                 \
+	out_dword(VIDC_REG_561679_ADDR, v)
+#define VIDC_REG_561679_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_561679_ADDR, m, v, \
+			VIDC_REG_561679_IN); \
+} while (0)
+#define VIDC_REG_561679_MSLICE_BYTE_BMSK       0xffffffff
+#define VIDC_REG_561679_MSLICE_BYTE_SHFT                0
+
+#define VIDC_REG_151345_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000400)
+#define VIDC_REG_151345_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000400)
+#define VIDC_REG_151345_RMSK                 0xffffffff
+#define VIDC_REG_151345_SHFT                          0
+#define VIDC_REG_151345_IN                   \
+	in_dword_masked(VIDC_REG_151345_ADDR,  \
+			VIDC_REG_151345_RMSK)
+#define VIDC_REG_151345_INM(m)               \
+	in_dword_masked(VIDC_REG_151345_ADDR,  m)
+#define VIDC_REG_151345_DISPLAY_Y_ADR_BMSK   0xffffffff
+#define VIDC_REG_151345_DISPLAY_Y_ADR_SHFT            0
+
+#define VIDC_REG_293983_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000404)
+#define VIDC_REG_293983_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000404)
+#define VIDC_REG_293983_RMSK                 0xffffffff
+#define VIDC_REG_293983_SHFT                          0
+#define VIDC_REG_293983_IN                   \
+	in_dword_masked(VIDC_REG_293983_ADDR,  \
+			VIDC_REG_293983_RMSK)
+#define VIDC_REG_293983_INM(m)               \
+	in_dword_masked(VIDC_REG_293983_ADDR,  m)
+#define VIDC_REG_293983_DISPLAY_C_ADR_BMSK   0xffffffff
+#define VIDC_REG_293983_DISPLAY_C_ADR_SHFT            0
+
+#define VIDC_REG_612715_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000408)
+#define VIDC_REG_612715_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000408)
+#define VIDC_REG_612715_RMSK                      0x3f
+#define VIDC_REG_612715_SHFT                         0
+#define VIDC_REG_612715_IN                  \
+	in_dword_masked(VIDC_REG_612715_ADDR,  \
+			VIDC_REG_612715_RMSK)
+#define VIDC_REG_612715_INM(m)              \
+	in_dword_masked(VIDC_REG_612715_ADDR,  m)
+#define VIDC_REG_612715_DISPLAY_STATUS_BMSK       0x3f
+#define VIDC_REG_612715_DISPLAY_STATUS_SHFT          0
+
+#define VIDC_REG_209364_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000040c)
+#define VIDC_REG_209364_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000040c)
+#define VIDC_REG_209364_RMSK                          0x1
+#define VIDC_REG_209364_SHFT                            0
+#define VIDC_REG_209364_IN                     \
+	in_dword_masked(VIDC_REG_209364_ADDR,  \
+			VIDC_REG_209364_RMSK)
+#define VIDC_REG_209364_INM(m)                 \
+	in_dword_masked(VIDC_REG_209364_ADDR,  m)
+#define VIDC_REG_209364_HEADER_DONE_BMSK              0x1
+#define VIDC_REG_209364_HEADER_DONE_SHFT                0
+
+#define VIDC_REG_757835_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000410)
+#define VIDC_REG_757835_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000410)
+#define VIDC_REG_757835_RMSK                     0xffffffff
+#define VIDC_REG_757835_SHFT                              0
+#define VIDC_REG_757835_IN                       \
+	in_dword_masked(VIDC_REG_757835_ADDR,        \
+	VIDC_REG_757835_RMSK)
+#define VIDC_REG_757835_INM(m)                   \
+	in_dword_masked(VIDC_REG_757835_ADDR,  m)
+#define VIDC_REG_757835_FRAME_NUM_BMSK           0xffffffff
+#define VIDC_REG_757835_FRAME_NUM_SHFT                    0
+
+#define VIDC_REG_352831_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000414)
+#define VIDC_REG_352831_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000414)
+#define VIDC_REG_352831_RMSK              0xffffffff
+#define VIDC_REG_352831_SHFT                       0
+#define VIDC_REG_352831_IN                \
+	in_dword_masked(VIDC_REG_352831_ADDR,  \
+			VIDC_REG_352831_RMSK)
+#define VIDC_REG_352831_INM(m)            \
+	in_dword_masked(VIDC_REG_352831_ADDR,  m)
+#define VIDC_REG_352831_DBG_INFO_OUTPUT0_BMSK 0xffffffff
+#define VIDC_REG_352831_DBG_INFO_OUTPUT0_SHFT          0
+
+#define VIDC_REG_668634_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000418)
+#define VIDC_REG_668634_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000418)
+#define VIDC_REG_668634_RMSK              0xffffffff
+#define VIDC_REG_668634_SHFT                       0
+#define VIDC_REG_668634_IN                \
+	in_dword_masked(VIDC_REG_668634_ADDR,  \
+			VIDC_REG_668634_RMSK)
+#define VIDC_REG_668634_INM(m)            \
+	in_dword_masked(VIDC_REG_668634_ADDR,  m)
+#define VIDC_REG_668634_DBG_INFO_OUTPUT1_BMSK 0xffffffff
+#define VIDC_REG_668634_DBG_INFO_OUTPUT1_SHFT          0
+
+#define VIDC_REG_609676_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000500)
+#define VIDC_REG_609676_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000500)
+#define VIDC_REG_609676_RMSK                              0x1
+#define VIDC_REG_609676_SHFT                                0
+#define VIDC_REG_609676_IN                         \
+	in_dword_masked(VIDC_REG_609676_ADDR,  VIDC_REG_609676_RMSK)
+#define VIDC_REG_609676_INM(m)                     \
+	in_dword_masked(VIDC_REG_609676_ADDR,  m)
+#define VIDC_REG_609676_OUT(v)                     \
+	out_dword(VIDC_REG_609676_ADDR, v)
+#define VIDC_REG_609676_OUTM(m, v)                  \
+do { \
+	out_dword_masked_ns(VIDC_REG_609676_ADDR, m, v, \
+			VIDC_REG_609676_IN); \
+} while (0)
+#define VIDC_REG_609676_INT_OFF_BMSK                      0x1
+#define VIDC_REG_609676_INT_OFF_SHFT                        0
+
+#define VIDC_REG_491082_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000504)
+#define VIDC_REG_491082_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000504)
+#define VIDC_REG_491082_RMSK                        0x1
+#define VIDC_REG_491082_SHFT                          0
+#define VIDC_REG_491082_IN                   \
+	in_dword_masked(VIDC_REG_491082_ADDR,  \
+			VIDC_REG_491082_RMSK)
+#define VIDC_REG_491082_INM(m)               \
+	in_dword_masked(VIDC_REG_491082_ADDR,  m)
+#define VIDC_REG_491082_OUT(v)               \
+	out_dword(VIDC_REG_491082_ADDR, v)
+#define VIDC_REG_491082_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_491082_ADDR, m, v, \
+			VIDC_REG_491082_IN); \
+} while (0)
+#define VIDC_REG_491082_INT_PULSE_SEL_BMSK          0x1
+#define VIDC_REG_491082_INT_PULSE_SEL_SHFT            0
+
+#define VIDC_REG_614776_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000508)
+#define VIDC_REG_614776_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000508)
+#define VIDC_REG_614776_RMSK                       0x1
+#define VIDC_REG_614776_SHFT                         0
+#define VIDC_REG_614776_IN                  \
+	in_dword_masked(VIDC_REG_614776_ADDR,  \
+			VIDC_REG_614776_RMSK)
+#define VIDC_REG_614776_INM(m)              \
+	in_dword_masked(VIDC_REG_614776_ADDR,  m)
+#define VIDC_REG_614776_OUT(v)              \
+	out_dword(VIDC_REG_614776_ADDR, v)
+#define VIDC_REG_614776_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_614776_ADDR, m, v, \
+			VIDC_REG_614776_IN); \
+} while (0)
+#define VIDC_REG_614776_INT_DONE_CLEAR_BMSK        0x1
+#define VIDC_REG_614776_INT_DONE_CLEAR_SHFT          0
+
+#define VIDC_REG_982553_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000050c)
+#define VIDC_REG_982553_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000050c)
+#define VIDC_REG_982553_RMSK                       0x1
+#define VIDC_REG_982553_SHFT                         0
+#define VIDC_REG_982553_IN                  \
+	in_dword_masked(VIDC_REG_982553_ADDR,  \
+			VIDC_REG_982553_RMSK)
+#define VIDC_REG_982553_INM(m)              \
+	in_dword_masked(VIDC_REG_982553_ADDR,  m)
+#define VIDC_REG_982553_OPERATION_DONE_BMSK        0x1
+#define VIDC_REG_982553_OPERATION_DONE_SHFT          0
+
+#define VIDC_REG_259967_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000510)
+#define VIDC_REG_259967_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000510)
+#define VIDC_REG_259967_RMSK                              0x1
+#define VIDC_REG_259967_SHFT                                0
+#define VIDC_REG_259967_IN                         \
+	in_dword_masked(VIDC_REG_259967_ADDR,  VIDC_REG_259967_RMSK)
+#define VIDC_REG_259967_INM(m)                     \
+	in_dword_masked(VIDC_REG_259967_ADDR,  m)
+#define VIDC_REG_259967_FW_DONE_BMSK                      0x1
+#define VIDC_REG_259967_FW_DONE_SHFT                        0
+
+#define VIDC_REG_512143_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000514)
+#define VIDC_REG_512143_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000514)
+#define VIDC_REG_512143_RMSK                         0x1f8
+#define VIDC_REG_512143_SHFT                             0
+#define VIDC_REG_512143_IN                      \
+	in_dword_masked(VIDC_REG_512143_ADDR,  \
+			VIDC_REG_512143_RMSK)
+#define VIDC_REG_512143_INM(m)                  \
+	in_dword_masked(VIDC_REG_512143_ADDR,  m)
+#define VIDC_REG_512143_FRAME_DONE_STAT_BMSK         0x100
+#define VIDC_REG_512143_FRAME_DONE_STAT_SHFT           0x8
+#define VIDC_REG_512143_DMA_DONE_STAT_BMSK            0x80
+#define VIDC_REG_512143_DMA_DONE_STAT_SHFT             0x7
+#define VIDC_REG_512143_HEADER_DONE_STAT_BMSK         0x40
+#define VIDC_REG_512143_HEADER_DONE_STAT_SHFT          0x6
+#define VIDC_REG_512143_FW_DONE_STAT_BMSK             0x20
+#define VIDC_REG_512143_FW_DONE_STAT_SHFT              0x5
+#define VIDC_REG_512143_OPERATION_FAILED_BMSK         0x10
+#define VIDC_REG_512143_OPERATION_FAILED_SHFT          0x4
+#define VIDC_REG_512143_STREAM_HDR_CHANGED_BMSK        0x8
+#define VIDC_REG_512143_STREAM_HDR_CHANGED_SHFT        0x3
+
+#define VIDC_REG_418173_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000518)
+#define VIDC_REG_418173_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000518)
+#define VIDC_REG_418173_RMSK                     0x1fa
+#define VIDC_REG_418173_SHFT                         0
+#define VIDC_REG_418173_IN                  \
+	in_dword_masked(VIDC_REG_418173_ADDR,  \
+			VIDC_REG_418173_RMSK)
+#define VIDC_REG_418173_INM(m)              \
+	in_dword_masked(VIDC_REG_418173_ADDR,  m)
+#define VIDC_REG_418173_OUT(v)              \
+	out_dword(VIDC_REG_418173_ADDR, v)
+#define VIDC_REG_418173_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_418173_ADDR, m, v, \
+			VIDC_REG_418173_IN); \
+} while (0)
+#define VIDC_REG_418173_FRAME_DONE_ENABLE_BMSK      0x100
+#define VIDC_REG_418173_FRAME_DONE_ENABLE_SHFT        0x8
+#define VIDC_REG_418173_DMA_DONE_ENABLE_BMSK       0x80
+#define VIDC_REG_418173_DMA_DONE_ENABLE_SHFT        0x7
+#define VIDC_REG_418173_HEADER_DONE_ENABLE_BMSK       0x40
+#define VIDC_REG_418173_HEADER_DONE_ENABLE_SHFT        0x6
+#define VIDC_REG_418173_FW_DONE_ENABLE_BMSK       0x20
+#define VIDC_REG_418173_FW_DONE_ENABLE_SHFT        0x5
+#define VIDC_REG_418173_OPERATION_FAILED_ENABLE_BMSK       0x10
+#define VIDC_REG_418173_OPERATION_FAILED_ENABLE_SHFT        0x4
+#define VIDC_REG_418173_STREAM_HDR_CHANGED_ENABLE_BMSK        0x8
+#define VIDC_REG_418173_STREAM_HDR_CHANGED_ENABLE_SHFT        0x3
+#define VIDC_REG_418173_BUFFER_FULL_ENABLE_BMSK        0x2
+#define VIDC_REG_418173_BUFFER_FULL_ENABLE_SHFT        0x1
+
+#define VIDC_REG_841539_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000600)
+#define VIDC_REG_841539_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000600)
+#define VIDC_REG_841539_RMSK                       0x3
+#define VIDC_REG_841539_SHFT                         0
+#define VIDC_REG_841539_IN                  \
+	in_dword_masked(VIDC_REG_841539_ADDR,  \
+			VIDC_REG_841539_RMSK)
+#define VIDC_REG_841539_INM(m)              \
+	in_dword_masked(VIDC_REG_841539_ADDR,  m)
+#define VIDC_REG_841539_OUT(v)              \
+	out_dword(VIDC_REG_841539_ADDR, v)
+#define VIDC_REG_841539_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_841539_ADDR, m, v, \
+			VIDC_REG_841539_IN); \
+} while (0)
+#define VIDC_REG_841539_TILE_MODE_BMSK             0x3
+#define VIDC_REG_841539_TILE_MODE_SHFT               0
+
+#define VIDC_REG_99105_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000800)
+#define VIDC_REG_99105_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000800)
+#define VIDC_REG_99105_RMSK                0xffffffff
+#define VIDC_REG_99105_SHFT                         0
+#define VIDC_REG_99105_IN                  \
+	in_dword_masked(VIDC_REG_99105_ADDR,  \
+			VIDC_REG_99105_RMSK)
+#define VIDC_REG_99105_INM(m)              \
+	in_dword_masked(VIDC_REG_99105_ADDR,  m)
+#define VIDC_REG_99105_OUT(v)              \
+	out_dword(VIDC_REG_99105_ADDR, v)
+#define VIDC_REG_99105_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_99105_ADDR, m, v, \
+			VIDC_REG_99105_IN); \
+} while (0)
+#define VIDC_REG_99105_ENC_CUR_Y_ADDR_BMSK 0xffffffff
+#define VIDC_REG_99105_ENC_CUR_Y_ADDR_SHFT          0
+
+#define VIDC_REG_777113_ADDR_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000804)
+#define VIDC_REG_777113_ADDR_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000804)
+#define VIDC_REG_777113_ADDR_RMSK                0xffffffff
+#define VIDC_REG_777113_ADDR_SHFT                         0
+#define VIDC_REG_777113_ADDR_IN                  \
+	in_dword_masked(VIDC_REG_777113_ADDR_ADDR,  \
+			VIDC_REG_777113_ADDR_RMSK)
+#define VIDC_REG_777113_ADDR_INM(m)              \
+	in_dword_masked(VIDC_REG_777113_ADDR_ADDR,  m)
+#define VIDC_REG_777113_ADDR_OUT(v)              \
+	out_dword(VIDC_REG_777113_ADDR_ADDR, v)
+#define VIDC_REG_777113_ADDR_OUTM(m, v)           \
+do { \
+	out_dword_masked_ns(VIDC_REG_777113_ADDR_ADDR, m, v, \
+			VIDC_REG_777113_ADDR_IN); \
+} while (0)
+#define VIDC_REG_777113_ADDR_ENC_CUR_C_ADDR_BMSK 0xffffffff
+#define VIDC_REG_777113_ADDR_ENC_CUR_C_ADDR_SHFT          0
+
+#define VIDC_REG_341928_ADDR_ADDR                  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000080c)
+#define VIDC_REG_341928_ADDR_PHYS                  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000080c)
+#define VIDC_REG_341928_ADDR_RMSK                  0xffffffff
+#define VIDC_REG_341928_ADDR_SHFT                           0
+#define VIDC_REG_341928_ADDR_IN                    \
+	in_dword_masked(VIDC_REG_341928_ADDR_ADDR,  \
+			VIDC_REG_341928_ADDR_RMSK)
+#define VIDC_REG_341928_ADDR_INM(m)                \
+	in_dword_masked(VIDC_REG_341928_ADDR_ADDR,  m)
+#define VIDC_REG_341928_ADDR_OUT(v)                \
+	out_dword(VIDC_REG_341928_ADDR_ADDR, v)
+#define VIDC_REG_341928_ADDR_OUTM(m, v)             \
+do { \
+	out_dword_masked_ns(VIDC_REG_341928_ADDR_ADDR, m, v, \
+			VIDC_REG_341928_ADDR_IN); \
+} while (0)
+#define VIDC_REG_341928_ADDR_ENC_DPB_ADR_BMSK      0xffffffff
+#define VIDC_REG_341928_ADDR_ENC_DPB_ADR_SHFT               0
+
+#define VIDC_REG_857491_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000810)
+#define VIDC_REG_857491_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000810)
+#define VIDC_REG_857491_RMSK                         0xfff
+#define VIDC_REG_857491_SHFT                             0
+#define VIDC_REG_857491_IN                      \
+	in_dword_masked(VIDC_REG_857491_ADDR,  \
+			VIDC_REG_857491_RMSK)
+#define VIDC_REG_857491_INM(m)                  \
+	in_dword_masked(VIDC_REG_857491_ADDR,  m)
+#define VIDC_REG_857491_OUT(v)                  \
+	out_dword(VIDC_REG_857491_ADDR, v)
+#define VIDC_REG_857491_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_857491_ADDR, m, v, \
+			VIDC_REG_857491_IN); \
+} while (0)
+#define VIDC_REG_857491_CIR_MB_NUM_BMSK              0xfff
+#define VIDC_REG_857491_CIR_MB_NUM_SHFT                  0
+
+#define VIDC_REG_518133_ADDR                  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000900)
+#define VIDC_REG_518133_PHYS                  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000900)
+#define VIDC_REG_518133_RMSK                  0xffffffff
+#define VIDC_REG_518133_SHFT                           0
+#define VIDC_REG_518133_IN                    \
+	in_dword_masked(VIDC_REG_518133_ADDR,  \
+			VIDC_REG_518133_RMSK)
+#define VIDC_REG_518133_INM(m)                \
+	in_dword_masked(VIDC_REG_518133_ADDR,  m)
+#define VIDC_REG_518133_OUT(v)                \
+	out_dword(VIDC_REG_518133_ADDR, v)
+#define VIDC_REG_518133_OUTM(m, v)             \
+do { \
+	out_dword_masked_ns(VIDC_REG_518133_ADDR, m, v, \
+			VIDC_REG_518133_IN); \
+} while (0)
+#define VIDC_REG_518133_DEC_DPB_ADDR_BMSK     0xffffffff
+#define VIDC_REG_518133_DEC_DPB_ADDR_SHFT              0
+
+#define VIDC_REG_456376_ADDR_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000904)
+#define VIDC_REG_456376_ADDR_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000904)
+#define VIDC_REG_456376_ADDR_RMSK                 0xffffffff
+#define VIDC_REG_456376_ADDR_SHFT                          0
+#define VIDC_REG_456376_ADDR_IN                   \
+	in_dword_masked(VIDC_REG_456376_ADDR_ADDR,  \
+			VIDC_REG_456376_ADDR_RMSK)
+#define VIDC_REG_456376_ADDR_INM(m)               \
+	in_dword_masked(VIDC_REG_456376_ADDR_ADDR,  m)
+#define VIDC_REG_456376_ADDR_OUT(v)               \
+	out_dword(VIDC_REG_456376_ADDR_ADDR, v)
+#define VIDC_REG_456376_ADDR_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_456376_ADDR_ADDR, m, v, \
+			VIDC_REG_456376_ADDR_IN); \
+} while (0)
+#define VIDC_REG_456376_ADDR_DPB_COMV_ADDR_BMSK   0xffffffff
+#define VIDC_REG_456376_ADDR_DPB_COMV_ADDR_SHFT            0
+
+#define VIDC_REG_267567_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000908)
+#define VIDC_REG_267567_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000908)
+#define VIDC_REG_267567_RMSK                 0xffffffff
+#define VIDC_REG_267567_SHFT                          0
+#define VIDC_REG_267567_IN                   \
+	in_dword_masked(VIDC_REG_267567_ADDR,  \
+			VIDC_REG_267567_RMSK)
+#define VIDC_REG_267567_INM(m)               \
+	in_dword_masked(VIDC_REG_267567_ADDR,  m)
+#define VIDC_REG_267567_OUT(v)               \
+	out_dword(VIDC_REG_267567_ADDR, v)
+#define VIDC_REG_267567_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_267567_ADDR, m, v, \
+			VIDC_REG_267567_IN); \
+} while (0)
+#define VIDC_REG_798486_ADDR_BMSK   0xffffffff
+#define VIDC_REG_798486_ADDR_SHFT            0
+
+#define VIDC_REG_105770_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x0000090c)
+#define VIDC_REG_105770_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x0000090c)
+#define VIDC_REG_105770_RMSK                            0xff
+#define VIDC_REG_105770_SHFT                               0
+#define VIDC_REG_105770_IN                        \
+	in_dword_masked(VIDC_REG_105770_ADDR,         \
+	VIDC_REG_105770_RMSK)
+#define VIDC_REG_105770_INM(m)                    \
+	in_dword_masked(VIDC_REG_105770_ADDR,  m)
+#define VIDC_REG_105770_DPB_SIZE_BMSK                   0xff
+#define VIDC_REG_105770_DPB_SIZE_SHFT                      0
+
+#define VIDC_REG_58211_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a00)
+#define VIDC_REG_58211_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a00)
+#define VIDC_REG_58211_RMSK                      0x33f
+#define VIDC_REG_58211_SHFT                          0
+#define VIDC_REG_58211_IN                   \
+	in_dword_masked(VIDC_REG_58211_ADDR,  \
+			VIDC_REG_58211_RMSK)
+#define VIDC_REG_58211_INM(m)               \
+	in_dword_masked(VIDC_REG_58211_ADDR,  m)
+#define VIDC_REG_58211_OUT(v)               \
+	out_dword(VIDC_REG_58211_ADDR, v)
+#define VIDC_REG_58211_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_58211_ADDR, m, v, \
+			VIDC_REG_58211_IN); \
+} while (0)
+#define VIDC_REG_58211_FR_RC_EN_BMSK             0x200
+#define VIDC_REG_58211_FR_RC_EN_SHFT               0x9
+#define VIDC_REG_58211_MB_RC_EN_BMSK             0x100
+#define VIDC_REG_58211_MB_RC_EN_SHFT               0x8
+#define VIDC_REG_58211_FRAME_QP_BMSK              0x3f
+#define VIDC_REG_58211_FRAME_QP_SHFT                 0
+
+#define VIDC_REG_548359_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a04)
+#define VIDC_REG_548359_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a04)
+#define VIDC_REG_548359_RMSK                          0x3f
+#define VIDC_REG_548359_SHFT                             0
+#define VIDC_REG_548359_IN                      \
+	in_dword_masked(VIDC_REG_548359_ADDR,  \
+			VIDC_REG_548359_RMSK)
+#define VIDC_REG_548359_INM(m)                  \
+	in_dword_masked(VIDC_REG_548359_ADDR,  m)
+#define VIDC_REG_548359_OUT(v)                  \
+	out_dword(VIDC_REG_548359_ADDR, v)
+#define VIDC_REG_548359_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_548359_ADDR, m, v, \
+			VIDC_REG_548359_IN); \
+} while (0)
+#define VIDC_REG_548359_P_FRAME_QP_BMSK               0x3f
+#define VIDC_REG_548359_P_FRAME_QP_SHFT                  0
+
+#define VIDC_REG_174150_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a08)
+#define VIDC_REG_174150_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a08)
+#define VIDC_REG_174150_RMSK                   0xffffffff
+#define VIDC_REG_174150_SHFT                            0
+#define VIDC_REG_174150_IN                     \
+	in_dword_masked(VIDC_REG_174150_ADDR,  \
+			VIDC_REG_174150_RMSK)
+#define VIDC_REG_174150_INM(m)                 \
+	in_dword_masked(VIDC_REG_174150_ADDR,  m)
+#define VIDC_REG_174150_OUT(v)                 \
+	out_dword(VIDC_REG_174150_ADDR, v)
+#define VIDC_REG_174150_OUTM(m, v)              \
+do { \
+	out_dword_masked_ns(VIDC_REG_174150_ADDR, m, v, \
+			VIDC_REG_174150_IN); \
+} while (0)
+#define VIDC_REG_174150_BIT_RATE_BMSK          0xffffffff
+#define VIDC_REG_174150_BIT_RATE_SHFT                   0
+
+#define VIDC_REG_734318_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a0c)
+#define VIDC_REG_734318_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a0c)
+#define VIDC_REG_734318_RMSK                         0x3f3f
+#define VIDC_REG_734318_SHFT                              0
+#define VIDC_REG_734318_IN                       \
+	in_dword_masked(VIDC_REG_734318_ADDR,        \
+	VIDC_REG_734318_RMSK)
+#define VIDC_REG_734318_INM(m)                   \
+	in_dword_masked(VIDC_REG_734318_ADDR,  m)
+#define VIDC_REG_734318_OUT(v)                   \
+	out_dword(VIDC_REG_734318_ADDR, v)
+#define VIDC_REG_734318_OUTM(m, v)                \
+do { \
+	out_dword_masked_ns(VIDC_REG_734318_ADDR, m, v, \
+			VIDC_REG_734318_IN); \
+} while (0)
+#define VIDC_REG_734318_MAX_QP_BMSK                  0x3f00
+#define VIDC_REG_734318_MAX_QP_SHFT                     0x8
+#define VIDC_REG_734318_MIN_QP_BMSK                    0x3f
+#define VIDC_REG_734318_MIN_QP_SHFT                       0
+
+#define VIDC_REG_677784_ADDR                      \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a10)
+#define VIDC_REG_677784_PHYS                      \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a10)
+#define VIDC_REG_677784_RMSK                          0xffff
+#define VIDC_REG_677784_SHFT                               0
+#define VIDC_REG_677784_IN                        \
+	in_dword_masked(VIDC_REG_677784_ADDR,         \
+	VIDC_REG_677784_RMSK)
+#define VIDC_REG_677784_INM(m)                    \
+	in_dword_masked(VIDC_REG_677784_ADDR,  m)
+#define VIDC_REG_677784_OUT(v)                    \
+	out_dword(VIDC_REG_677784_ADDR, v)
+#define VIDC_REG_677784_OUTM(m, v)                 \
+do { \
+	out_dword_masked_ns(VIDC_REG_677784_ADDR, m, v, \
+			VIDC_REG_677784_IN); \
+} while (0)
+#define VIDC_REG_677784_REACT_PARA_BMSK               0xffff
+#define VIDC_REG_677784_REACT_PARA_SHFT                    0
+
+#define VIDC_REG_995041_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a14)
+#define VIDC_REG_995041_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a14)
+#define VIDC_REG_995041_RMSK                           0xf
+#define VIDC_REG_995041_SHFT                             0
+#define VIDC_REG_995041_IN                      \
+	in_dword_masked(VIDC_REG_995041_ADDR,  \
+			VIDC_REG_995041_RMSK)
+#define VIDC_REG_995041_INM(m)                  \
+	in_dword_masked(VIDC_REG_995041_ADDR,  m)
+#define VIDC_REG_995041_OUT(v)                  \
+	out_dword(VIDC_REG_995041_ADDR, v)
+#define VIDC_REG_995041_OUTM(m, v)               \
+do { \
+	out_dword_masked_ns(VIDC_REG_995041_ADDR, m, v, \
+			VIDC_REG_995041_IN); \
+} while (0)
+#define VIDC_REG_995041_DARK_DISABLE_BMSK              0x8
+#define VIDC_REG_995041_DARK_DISABLE_SHFT              0x3
+#define VIDC_REG_995041_SMOOTH_DISABLE_BMSK            0x4
+#define VIDC_REG_995041_SMOOTH_DISABLE_SHFT            0x2
+#define VIDC_REG_995041_STATIC_DISABLE_BMSK            0x2
+#define VIDC_REG_995041_STATIC_DISABLE_SHFT            0x1
+#define VIDC_REG_995041_ACT_DISABLE_BMSK               0x1
+#define VIDC_REG_995041_ACT_DISABLE_SHFT                 0
+
+#define VIDC_REG_273649_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000a18)
+#define VIDC_REG_273649_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000a18)
+#define VIDC_REG_273649_RMSK                             0x3f
+#define VIDC_REG_273649_SHFT                                0
+#define VIDC_REG_273649_IN                         \
+	in_dword_masked(VIDC_REG_273649_ADDR,  VIDC_REG_273649_RMSK)
+#define VIDC_REG_273649_INM(m)                     \
+	in_dword_masked(VIDC_REG_273649_ADDR,  m)
+#define VIDC_REG_273649_QP_OUT_BMSK                      0x3f
+#define VIDC_REG_273649_QP_OUT_SHFT                         0
+
+#define VIDC_REG_548823_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000b00)
+#define VIDC_REG_548823_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000b00)
+#define VIDC_REG_548823_RMSK                   0xffffffff
+#define VIDC_REG_548823_SHFT                            0
+#define VIDC_REG_548823_IN                     \
+	in_dword_masked(VIDC_REG_548823_ADDR,  \
+			VIDC_REG_548823_RMSK)
+#define VIDC_REG_548823_INM(m)                 \
+	in_dword_masked(VIDC_REG_548823_ADDR,  m)
+#define VIDC_REG_548823_720P_VERSION_BMSK       0xffffffff
+#define VIDC_REG_548823_720P_VERSION_SHFT                0
+
+#define VIDC_REG_881638_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000c00)
+#define VIDC_REG_881638_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c00)
+#define VIDC_REG_881638_RMSK                     0xffffffff
+#define VIDC_REG_881638_SHFT                              0
+#define VIDC_REG_881638_IN                       \
+	in_dword_masked(VIDC_REG_881638_ADDR,        \
+	VIDC_REG_881638_RMSK)
+#define VIDC_REG_881638_INM(m)                   \
+	in_dword_masked(VIDC_REG_881638_ADDR,  m)
+#define VIDC_REG_881638_CROP_RIGHT_OFFSET_BMSK   0xffff0000
+#define VIDC_REG_881638_CROP_RIGHT_OFFSET_SHFT         0x10
+#define VIDC_REG_881638_CROP_LEFT_OFFSET_BMSK        0xffff
+#define VIDC_REG_881638_CROP_LEFT_OFFSET_SHFT             0
+
+#define VIDC_REG_161486_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000c04)
+#define VIDC_REG_161486_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c04)
+#define VIDC_REG_161486_RMSK                     0xffffffff
+#define VIDC_REG_161486_SHFT                              0
+#define VIDC_REG_161486_IN                       \
+	in_dword_masked(VIDC_REG_161486_ADDR,        \
+	VIDC_REG_161486_RMSK)
+#define VIDC_REG_161486_INM(m)                   \
+	in_dword_masked(VIDC_REG_161486_ADDR,  m)
+#define VIDC_REG_161486_CROP_BOTTOM_OFFSET_BMSK  0xffff0000
+#define VIDC_REG_161486_CROP_BOTTOM_OFFSET_SHFT        0x10
+#define VIDC_REG_161486_CROP_TOP_OFFSET_BMSK         0xffff
+#define VIDC_REG_161486_CROP_TOP_OFFSET_SHFT              0
+
+#define VIDC_REG_580603_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000c08)
+#define VIDC_REG_580603_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c08)
+#define VIDC_REG_580603_RMSK              0xffffffff
+#define VIDC_REG_580603_SHFT                       0
+#define VIDC_REG_580603_IN                \
+	in_dword_masked(VIDC_REG_580603_ADDR,  \
+			VIDC_REG_580603_RMSK)
+#define VIDC_REG_580603_INM(m)            \
+	in_dword_masked(VIDC_REG_580603_ADDR,  m)
+#define VIDC_REG_580603_720P_DEC_FRM_SIZE_BMSK 0xffffffff
+#define VIDC_REG_580603_720P_DEC_FRM_SIZE_SHFT          0
+
+
+#define VIDC_REG_606447_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000c0c)
+#define VIDC_REG_606447_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c0c)
+#define VIDC_REG_606447_RMSK  0xff1f
+#define VIDC_REG_606447_SHFT  0
+#define VIDC_REG_606447_IN                         \
+		in_dword_masked(VIDC_REG_606447_ADDR, \
+		VIDC_REG_606447_RMSK)
+#define VIDC_REG_606447_INM(m)                     \
+		in_dword_masked(VIDC_REG_606447_ADDR, m)
+#define VIDC_REG_606447_OUT(v)                     \
+		out_dword(VIDC_REG_606447_ADDR, v)
+#define VIDC_REG_606447_OUTM(m, v)                  \
+		out_dword_masked_ns(VIDC_REG_606447_ADDR, \
+		m, v, VIDC_REG_606447_IN); \
+
+#define VIDC_REG_606447_DIS_PIC_LEVEL_BMSK 0xff00
+#define VIDC_REG_606447_DIS_PIC_LEVEL_SHFT 0x8
+#define VIDC_REG_606447_DISP_PIC_PROFILE_BMSK 0x1f
+#define VIDC_REG_606447_DISP_PIC_PROFILE_SHFT 0
+
+#define VIDC_REG_854281_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE      + 0x00000c10)
+#define VIDC_REG_854281_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c10)
+#define VIDC_REG_854281_RMSK 0xffffffff
+#define VIDC_REG_854281_SHFT 0
+#define VIDC_REG_854281_IN \
+		in_dword_masked(VIDC_REG_854281_ADDR, \
+		VIDC_REG_854281_RMSK)
+#define VIDC_REG_854281_INM(m) \
+		in_dword_masked(VIDC_REG_854281_ADDR, m)
+#define VIDC_REG_854281_MIN_DPB_SIZE_BMSK 0xffffffff
+#define VIDC_REG_854281_MIN_DPB_SIZE_SHFT 0
+
+
+#define VIDC_REG_381535_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000c14)
+#define VIDC_REG_381535_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c14)
+#define VIDC_REG_381535_RMSK 0xffffffff
+#define VIDC_REG_381535_SHFT 0
+#define VIDC_REG_381535_IN \
+		in_dword_masked(VIDC_REG_381535_ADDR, \
+		VIDC_REG_381535_RMSK)
+#define VIDC_REG_381535_INM(m) \
+		in_dword_masked(VIDC_REG_381535_ADDR, m)
+#define VIDC_REG_381535_720P_FW_STATUS_BMSK 0xffffffff
+#define VIDC_REG_381535_720P_FW_STATUS_SHFT 0
+
+
+#define VIDC_REG_347105_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000c18)
+#define VIDC_REG_347105_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000c18)
+#define VIDC_REG_347105_RMSK 0xffffffff
+#define VIDC_REG_347105_SHFT 0
+#define VIDC_REG_347105_IN \
+		in_dword_masked(VIDC_REG_347105_ADDR, \
+		VIDC_REG_347105_RMSK)
+#define VIDC_REG_347105_INM(m) \
+		in_dword_masked(VIDC_REG_347105_ADDR, m)
+#define VIDC_REG_347105_FREE_LUMA_DPB_BMSK 0xffffffff
+#define VIDC_REG_347105_FREE_LUMA_DPB_SHFT 0
+
+
+#define VIDC_REG_62325_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000d00)
+#define VIDC_REG_62325_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d00)
+#define VIDC_REG_62325_RMSK                     0xf
+#define VIDC_REG_62325_SHFT                       0
+#define VIDC_REG_62325_IN                \
+		in_dword_masked(VIDC_REG_62325_ADDR,  \
+		VIDC_REG_62325_RMSK)
+#define VIDC_REG_62325_INM(m)            \
+	in_dword_masked(VIDC_REG_62325_ADDR,  m)
+#define VIDC_REG_62325_OUT(v)            \
+	out_dword(VIDC_REG_62325_ADDR, v)
+#define VIDC_REG_62325_OUTM(m, v)         \
+do { \
+	out_dword_masked_ns(VIDC_REG_62325_ADDR, m, v, \
+			VIDC_REG_62325_IN); \
+} while (0)
+#define VIDC_REG_62325_COMMAND_TYPE_BMSK        0xf
+#define VIDC_REG_62325_COMMAND_TYPE_SHFT          0
+
+#define VIDC_REG_101184_ADDR  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000d04)
+#define VIDC_REG_101184_PHYS  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d04)
+#define VIDC_REG_101184_RMSK                0xffffffff
+#define VIDC_REG_101184_SHFT                0
+#define VIDC_REG_101184_OUT(v)                     \
+	out_dword(VIDC_REG_101184_ADDR, v)
+
+#define VIDC_REG_490443_ADDR  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000d08)
+#define VIDC_REG_490443_PHYS  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d08)
+#define VIDC_REG_490443_RMSK                       \
+	0xffffffff
+#define \
+	\
+VIDC_REG_490443_SHFT                                0
+#define VIDC_REG_490443_OUT(v)                     \
+	out_dword(VIDC_REG_490443_ADDR, v)
+
+#define VIDC_REG_625444_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000d14)
+#define VIDC_REG_625444_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d14)
+#define VIDC_REG_625444_RMSK                 0xffffffff
+#define VIDC_REG_625444_SHFT                          0
+#define VIDC_REG_625444_IN                   \
+	in_dword_masked(VIDC_REG_625444_ADDR,  \
+			VIDC_REG_625444_RMSK)
+#define VIDC_REG_625444_INM(m)               \
+	in_dword_masked(VIDC_REG_625444_ADDR,  m)
+#define VIDC_REG_625444_OUT(v)               \
+	out_dword(VIDC_REG_625444_ADDR, v)
+#define VIDC_REG_625444_OUTM(m, v)            \
+do { \
+	out_dword_masked_ns(VIDC_REG_625444_ADDR, m, v, \
+			VIDC_REG_625444_IN); \
+} while (0)
+#define VIDC_REG_625444_FRAME_RATE_BMSK      0xffffffff
+#define VIDC_REG_625444_FRAME_RATE_SHFT               0
+
+#define VIDC_REG_639999_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000d20)
+#define VIDC_REG_639999_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d20)
+#define VIDC_REG_639999_RMSK                    0xffff
+#define VIDC_REG_639999_SHFT                         0
+#define VIDC_REG_639999_OUT(v)                  \
+	out_dword(VIDC_REG_639999_ADDR, v)
+
+#define VIDC_REG_64895_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e00)
+#define VIDC_REG_64895_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e00)
+#define VIDC_REG_64895_RMSK                    0xffffffff
+#define VIDC_REG_64895_SHFT                             0
+#define VIDC_REG_64895_OUT(v)                  \
+	out_dword(VIDC_REG_64895_ADDR, v)
+
+#define VIDC_REG_965480_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000e04)
+#define VIDC_REG_965480_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e04)
+#define VIDC_REG_965480_RMSK 0x1
+#define VIDC_REG_965480_SHFT 0
+#define VIDC_REG_965480_OUT(v) \
+		out_dword(VIDC_REG_965480_ADDR, v)
+
+#define VIDC_REG_804959_ADDR              \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e08)
+#define VIDC_REG_804959_PHYS              \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e08)
+#define VIDC_REG_804959_RMSK                     0x7
+#define VIDC_REG_804959_SHFT                       0
+#define VIDC_REG_804959_OUT(v)            \
+	out_dword(VIDC_REG_804959_ADDR, v)
+
+#define VIDC_REG_257463_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e10)
+#define VIDC_REG_257463_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e10)
+#define VIDC_REG_257463_RMSK                   0xffffffff
+#define VIDC_REG_257463_SHFT                            0
+#define VIDC_REG_257463_IN                     \
+	in_dword_masked(VIDC_REG_257463_ADDR,  \
+			VIDC_REG_257463_RMSK)
+#define VIDC_REG_257463_INM(m)                 \
+	in_dword_masked(VIDC_REG_257463_ADDR,  m)
+#define VIDC_REG_257463_MIN_NUM_DPB_BMSK       0xffffffff
+#define VIDC_REG_257463_MIN_NUM_DPB_SHFT                0
+
+#define VIDC_REG_883500_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e14)
+#define VIDC_REG_883500_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e14)
+#define VIDC_REG_883500_RMSK                       0xffffffff
+#define VIDC_REG_883500_SHFT                                0
+#define VIDC_REG_883500_OUT(v)                     \
+	out_dword(VIDC_REG_883500_ADDR, v)
+
+#define VIDC_REG_615716_ADDR(n)               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e18 + 4 * (n))
+#define VIDC_REG_615716_PHYS(n)               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e18 + 4 * (n))
+#define VIDC_REG_615716_RMSK                  0xffffffff
+#define VIDC_REG_615716_SHFT                           0
+#define VIDC_REG_615716_OUTI(n, v) \
+	out_dword(VIDC_REG_615716_ADDR(n), v)
+
+#define VIDC_REG_603032_ADDR                \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e98)
+#define VIDC_REG_603032_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e98)
+#define VIDC_REG_603032_RMSK                0xffffffff
+#define VIDC_REG_603032_SHFT                         0
+#define VIDC_REG_603032_OUT(v)              \
+	out_dword(VIDC_REG_603032_ADDR, v)
+
+#define VIDC_REG_300310_ADDR                  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000e9c)
+#define VIDC_REG_300310_PHYS                  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000e9c)
+#define VIDC_REG_300310_RMSK                  0xffffffff
+#define VIDC_REG_300310_SHFT                           0
+#define VIDC_REG_300310_IN                    \
+	in_dword_masked(VIDC_REG_300310_ADDR,  \
+			VIDC_REG_300310_RMSK)
+#define VIDC_REG_300310_INM(m)                \
+	in_dword_masked(VIDC_REG_300310_ADDR,  m)
+#define VIDC_REG_300310_ERROR_STATUS_BMSK     0xffffffff
+#define VIDC_REG_300310_ERROR_STATUS_SHFT              0
+
+#define VIDC_REG_792026_ADDR        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ea0)
+#define VIDC_REG_792026_PHYS        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ea0)
+#define VIDC_REG_792026_RMSK        0xffffffff
+#define VIDC_REG_792026_SHFT                 0
+#define VIDC_REG_792026_OUT(v)      \
+	out_dword(VIDC_REG_792026_ADDR, v)
+
+#define VIDC_REG_844152_ADDR        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ea4)
+#define VIDC_REG_844152_PHYS        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ea4)
+#define VIDC_REG_844152_RMSK        0xffffffff
+#define VIDC_REG_844152_SHFT                 0
+#define VIDC_REG_844152_OUT(v)      \
+	out_dword(VIDC_REG_844152_ADDR, v)
+
+#define VIDC_REG_370409_ADDR            \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ea8)
+#define VIDC_REG_370409_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ea8)
+#define VIDC_REG_370409_RMSK                0xffffffff
+#define VIDC_REG_370409_SHFT                         0
+#define VIDC_REG_370409_IN                  \
+	in_dword_masked(VIDC_REG_370409_ADDR,  \
+			VIDC_REG_370409_RMSK)
+#define VIDC_REG_370409_INM(m)              \
+	in_dword_masked(VIDC_REG_370409_ADDR,  m)
+#define VIDC_REG_370409_GET_FRAME_TAG_TOP_BMSK 0xffffffff
+#define VIDC_REG_370409_GET_FRAME_TAG_TOP_SHFT          0
+
+#define VIDC_REG_147682_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000eac)
+#define VIDC_REG_147682_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000eac)
+#define VIDC_REG_147682_RMSK                        0x1
+#define VIDC_REG_147682_SHFT                        0
+#define VIDC_REG_147682_OUT(v)             \
+	out_dword(VIDC_REG_147682_ADDR, v)
+
+#define VIDC_REG_407718_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000eb0)
+#define VIDC_REG_407718_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000eb0)
+#define VIDC_REG_407718_RMSK                    0xffffffff
+#define VIDC_REG_407718_SHFT                             0
+#define VIDC_REG_407718_OUT(v)                  \
+	out_dword(VIDC_REG_407718_ADDR, v)
+
+#define VIDC_REG_697961_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000eb4)
+#define VIDC_REG_697961_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000eb4)
+#define VIDC_REG_697961_RMSK 0x3
+#define VIDC_REG_697961_SHFT 0
+#define VIDC_REG_697961_IN \
+		in_dword_masked(VIDC_REG_697961_ADDR, \
+		VIDC_REG_697961_RMSK)
+#define VIDC_REG_697961_INM(m) \
+		in_dword_masked(VIDC_REG_697961_ADDR, m)
+#define VIDC_REG_697961_FRAME_TYPE_BMSK 0x3
+#define VIDC_REG_697961_FRAME_TYPE_SHFT 0
+
+
+#define VIDC_REG_613254_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000eb8)
+#define VIDC_REG_613254_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000eb8)
+#define VIDC_REG_613254_RMSK                      0x1
+#define VIDC_REG_613254_SHFT                        0
+#define VIDC_REG_613254_IN                 \
+	in_dword_masked(VIDC_REG_613254_ADDR,  \
+			VIDC_REG_613254_RMSK)
+#define VIDC_REG_613254_INM(m)             \
+	in_dword_masked(VIDC_REG_613254_ADDR,  m)
+#define VIDC_REG_613254_METADATA_STATUS_BMSK        0x1
+#define VIDC_REG_613254_METADATA_STATUS_SHFT          0
+#define VIDC_REG_441270_ADDR                    \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ebc)
+#define VIDC_REG_441270_PHYS                    \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ebc)
+#define VIDC_REG_441270_RMSK                          0x1f
+#define VIDC_REG_441270_SHFT                             0
+#define VIDC_REG_441270_IN                      \
+	in_dword_masked(VIDC_REG_441270_ADDR,  \
+			VIDC_REG_441270_RMSK)
+#define VIDC_REG_441270_INM(m)                  \
+	in_dword_masked(VIDC_REG_441270_ADDR,  m)
+#define VIDC_REG_441270_DATA_PARTITIONED_BMSK 0x8
+#define VIDC_REG_441270_DATA_PARTITIONED_SHFT 0x3
+
+#define VIDC_REG_441270_FRAME_TYPE_BMSK               0x17
+#define VIDC_REG_441270_FRAME_TYPE_SHFT                  0
+
+#define VIDC_REG_724381_ADDR        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ec0)
+#define VIDC_REG_724381_PHYS        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ec0)
+#define VIDC_REG_724381_RMSK               0x3
+#define VIDC_REG_724381_SHFT                 0
+#define VIDC_REG_724381_IN          \
+	in_dword_masked(VIDC_REG_724381_ADDR,  \
+			VIDC_REG_724381_RMSK)
+#define VIDC_REG_724381_INM(m)      \
+	in_dword_masked(VIDC_REG_724381_ADDR,  m)
+#define VIDC_REG_724381_MORE_FIELD_NEEDED_BMSK       0x4
+#define VIDC_REG_724381_MORE_FIELD_NEEDED_SHFT       0x2
+#define VIDC_REG_724381_OPERATION_FAILED_BMSK        0x2
+#define VIDC_REG_724381_OPERATION_FAILED_SHFT        0x1
+#define VIDC_REG_724381_RESOLUTION_CHANGE_BMSK       0x1
+#define VIDC_REG_724381_RESOLUTION_CHANGE_SHFT         0
+
+#define VIDC_REG_854681_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ec4)
+#define VIDC_REG_854681_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ec4)
+#define VIDC_REG_854681_RMSK                     0x7f
+#define VIDC_REG_854681_SHFT                        0
+#define VIDC_REG_854681_OUT(v)             \
+	out_dword(VIDC_REG_854681_ADDR, v)
+
+#define VIDC_REG_128234_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ec8)
+#define VIDC_REG_128234_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ec8)
+#define VIDC_REG_128234_RMSK               0xffff000f
+#define VIDC_REG_128234_SHFT                        0
+#define VIDC_REG_128234_OUT(v)             \
+	out_dword(VIDC_REG_128234_ADDR, v)
+
+#define VIDC_REG_1137_ADDR        \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ecc)
+#define VIDC_REG_1137_PHYS        \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ecc)
+#define VIDC_REG_1137_RMSK        0xffffffff
+#define VIDC_REG_1137_SHFT                 0
+#define VIDC_REG_1137_IN          \
+	in_dword_masked(VIDC_REG_1137_ADDR,  \
+			VIDC_REG_1137_RMSK)
+#define VIDC_REG_1137_INM(m)      \
+	in_dword_masked(VIDC_REG_1137_ADDR,  m)
+#define VIDC_REG_1137_METADATA_DISPLAY_INDEX_BMSK \
+	0xffffffff
+#define \
+	\
+VIDC_REG_1137_METADATA_DISPLAY_INDEX_SHFT          0
+
+#define VIDC_REG_988552_ADDR       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ed0)
+#define VIDC_REG_988552_PHYS       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ed0)
+#define VIDC_REG_988552_RMSK       0xffffffff
+#define VIDC_REG_988552_SHFT                0
+#define VIDC_REG_988552_OUT(v)     \
+	out_dword(VIDC_REG_988552_ADDR, v)
+
+#define VIDC_REG_319934_ADDR  \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ed4)
+#define VIDC_REG_319934_PHYS  \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ed4)
+#define VIDC_REG_319934_RMSK                       0xffffffff
+#define VIDC_REG_319934_SHFT                   0
+#define VIDC_REG_319934_OUT(v)                     \
+	out_dword(VIDC_REG_319934_ADDR, v)
+
+#define VIDC_REG_679165_ADDR                   \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ed8)
+#define VIDC_REG_679165_PHYS                   \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ed8)
+#define VIDC_REG_679165_RMSK                   0xffffffff
+#define VIDC_REG_679165_SHFT                            0
+#define VIDC_REG_679165_IN                     \
+	in_dword_masked(VIDC_REG_679165_ADDR,  \
+			VIDC_REG_679165_RMSK)
+#define VIDC_REG_679165_INM(m)                 \
+	in_dword_masked(VIDC_REG_679165_ADDR,  m)
+#define VIDC_REG_679165_PIC_TIME_TOP_BMSK       0xffffffff
+#define VIDC_REG_679165_PIC_TIME_TOP_SHFT                0
+
+#define VIDC_REG_374150_ADDR                     \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000edc)
+#define VIDC_REG_374150_PHYS                     \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000edc)
+#define VIDC_REG_374150_RMSK                     0xffffffff
+#define VIDC_REG_374150_SHFT                              0
+#define VIDC_REG_374150_IN                       \
+	in_dword_masked(VIDC_REG_374150_ADDR,  \
+			VIDC_REG_374150_RMSK)
+#define VIDC_REG_374150_INM(m)                   \
+	in_dword_masked(VIDC_REG_374150_ADDR,  m)
+#define VIDC_REG_374150_PIC_TIME_BOTTOM_BMSK           0xffffffff
+#define VIDC_REG_374150_PIC_TIME_BOTTOM_SHFT                    0
+
+#define VIDC_REG_94750_ADDR                 \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ee0)
+#define VIDC_REG_94750_PHYS                 \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ee0)
+#define VIDC_REG_94750_RMSK                 0xffffffff
+#define VIDC_REG_94750_SHFT                          0
+#define VIDC_REG_94750_OUT(v)               \
+	out_dword(VIDC_REG_94750_ADDR, v)
+
+#define VIDC_REG_438677_ADDR          \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ee4)
+#define VIDC_REG_438677_PHYS                \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ee4)
+#define VIDC_REG_438677_RMSK                0xffffffff
+#define VIDC_REG_438677_SHFT                         0
+#define VIDC_REG_438677_IN                  \
+	in_dword_masked(VIDC_REG_438677_ADDR,  \
+			VIDC_REG_438677_RMSK)
+#define VIDC_REG_438677_INM(m)              \
+	in_dword_masked(VIDC_REG_438677_ADDR,  m)
+#define VIDC_REG_438677_GET_FRAME_TAG_BOTTOM_BMSK 0xffffffff
+#define VIDC_REG_438677_GET_FRAME_TAG_BOTTOM_SHFT          0
+
+#define VIDC_REG_76706_ADDR               \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00000ee8)
+#define VIDC_REG_76706_PHYS               \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000ee8)
+#define VIDC_REG_76706_RMSK                      0x1
+#define VIDC_REG_76706_SHFT                        0
+#define VIDC_REG_76706_OUT(v)             \
+	out_dword(VIDC_REG_76706_ADDR, v)
+
+#define VIDC_REG_809984_ADDR                       \
+	(VIDC_720P_WRAPPER_REG_BASE      + 0x00001000)
+#define VIDC_REG_809984_PHYS                       \
+	(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00001000)
+#define VIDC_REG_809984_RMSK                       0xffff0007
+#define VIDC_REG_809984_SHFT                                0
+#define VIDC_REG_809984_IN                         \
+	in_dword_masked(VIDC_REG_809984_ADDR,  VIDC_REG_809984_RMSK)
+#define VIDC_REG_809984_INM(m)                     \
+	in_dword_masked(VIDC_REG_809984_ADDR,  m)
+#define VIDC_REG_809984_720PV_720P_WRAPPER_VERSION_BMSK 0xffff0000
+#define VIDC_REG_809984_720PV_720P_WRAPPER_VERSION_SHFT       0x10
+#define VIDC_REG_809984_TEST_MUX_SEL_BMSK                 0x7
+#define VIDC_REG_809984_TEST_MUX_SEL_SHFT                   0
+
+
+#define VIDC_REG_699747_ADDR \
+       (VIDC_720P_WRAPPER_REG_BASE + 0x00000d0c)
+#define VIDC_REG_699747_PHYS \
+       (VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d0c)
+#define VIDC_REG_699747_RMSK 0xffffffff
+#define VIDC_REG_699747_SHFT 0
+#define VIDC_REG_699747_OUT(v)                  \
+		out_dword(VIDC_REG_699747_ADDR, v)
+
+#define VIDC_REG_166247_ADDR \
+       (VIDC_720P_WRAPPER_REG_BASE + 0x00000d10)
+#define VIDC_REG_166247_PHYS \
+       (VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d10)
+#define VIDC_REG_166247_RMSK 0xffffffff
+#define VIDC_REG_166247_SHFT 0
+#define VIDC_REG_166247_OUT(v)               \
+		out_dword(VIDC_REG_166247_ADDR, v)
+
+#define VIDC_REG_486169_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000d18)
+#define VIDC_REG_486169_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d18)
+#define VIDC_REG_486169_RMSK 0xffffffff
+#define VIDC_REG_486169_SHFT 0
+#define VIDC_REG_486169_OUT(v) \
+		out_dword(VIDC_REG_486169_ADDR, v)
+
+#define VIDC_REG_926519_ADDR \
+		(VIDC_720P_WRAPPER_REG_BASE + 0x00000d1c)
+#define VIDC_REG_926519_PHYS \
+		(VIDC_720P_WRAPPER_REG_BASE_PHYS + 0x00000d1c)
+#define VIDC_REG_926519_RMSK 0xffffffff
+#define VIDC_REG_926519_SHFT 0
+#define VIDC_REG_926519_OUT(v) \
+		out_dword(VIDC_REG_926519_ADDR, v)
+
+/** List all the levels and their register valus */
+
+#define VIDC_720P_PROFILE_MPEG4_SP      0
+#define VIDC_720P_PROFILE_MPEG4_ASP     1
+#define VIDC_720P_PROFILE_H264_BASELINE 0
+#define VIDC_720P_PROFILE_H264_MAIN     1
+#define VIDC_720P_PROFILE_H264_HIGH     2
+#define VIDC_720P_PROFILE_H264_CPB      3
+#define VIDC_720P_PROFILE_H263_BASELINE 0
+
+#define VIDC_720P_PROFILE_VC1_SP        0
+#define VIDC_720P_PROFILE_VC1_MAIN      1
+#define VIDC_720P_PROFILE_VC1_ADV       2
+#define VIDC_720P_PROFILE_MPEG2_MAIN    4
+#define VIDC_720P_PROFILE_MPEG2_SP      5
+
+#define VIDC_720P_MPEG4_LEVEL0  0
+#define VIDC_720P_MPEG4_LEVEL0b 9
+#define VIDC_720P_MPEG4_LEVEL1  1
+#define VIDC_720P_MPEG4_LEVEL2  2
+#define VIDC_720P_MPEG4_LEVEL3  3
+#define VIDC_720P_MPEG4_LEVEL3b 7
+#define VIDC_720P_MPEG4_LEVEL4a 4
+#define VIDC_720P_MPEG4_LEVEL5  5
+#define VIDC_720P_MPEG4_LEVEL6  6
+
+#define VIDC_720P_H264_LEVEL1     10
+#define VIDC_720P_H264_LEVEL1b    9
+#define VIDC_720P_H264_LEVEL1p1   11
+#define VIDC_720P_H264_LEVEL1p2   12
+#define VIDC_720P_H264_LEVEL1p3   13
+#define VIDC_720P_H264_LEVEL2     20
+#define VIDC_720P_H264_LEVEL2p1   21
+#define VIDC_720P_H264_LEVEL2p2   22
+#define VIDC_720P_H264_LEVEL3     30
+#define VIDC_720P_H264_LEVEL3p1   31
+#define VIDC_720P_H264_LEVEL3p2   32
+
+#define VIDC_720P_H263_LEVEL10    10
+#define VIDC_720P_H263_LEVEL20    20
+#define VIDC_720P_H263_LEVEL30    30
+#define VIDC_720P_H263_LEVEL40    40
+#define VIDC_720P_H263_LEVEL45    45
+#define VIDC_720P_H263_LEVEL50    50
+#define VIDC_720P_H263_LEVEL60    60
+#define VIDC_720P_H263_LEVEL70    70
+
+#define VIDC_720P_VC1_LEVEL_LOW    0
+#define VIDC_720P_VC1_LEVEL_MED    2
+#define VIDC_720P_VC1_LEVEL_HIGH   4
+#define VIDC_720P_VC1_LEVEL0       0
+#define VIDC_720P_VC1_LEVEL1       1
+#define VIDC_720P_VC1_LEVEL2       2
+#define VIDC_720P_VC1_LEVEL3       3
+#define VIDC_720P_VC1_LEVEL4       4
+
+#define VIDCL_720P_MPEG2_LEVEL_LOW 10
+#define VIDCL_720P_MPEG2_LEVEL_MAIN 8
+#define VIDCL_720P_MPEG2_LEVEL_HIGH14 6
+
+#define VIDC_720P_CMD_CHSET               0x0
+#define VIDC_720P_CMD_CHEND               0x2
+#define VIDC_720P_CMD_INITCODEC           0x3
+#define VIDC_720P_CMD_FRAMERUN            0x4
+#define VIDC_720P_CMD_INITBUFFERS         0x5
+#define VIDC_720P_CMD_FRAMERUN_REALLOCATE 0x6
+#define VIDC_720P_CMD_MFC_ENGINE_RESET 0x7
+
+enum vidc_720p_endian {
+	VIDC_720P_BIG_ENDIAN = 0x0,
+	VIDC_720P_LITTLE_ENDIAN = 0x1
+};
+
+enum vidc_720p_memory_access_method {
+	VIDC_720P_TILE_LINEAR = 0,
+	VIDC_720P_TILE_16x16 = 2,
+	VIDC_720P_TILE_64x32 = 3
+};
+
+enum vidc_720p_interrupt_control_mode {
+	VIDC_720P_INTERRUPT_MODE = 0,
+	VIDC_720P_POLL_MODE = 1
+};
+
+enum vidc_720p_interrupt_level_selection {
+	VIDC_720P_INTERRUPT_LEVEL_SEL = 0,
+	VIDC_720P_INTERRUPT_PULSE_SEL = 1
+};
+
+#define VIDC_720P_INTR_BUFFER_FULL             0x002
+#define VIDC_720P_INTR_FW_DONE                 0x020
+#define VIDC_720P_INTR_HEADER_DONE             0x040
+#define VIDC_720P_INTR_DMA_DONE                0x080
+#define VIDC_720P_INTR_FRAME_DONE              0x100
+
+enum vidc_720p_enc_dec_selection {
+	VIDC_720P_DECODER = 0,
+	VIDC_720P_ENCODER = 1
+};
+
+enum vidc_720p_codec {
+	VIDC_720P_MPEG4 = 0,
+	VIDC_720P_H264 = 1,
+	VIDC_720P_DIVX = 2,
+	VIDC_720P_XVID = 3,
+	VIDC_720P_H263 = 4,
+	VIDC_720P_MPEG2 = 5,
+	VIDC_720P_VC1 = 6
+};
+
+enum vidc_720p_frame {
+	VIDC_720P_NOTCODED = 0,
+	VIDC_720P_IFRAME = 1,
+	VIDC_720P_PFRAME = 2,
+	VIDC_720P_BFRAME = 3,
+	VIDC_720P_IDRFRAME = 4
+};
+
+enum vidc_720p_entropy_sel {
+	VIDC_720P_ENTROPY_SEL_CAVLC = 0,
+	VIDC_720P_ENTROPY_SEL_CABAC = 1
+};
+
+enum vidc_720p_cabac_model {
+	VIDC_720P_CABAC_MODEL_NUMBER_0 = 0,
+	VIDC_720P_CABAC_MODEL_NUMBER_1 = 1,
+	VIDC_720P_CABAC_MODEL_NUMBER_2 = 2
+};
+
+enum vidc_720p_DBConfig {
+	VIDC_720P_DB_ALL_BLOCKING_BOUNDARY = 0,
+	VIDC_720P_DB_DISABLE = 1,
+	VIDC_720P_DB_SKIP_SLICE_BOUNDARY = 2
+};
+
+enum vidc_720p_MSlice_selection {
+	VIDC_720P_MSLICE_BY_MB_COUNT = 0,
+	VIDC_720P_MSLICE_BY_BYTE_COUNT = 1,
+	VIDC_720P_MSLICE_BY_GOB = 2,
+	VIDC_720P_MSLICE_OFF = 3
+};
+
+enum vidc_720p_display_status {
+	VIDC_720P_DECODE_ONLY = 0,
+	VIDC_720P_DECODE_AND_DISPLAY = 1,
+	VIDC_720P_DISPLAY_ONLY = 2,
+	VIDC_720P_EMPTY_BUFFER = 3
+};
+
+#define VIDC_720P_ENC_IFRAME_REQ       0x1
+#define VIDC_720P_ENC_IPERIOD_CHANGE   0x1
+#define VIDC_720P_ENC_FRAMERATE_CHANGE 0x2
+#define VIDC_720P_ENC_BITRATE_CHANGE   0x4
+
+#define VIDC_720P_FLUSH_REQ     0x1
+#define VIDC_720P_EXTRADATA     0x2
+
+#define VIDC_720P_METADATA_ENABLE_QP           0x01
+#define VIDC_720P_METADATA_ENABLE_CONCEALMB    0x02
+#define VIDC_720P_METADATA_ENABLE_VC1          0x04
+#define VIDC_720P_METADATA_ENABLE_SEI          0x08
+#define VIDC_720P_METADATA_ENABLE_VUI          0x10
+#define VIDC_720P_METADATA_ENABLE_ENCSLICE     0x20
+#define VIDC_720P_METADATA_ENABLE_PASSTHROUGH  0x40
+
+struct vidc_720p_dec_disp_info {
+	enum vidc_720p_display_status disp_status;
+	u32 resl_change;
+	u32 reconfig_flush_done;
+	u32 img_size_x;
+	u32 img_size_y;
+	u32 y_addr;
+	u32 c_addr;
+	u32 tag_top;
+	u32 pic_time_top;
+	u32 disp_is_interlace;
+	u32 tag_bottom;
+	u32 pic_time_bottom;
+	u32 metadata_exists;
+	u32 crop_exists;
+	u32 crop_right_offset;
+	u32 crop_left_offset;
+	u32 crop_bottom_offset;
+	u32 crop_top_offset;
+	u32 input_frame;
+	u32 input_bytes_consumed;
+	u32 input_is_interlace;
+	u32 input_frame_num;
+};
+
+struct vidc_720p_seq_hdr_info {
+	u32 img_size_x;
+	u32 img_size_y;
+	u32 dec_frm_size;
+	u32 min_num_dpb;
+	u32 min_dpb_size;
+	u32 profile;
+	u32 level;
+	u32 progressive;
+	u32 data_partitioned;
+	u32  crop_exists;
+	u32  crop_right_offset;
+	u32  crop_left_offset;
+	u32  crop_bottom_offset;
+	u32  crop_top_offset;
+};
+
+struct vidc_720p_enc_frame_info {
+	u32 enc_size;
+	u32 frame;
+	u32 metadata_exists;
+};
+
+void vidc_720p_set_device_virtual_base(u8 *core_virtual_base_addr);
+
+void vidc_720p_init(char **ppsz_version, u32 i_firmware_size,
+	u32 *pi_firmware_address, enum vidc_720p_endian dma_endian,
+	u32 interrupt_off,
+	enum vidc_720p_interrupt_level_selection	interrupt_sel,
+	u32 interrupt_mask);
+
+u32 vidc_720p_do_sw_reset(void);
+
+u32 vidc_720p_reset_is_success(void);
+
+void vidc_720p_start_cpu(enum vidc_720p_endian dma_endian,
+		u32 *icontext_bufferstart, u32 *debug_core_dump_addr,
+		u32  debug_buffer_size);
+
+u32 vidc_720p_cpu_start(void);
+
+void vidc_720p_stop_fw(void);
+
+void vidc_720p_get_interrupt_status(u32 *interrupt_status,
+		u32 *cmd_err_status, u32 *disp_pic_err_status,
+		u32 *op_failed);
+
+void vidc_720p_interrupt_done_clear(void);
+
+void vidc_720p_submit_command(u32 ch_id, u32 cmd_id);
+
+
+void vidc_720p_set_channel(u32 i_ch_id,
+	enum vidc_720p_enc_dec_selection enc_dec_sel,
+	enum vidc_720p_codec codec, u32 *pi_fw, u32 i_firmware_size);
+
+u32 vidc_720p_engine_reset(u32 ch_id,
+   enum vidc_720p_endian dma_endian,
+   enum vidc_720p_interrupt_level_selection interrupt_sel,
+   u32 interrupt_mask
+);
+
+void vidc_720p_encode_set_profile(u32 i_profile, u32 i_level);
+
+void vidc_720p_set_frame_size(u32 i_size_x, u32 i_size_y);
+
+void vidc_720p_encode_set_fps(u32 i_rc_frame_rate);
+
+void vidc_720p_encode_set_vop_time(u32 vop_time_resolution,
+		u32 vop_time_increment);
+
+void vidc_720p_encode_set_hec_period(u32 hec_period);
+
+void vidc_720p_encode_set_short_header(u32 i_short_header);
+
+void vidc_720p_encode_set_qp_params(u32 i_max_qp, u32 i_min_qp);
+
+void vidc_720p_encode_set_rc_config(u32 enable_frame_level_rc,
+		u32 enable_mb_level_rc_flag, u32 i_frame_qp, u32 pframe_qp);
+
+void vidc_720p_encode_set_bit_rate(u32 i_target_bitrate);
+
+void vidc_720p_encoder_set_param_change(u32 enc_param_change);
+
+void vidc_720p_encode_set_control_param(u32 param_val);
+
+void vidc_720p_encode_set_frame_level_rc_params(u32 i_reaction_coeff);
+
+void vidc_720p_encode_set_mb_level_rc_params(u32 dark_region_as_flag,
+	u32 smooth_region_as_flag, u32 static_region_as_flag,
+	u32 activity_region_flag);
+
+void vidc_720p_encode_set_entropy_control(enum vidc_720p_entropy_sel \
+		entropy_sel,
+		enum vidc_720p_cabac_model cabac_model_number);
+
+void vidc_720p_encode_set_db_filter_control(enum vidc_720p_DBConfig
+		db_config, u32 i_slice_alpha_offset, u32 i_slice_beta_offset);
+
+void vidc_720p_encode_set_intra_refresh_mb_number(u32 i_cir_mb_number);
+
+void vidc_720p_encode_set_multi_slice_info(
+		enum vidc_720p_MSlice_selection m_slice_sel,
+		u32 multi_slice_size);
+
+void vidc_720p_encode_set_dpb_buffer(u32 *pi_enc_dpb_addr, u32 alloc_len);
+
+void vidc_720p_set_deblock_line_buffer(u32 *pi_deblock_line_buffer_start,
+		u32 alloc_len);
+
+void vidc_720p_encode_set_i_period(u32 i_i_period);
+
+void vidc_720p_encode_init_codec(u32 i_ch_id,
+	enum vidc_720p_memory_access_method memory_access_model);
+
+void vidc_720p_encode_unalign_bitstream(u32 upper_unalign_word,
+	u32 lower_unalign_word);
+
+void vidc_720p_encode_set_seq_header_buffer(u32 ext_buffer_start,
+	u32 ext_buffer_end, u32 start_byte_num);
+
+void vidc_720p_encode_frame(u32 ch_id, u32 ext_buffer_start,
+	u32 ext_buffer_end, u32 start_byte_number,
+	u32 y_addr, u32 c_addr);
+
+void vidc_720p_encode_get_header(u32 *pi_enc_header_size);
+
+void vidc_720p_enc_frame_info
+	(struct vidc_720p_enc_frame_info *enc_frame_info);
+
+void vidc_720p_decode_bitstream_header(u32 ch_id, u32 dec_unit_size,
+	u32 start_byte_num, u32 ext_buffer_start, u32 ext_buffer_end,
+	enum vidc_720p_memory_access_method memory_access_model,
+	u32 decode_order);
+
+void vidc_720p_decode_get_seq_hdr_info
+    (struct vidc_720p_seq_hdr_info *seq_hdr_info);
+
+void vidc_720p_decode_set_dpb_release_buffer_mask
+    (u32 i_dpb_release_buffer_mask);
+
+void vidc_720p_decode_set_dpb_buffers(u32 i_buf_index, u32 *pi_dpb_buffer);
+
+void vidc_720p_decode_set_comv_buffer
+    (u32 *pi_dpb_comv_buffer, u32 alloc_len);
+
+void vidc_720p_decode_set_dpb_details
+    (u32 num_dpb, u32 alloc_len, u32 *ref_buffer);
+
+void vidc_720p_decode_set_mpeg4Post_filter(u32 enable_post_filter);
+
+void vidc_720p_decode_set_error_control(u32 enable_error_control);
+
+void vidc_720p_decode_set_mpeg4_data_partitionbuffer(u32 *vsp_buf_start);
+
+void vidc_720p_decode_setH264VSPBuffer(u32 *pi_vsp_temp_buffer_start);
+
+void vidc_720p_decode_frame(u32 ch_id, u32 ext_buffer_start,
+		u32 ext_buffer_end, u32 dec_unit_size,
+		u32 start_byte_num, u32 input_frame_tag);
+
+void vidc_720p_issue_eos(u32 i_ch_id);
+void vidc_720p_eos_info(u32 *disp_status, u32 *resl_change);
+
+void vidc_720p_decode_display_info
+    (struct vidc_720p_dec_disp_info *disp_info);
+
+void vidc_720p_decode_skip_frm_details(u32 *free_luma_dpb);
+
+void vidc_720p_metadata_enable(u32 flag, u32 *input_buffer);
+
+void vidc_720p_decode_dynamic_req_reset(void);
+
+void vidc_720p_decode_dynamic_req_set(u32 property);
+
+void vidc_720p_decode_setpassthrough_start(u32 pass_startaddr);
+
+
+
+#define DDL_720P_REG_BASE VIDC_720P_WRAPPER_REG_BASE
+#define VIDC_BUSY_WAIT(n) udelay(n)
+
+#undef VIDC_REGISTER_LOG_MSG
+#undef VIDC_REGISTER_LOG_INTO_BUFFER
+
+#ifdef VIDC_REGISTER_LOG_MSG
+#define VIDC_MSG1(msg_format, a) printk(KERN_INFO msg_format, a)
+#define VIDC_MSG2(msg_format, a, b) printk(KERN_INFO msg_format, a, b)
+#define VIDC_MSG3(msg_format, a, b, c) printk(KERN_INFO msg_format, a, b, c)
+#else
+#define VIDC_MSG1(msg_format, a)
+#define VIDC_MSG2(msg_format, a, b)
+#define VIDC_MSG3(msg_format, a, b, c)
+#endif
+
+#ifdef VIDC_REGISTER_LOG_INTO_BUFFER
+
+#define VIDC_REGLOG_BUFSIZE 200000
+#define VIDC_REGLOG_MAX_PRINT_SIZE 100
+extern char vidclog[VIDC_REGLOG_BUFSIZE];
+extern unsigned int vidclog_index;
+
+#define VIDC_LOG_BUFFER_INIT \
+{if (vidclog_index) \
+  memset(vidclog, 0, vidclog_index+1); \
+  vidclog_index = 0; }
+
+#define VIDC_REGLOG_CHECK_BUFINDEX(req_size) \
+  vidclog_index = \
+  (vidclog_index+(req_size) < VIDC_REGLOG_BUFSIZE) ? vidclog_index : 0;
+
+#define VIDC_LOG_WRITE(reg, val) \
+{unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"(0x%x:"#reg"=0x%x)" , VIDC_##reg##_ADDR - DDL_720P_REG_BASE, val);\
+	vidclog_index += len; }
+
+#define VIDC_LOG_WRITEI(reg, index, val) \
+{unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"(0x%x:"#reg"=0x%x)" , VIDC_##reg##_ADDR(index)-DDL_720P_REG_BASE,  \
+	val); vidclog_index += len; }
+
+#define VIDC_LOG_WRITEF(reg, field, val) \
+{unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"(0x%x:"#reg":0x%x:=0x%x)" , VIDC_##reg##_ADDR - DDL_720P_REG_BASE,  \
+	VIDC_##reg##_##field##_BMSK,  val);\
+	vidclog_index += len; }
+
+#define VIDC_LOG_READ(reg, pval) \
+{ unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"(0x%x:"#reg"==0x%x)" , VIDC_##reg##_ADDR - DDL_720P_REG_BASE,  \
+	(u32)*pval); \
+	vidclog_index += len; }
+
+#define VIDC_STR_LOGBUFFER(str) \
+{ unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"<%s>" , str); vidclog_index += len; }
+
+#define VIDC_LONG_LOGBUFFER(str, arg1) \
+{ unsigned int len; \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], VIDC_REGLOG_MAX_PRINT_SIZE, \
+	"<%s=0x%x>" , str, arg1); vidclog_index += len; }
+
+#define VIDC_DEBUG_REGISTER_LOG \
+{ u32 val; unsigned int len; \
+	val = VIDC_720P_IN(REG_881638); \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], 50,  "[dbg1=%x]" , val); \
+	vidclog_index += len; \
+	val = VIDC_720P_IN(REG_161486); \
+	VIDC_REGLOG_CHECK_BUFINDEX(VIDC_REGLOG_MAX_PRINT_SIZE); \
+	len = snprintf(&vidclog[vidclog_index], 50,  "[dbg2=%x]" , val); \
+	vidclog_index += len; }
+
+#else
+#define VIDC_LOG_WRITE(reg, val)
+#define VIDC_LOG_WRITEI(reg, index, val)
+#define VIDC_LOG_WRITEF(reg, field, val)
+#define VIDC_LOG_READ(reg, pval)
+#define VIDC_LOG_BUFFER_INIT
+#define VIDC_STR_LOGBUFFER(str)
+#define VIDC_LONG_LOGBUFFER(str, arg1)
+#define VIDC_DEBUG_REGISTER_LOG
+#endif
+
+void vidcputlog(char *str);
+void vidcput_debug_reglog(void);
+
+#define VIDC_LOGERR_STRING(str) \
+do { \
+	VIDC_STR_LOGBUFFER(str); \
+	VIDC_MSG1("\n<%s>", str); \
+} while (0)
+
+#define VIDC_LOG_STRING(str) \
+do { \
+	VIDC_STR_LOGBUFFER(str); \
+	VIDC_MSG1("\n<%s>", str); \
+} while (0)
+
+#define VIDC_LOG1(str, arg1) \
+do { \
+	VIDC_LONG_LOGBUFFER(str, arg1); \
+	VIDC_MSG2("\n<%s=0x%08x>", str, arg1); \
+} while (0)
+
+#define VIDC_IO_OUT(reg,  val) \
+do { \
+	VIDC_LOG_WRITE(reg, (u32)val);  \
+	VIDC_MSG2("\n(0x%08x:"#reg"=0x%08x)",  \
+	(u32)(VIDC_##reg##_ADDR - DDL_720P_REG_BASE),  (u32)val); \
+	mb(); \
+	VIDC_720P_OUT(reg, val);  \
+} while (0)
+
+#define VIDC_IO_OUTI(reg,  index,  val) \
+do { \
+	VIDC_LOG_WRITEI(reg, index, (u32)val); \
+	VIDC_MSG2("\n(0x%08x:"#reg"=0x%08x)",  \
+	(u32)(VIDC_##reg##_ADDR(index)-DDL_720P_REG_BASE),  (u32)val); \
+	mb(); \
+	VIDC_720P_OUTI(reg, index, val);  \
+} while (0)
+
+#define VIDC_IO_OUTF(reg,  field,  val) \
+do { \
+	VIDC_LOG_WRITEF(reg, field, val); \
+	VIDC_MSG3("\n(0x%08x:"#reg":0x%x:=0x%08x)",  \
+	(u32)(VIDC_##reg##_ADDR - DDL_720P_REG_BASE),  \
+	VIDC_##reg##_##field##_BMSK,  (u32)val); \
+	mb(); \
+	VIDC_720P_OUTF(reg, field, val);  \
+} while (0)
+
+#define VIDC_IO_IN(reg, pval) \
+do { \
+	mb(); \
+	*pval = (u32) VIDC_720P_IN(reg); \
+	VIDC_LOG_READ(reg, pval); \
+	VIDC_MSG2("\n(0x%08x:"#reg"==0x%08x)",  \
+	(u32)(VIDC_##reg##_ADDR - DDL_720P_REG_BASE), (u32) *pval);  \
+} while (0)
+
+#define VIDC_IO_INF(reg, mask, pval) \
+do { \
+	mb(); \
+	*pval = VIDC_720P_INF(reg, mask); \
+	VIDC_LOG_READ(reg, pval); \
+	VIDC_MSG2("\n(0x%08x:"#reg"==0x%08x)",  \
+	(u32)(VIDC_##reg##_ADDR - DDL_720P_REG_BASE),  *pval); \
+} while (0)
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c
new file mode 100644
index 0000000..9b184e8
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c
@@ -0,0 +1,807 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/firmware.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <mach/clk.h>
+#include <linux/interrupt.h>
+#include <media/msm/vidc_init.h>
+#include <media/msm/vidc_type.h>
+#include "vcd_res_tracker.h"
+
+#define MSM_AXI_QOS_NAME "msm_vidc_reg"
+#define AXI_CLK_SCALING
+
+#define QVGA_PERF_LEVEL (300 * 30)
+#define VGA_PERF_LEVEL (1200 * 30)
+#define WVGA_PERF_LEVEL (1500 * 30)
+
+static unsigned int mfc_clk_freq_table[3] = {
+	61440000, 122880000, 170667000
+};
+
+static unsigned int axi_clk_freq_table_enc[2] = {
+	122880, 192000
+};
+static unsigned int axi_clk_freq_table_dec[2] = {
+	122880, 192000
+};
+
+static struct res_trk_context resource_context;
+
+#define VIDC_BOOT_FW			"vidc_720p_command_control.fw"
+#define VIDC_MPG4_DEC_FW		"vidc_720p_mp4_dec_mc.fw"
+#define VIDC_H263_DEC_FW		"vidc_720p_h263_dec_mc.fw"
+#define VIDC_H264_DEC_FW		"vidc_720p_h264_dec_mc.fw"
+#define VIDC_MPG4_ENC_FW		"vidc_720p_mp4_enc_mc.fw"
+#define VIDC_H264_ENC_FW		"vidc_720p_h264_enc_mc.fw"
+#define VIDC_VC1_DEC_FW		"vidc_720p_vc1_dec_mc.fw"
+
+unsigned char *vidc_command_control_fw;
+u32 vidc_command_control_fw_size;
+
+unsigned char *vidc_mpg4_dec_fw;
+u32 vidc_mpg4_dec_fw_size;
+
+unsigned char *vidc_h263_dec_fw;
+u32 vidc_h263_dec_fw_size;
+
+unsigned char *vidc_h264_dec_fw;
+u32 vidc_h264_dec_fw_size;
+
+unsigned char *vidc_mpg4_enc_fw;
+u32 vidc_mpg4_enc_fw_size;
+
+unsigned char *vidc_h264_enc_fw;
+u32 vidc_h264_enc_fw_size;
+
+unsigned char *vidc_vc1_dec_fw;
+u32 vidc_vc1_dec_fw_size;
+
+static u32 res_trk_disable_videocore(void)
+{
+	int rc = -1;
+	mutex_lock(&resource_context.lock);
+
+	if (!resource_context.rail_enabled) {
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+
+	if (!resource_context.clock_enabled &&
+		resource_context.pclk &&
+		resource_context.hclk &&
+		resource_context.hclk_div2) {
+
+		VCDRES_MSG_LOW("\nEnabling clk before disabling pwr rail\n");
+		if (clk_set_rate(resource_context.hclk,
+			mfc_clk_freq_table[0])) {
+			VCDRES_MSG_ERROR("\n pwr_rail_disable:"
+				 " set clk rate failed\n");
+			goto bail_out;
+		}
+
+		if (clk_prepare_enable(resource_context.pclk)) {
+			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
+			goto bail_out;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk)) {
+			VCDRES_MSG_ERROR("vidc hclk Enable failed\n");
+			goto disable_pclk;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
+			VCDRES_MSG_ERROR("vidc hclk_div2 Enable failed\n");
+			goto disable_hclk;
+		}
+	} else {
+		VCDRES_MSG_ERROR("\ndisabling pwr rail: Enabling clk failed\n");
+		goto bail_out;
+	}
+
+	resource_context.rail_enabled = 0;
+	rc = clk_reset(resource_context.pclk, CLK_RESET_ASSERT);
+	if (rc) {
+		VCDRES_MSG_ERROR("\n clk_reset failed %d\n", rc);
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+	msleep(20);
+
+	clk_disable_unprepare(resource_context.pclk);
+	clk_disable_unprepare(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk_div2);
+
+	clk_put(resource_context.hclk_div2);
+	clk_put(resource_context.hclk);
+	clk_put(resource_context.pclk);
+
+	rc = regulator_disable(resource_context.regulator);
+	if (rc) {
+		VCDRES_MSG_ERROR("\n regulator disable failed %d\n", rc);
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+
+	resource_context.hclk_div2 = NULL;
+	resource_context.hclk = NULL;
+	resource_context.pclk = NULL;
+
+	mutex_unlock(&resource_context.lock);
+
+	return true;
+
+disable_hclk:
+	clk_disable_unprepare(resource_context.hclk);
+disable_pclk:
+	clk_disable_unprepare(resource_context.pclk);
+bail_out:
+	if (resource_context.pclk) {
+		clk_put(resource_context.pclk);
+		resource_context.pclk = NULL;
+	}
+	if (resource_context.hclk) {
+		clk_put(resource_context.hclk);
+		resource_context.hclk = NULL;
+	}
+	if (resource_context.hclk_div2) {
+		clk_put(resource_context.hclk_div2);
+		resource_context.hclk_div2 = NULL;
+	}
+	mutex_unlock(&resource_context.lock);
+	return false;
+}
+
+u32 res_trk_enable_clocks(void)
+{
+	VCDRES_MSG_LOW("\n in res_trk_enable_clocks()");
+
+	mutex_lock(&resource_context.lock);
+	if (!resource_context.clock_enabled) {
+		VCDRES_MSG_LOW("Enabling IRQ in %s()\n", __func__);
+		enable_irq(resource_context.irq_num);
+
+		VCDRES_MSG_LOW("%s(): Enabling the clocks ...\n", __func__);
+
+		if (clk_prepare_enable(resource_context.pclk)) {
+			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
+
+			clk_put(resource_context.hclk);
+			clk_put(resource_context.hclk_div2);
+			mutex_unlock(&resource_context.lock);
+			return false;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk)) {
+			VCDRES_MSG_ERROR("vidc  hclk Enable failed\n");
+			clk_put(resource_context.pclk);
+			clk_put(resource_context.hclk_div2);
+			mutex_unlock(&resource_context.lock);
+			return false;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
+			VCDRES_MSG_ERROR("vidc  hclk Enable failed\n");
+			clk_put(resource_context.hclk);
+			clk_put(resource_context.pclk);
+			mutex_unlock(&resource_context.lock);
+			return false;
+		}
+	}
+
+	resource_context.clock_enabled = 1;
+	mutex_unlock(&resource_context.lock);
+	return true;
+}
+
+static u32 res_trk_sel_clk_rate(unsigned long hclk_rate)
+{
+	mutex_lock(&resource_context.lock);
+	if (clk_set_rate(resource_context.hclk,
+		hclk_rate)) {
+		VCDRES_MSG_ERROR("vidc hclk set rate failed\n");
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+	resource_context.hclk_rate = hclk_rate;
+	mutex_unlock(&resource_context.lock);
+	return true;
+}
+
+static u32 res_trk_get_clk_rate(unsigned long *phclk_rate)
+{
+	if (!phclk_rate) {
+		VCDRES_MSG_ERROR("%s(): phclk_rate is NULL\n", __func__);
+		return false;
+	}
+	mutex_lock(&resource_context.lock);
+	*phclk_rate = clk_get_rate(resource_context.hclk);
+	if (!(*phclk_rate)) {
+		VCDRES_MSG_ERROR("vidc hclk get rate failed\n");
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+	mutex_unlock(&resource_context.lock);
+	return true;
+}
+
+u32 res_trk_disable_clocks(void)
+{
+	VCDRES_MSG_LOW("in res_trk_disable_clocks()\n");
+
+	mutex_lock(&resource_context.lock);
+
+	if (!resource_context.clock_enabled) {
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+
+	VCDRES_MSG_LOW("Disabling IRQ in %s()\n", __func__);
+	disable_irq_nosync(resource_context.irq_num);
+	VCDRES_MSG_LOW("%s(): Disabling the clocks ...\n", __func__);
+
+	resource_context.clock_enabled = 0;
+	clk_disable_unprepare(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk_div2);
+	clk_disable_unprepare(resource_context.pclk);
+	mutex_unlock(&resource_context.lock);
+
+	return true;
+}
+
+static u32 res_trk_enable_videocore(void)
+{
+	mutex_lock(&resource_context.lock);
+	if (!resource_context.rail_enabled) {
+		int rc = -1;
+
+		rc = regulator_enable(resource_context.regulator);
+		if (rc) {
+			VCDRES_MSG_ERROR("%s(): regulator_enable failed %d\n",
+							 __func__, rc);
+			goto bail_out;
+		}
+		VCDRES_MSG_LOW("%s(): regulator enable Success %d\n",
+							__func__, rc);
+
+		resource_context.pclk = clk_get(resource_context.device,
+			"iface_clk");
+
+		if (IS_ERR(resource_context.pclk)) {
+			VCDRES_MSG_ERROR("%s(): iface_clk get failed\n"
+							 , __func__);
+			goto disable_regulator;
+		}
+
+		resource_context.hclk = clk_get(resource_context.device,
+			"core_clk");
+
+		if (IS_ERR(resource_context.hclk)) {
+			VCDRES_MSG_ERROR("%s(): core_clk get failed\n"
+							 , __func__);
+
+			goto release_pclk;
+		}
+
+		resource_context.hclk_div2 =
+			clk_get(resource_context.device, "core_div2_clk");
+
+		if (IS_ERR(resource_context.hclk_div2)) {
+			VCDRES_MSG_ERROR("%s(): core_div2_clk get failed\n"
+							 , __func__);
+			goto release_hclk_pclk;
+		}
+
+		if (clk_set_rate(resource_context.hclk,
+			mfc_clk_freq_table[0])) {
+			VCDRES_MSG_ERROR("\n pwr_rail_enable:"
+				 " set clk rate failed\n");
+			goto release_all_clks;
+		}
+
+		if (clk_prepare_enable(resource_context.pclk)) {
+			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
+			goto release_all_clks;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk)) {
+			VCDRES_MSG_ERROR("vidc hclk Enable failed\n");
+			goto disable_pclk;
+		}
+
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
+			VCDRES_MSG_ERROR("vidc hclk_div2 Enable failed\n");
+			goto disable_hclk_pclk;
+		}
+
+		rc = clk_reset(resource_context.pclk, CLK_RESET_DEASSERT);
+		if (rc) {
+			VCDRES_MSG_ERROR("\n clk_reset failed %d\n", rc);
+			goto disable_and_release_all_clks;
+		}
+		msleep(20);
+
+		clk_disable_unprepare(resource_context.pclk);
+		clk_disable_unprepare(resource_context.hclk);
+		clk_disable_unprepare(resource_context.hclk_div2);
+
+	}
+	resource_context.rail_enabled = 1;
+	mutex_unlock(&resource_context.lock);
+	return true;
+
+disable_and_release_all_clks:
+	clk_disable_unprepare(resource_context.hclk_div2);
+disable_hclk_pclk:
+	clk_disable_unprepare(resource_context.hclk);
+disable_pclk:
+	clk_disable_unprepare(resource_context.pclk);
+release_all_clks:
+	clk_put(resource_context.hclk_div2);
+	resource_context.hclk_div2 = NULL;
+release_hclk_pclk:
+	clk_put(resource_context.hclk);
+	resource_context.hclk = NULL;
+release_pclk:
+	clk_put(resource_context.pclk);
+	resource_context.pclk = NULL;
+disable_regulator:
+	regulator_disable(resource_context.regulator);
+bail_out:
+	mutex_unlock(&resource_context.lock);
+	return false;
+}
+
+static u32 res_trk_convert_freq_to_perf_lvl(u64 freq)
+{
+	u64 perf_lvl;
+	u64 temp;
+
+	VCDRES_MSG_MED("\n %s():: freq = %u\n", __func__, (u32)freq);
+
+	if (!freq)
+		return 0;
+
+	temp = freq * 1000;
+	do_div(temp, VCD_RESTRK_HZ_PER_1000_PERFLVL);
+	perf_lvl = (u32)temp;
+	VCDRES_MSG_MED("\n %s(): perf_lvl = %u\n", __func__,
+		(u32)perf_lvl);
+
+	return (u32)perf_lvl;
+}
+
+static u32 res_trk_convert_perf_lvl_to_freq(u64 perf_lvl)
+{
+	u64 freq, temp;
+
+	VCDRES_MSG_MED("\n %s():: perf_lvl = %u\n", __func__,
+		(u32)perf_lvl);
+	temp = (perf_lvl * VCD_RESTRK_HZ_PER_1000_PERFLVL) + 999;
+	do_div(temp, 1000);
+	freq = (u32)temp;
+	VCDRES_MSG_MED("\n %s(): freq = %u\n", __func__, (u32)freq);
+
+	return (u32)freq;
+}
+
+static struct clk *ebi1_clk;
+
+u32 res_trk_power_up(void)
+{
+	VCDRES_MSG_LOW("clk_regime_rail_enable");
+	VCDRES_MSG_LOW("clk_regime_sel_rail_control");
+#ifdef AXI_CLK_SCALING
+{
+	VCDRES_MSG_MED("\n res_trk_power_up():: "
+		"Calling AXI add requirement\n");
+	ebi1_clk = clk_get(resource_context.device, "mem_clk");
+	if (IS_ERR(ebi1_clk)) {
+		VCDRES_MSG_ERROR("Request AXI bus QOS fails.");
+		return false;
+	}
+	clk_prepare_enable(ebi1_clk);
+}
+#endif
+
+	VCDRES_MSG_MED("\n res_trk_power_up():: Calling "
+		"vidc_enable_pwr_rail()\n");
+	return res_trk_enable_videocore();
+}
+
+u32 res_trk_power_down(void)
+{
+	VCDRES_MSG_LOW("clk_regime_rail_disable");
+#ifdef AXI_CLK_SCALING
+	VCDRES_MSG_MED("\n res_trk_power_down()::"
+		"Calling AXI remove requirement\n");
+	clk_disable_unprepare(ebi1_clk);
+	clk_put(ebi1_clk);
+#endif
+	VCDRES_MSG_MED("\n res_trk_power_down():: Calling "
+		"res_trk_disable_videocore()\n");
+	return res_trk_disable_videocore();
+}
+
+u32 res_trk_get_max_perf_level(u32 *pn_max_perf_lvl)
+{
+	if (!pn_max_perf_lvl) {
+		VCDRES_MSG_ERROR("%s(): pn_max_perf_lvl is NULL\n",
+			__func__);
+		return false;
+	}
+
+	*pn_max_perf_lvl = VCD_RESTRK_MAX_PERF_LEVEL;
+	return true;
+}
+
+u32 res_trk_set_perf_level(u32 req_perf_lvl, u32 *pn_set_perf_lvl,
+	struct vcd_dev_ctxt *dev_ctxt)
+{
+	struct vcd_clnt_ctxt *cctxt_itr = NULL;
+	u32 axi_freq = 0, mfc_freq = 0, calc_mfc_freq = 0;
+	u8 enc_clnt_present = false;
+
+	if (!pn_set_perf_lvl || !dev_ctxt) {
+		VCDRES_MSG_ERROR("%s(): NULL pointer! dev_ctxt(%p)\n",
+			__func__, dev_ctxt);
+		return false;
+	}
+
+	VCDRES_MSG_LOW("%s(), req_perf_lvl = %d", __func__, req_perf_lvl);
+	calc_mfc_freq = res_trk_convert_perf_lvl_to_freq(
+		(u64)req_perf_lvl);
+
+	if (calc_mfc_freq < VCD_RESTRK_MIN_FREQ_POINT)
+		calc_mfc_freq = VCD_RESTRK_MIN_FREQ_POINT;
+	else if (calc_mfc_freq > VCD_RESTRK_MAX_FREQ_POINT)
+		calc_mfc_freq = VCD_RESTRK_MAX_FREQ_POINT;
+
+	cctxt_itr = dev_ctxt->cctxt_list_head;
+	while (cctxt_itr) {
+		VCDRES_MSG_LOW("\n cctxt_itr = %p", cctxt_itr);
+		if (!cctxt_itr->decoding) {
+				VCDRES_MSG_LOW("\n Encoder client");
+				enc_clnt_present = true;
+				break;
+		} else {
+				VCDRES_MSG_LOW("\n Decoder client");
+		}
+		cctxt_itr = cctxt_itr->next;
+	}
+
+	if (enc_clnt_present) {
+		if (req_perf_lvl >= VGA_PERF_LEVEL) {
+			mfc_freq = mfc_clk_freq_table[2];
+			axi_freq = axi_clk_freq_table_enc[1];
+		} else {
+			mfc_freq = mfc_clk_freq_table[0];
+			axi_freq = axi_clk_freq_table_enc[0];
+		}
+		VCDRES_MSG_MED("\n ENCODER: axi_freq = %u"
+			", mfc_freq = %u, calc_mfc_freq = %u,"
+			" req_perf_lvl = %u", axi_freq,
+			mfc_freq, calc_mfc_freq,
+			req_perf_lvl);
+	} else {
+		if (req_perf_lvl <= QVGA_PERF_LEVEL) {
+			mfc_freq = mfc_clk_freq_table[0];
+			axi_freq = axi_clk_freq_table_dec[0];
+		} else {
+			axi_freq = axi_clk_freq_table_dec[0];
+			if (req_perf_lvl <= VGA_PERF_LEVEL)
+				mfc_freq = mfc_clk_freq_table[0];
+			else if (req_perf_lvl <= WVGA_PERF_LEVEL)
+				mfc_freq = mfc_clk_freq_table[1];
+			else {
+				mfc_freq = mfc_clk_freq_table[2];
+				axi_freq = axi_clk_freq_table_dec[1];
+			}
+		}
+		VCDRES_MSG_MED("\n DECODER: axi_freq = %u"
+			", mfc_freq = %u, calc_mfc_freq = %u,"
+			" req_perf_lvl = %u", axi_freq,
+			mfc_freq, calc_mfc_freq,
+			req_perf_lvl);
+	}
+
+#ifdef AXI_CLK_SCALING
+    if (req_perf_lvl != VCD_RESTRK_MIN_PERF_LEVEL) {
+		VCDRES_MSG_MED("\n %s(): Setting AXI freq to %u",
+			__func__, axi_freq);
+		clk_set_rate(ebi1_clk, axi_freq * 1000);
+	}
+#endif
+
+#ifdef USE_RES_TRACKER
+    if (req_perf_lvl != VCD_RESTRK_MIN_PERF_LEVEL) {
+		VCDRES_MSG_MED("\n %s(): Setting MFC freq to %u",
+			__func__, mfc_freq);
+		if (!res_trk_sel_clk_rate(mfc_freq)) {
+			VCDRES_MSG_ERROR("%s(): res_trk_sel_clk_rate FAILED\n",
+				__func__);
+			*pn_set_perf_lvl = 0;
+			return false;
+		}
+	}
+#endif
+
+	*pn_set_perf_lvl =
+	    res_trk_convert_freq_to_perf_lvl((u64) mfc_freq);
+	return true;
+}
+
+u32 res_trk_get_curr_perf_level(u32 *pn_perf_lvl)
+{
+	unsigned long freq;
+
+	if (!pn_perf_lvl) {
+		VCDRES_MSG_ERROR("%s(): pn_perf_lvl is NULL\n",
+			__func__);
+		return false;
+	}
+	VCDRES_MSG_LOW("clk_regime_msm_get_clk_freq_hz");
+	if (!res_trk_get_clk_rate(&freq)) {
+		VCDRES_MSG_ERROR("%s(): res_trk_get_clk_rate FAILED\n",
+			__func__);
+		*pn_perf_lvl = 0;
+		return false;
+	}
+
+	*pn_perf_lvl = res_trk_convert_freq_to_perf_lvl((u64) freq);
+	VCDRES_MSG_MED("%s(): freq = %lu, *pn_perf_lvl = %u", __func__,
+		freq, *pn_perf_lvl);
+	return true;
+}
+
+u32 res_trk_download_firmware(void)
+{
+	const struct firmware *fw_boot = NULL;
+	const struct firmware *fw_mpg4_dec = NULL;
+	const struct firmware *fw_h263_dec = NULL;
+	const struct firmware *fw_h264_dec = NULL;
+	const struct firmware *fw_mpg4_enc = NULL;
+	const struct firmware *fw_h264_enc = NULL;
+	const struct firmware *fw_vc1_dec = NULL;
+	int rc = 0;
+	u32 status = true;
+
+	VCDRES_MSG_HIGH("%s(): Request firmware download\n",
+		__func__);
+	mutex_lock(&resource_context.lock);
+	rc = request_firmware(&fw_boot, VIDC_BOOT_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_BOOT_FW, rc);
+		mutex_unlock(&resource_context.lock);
+		return false;
+	}
+	vidc_command_control_fw = (unsigned char *)fw_boot->data;
+	vidc_command_control_fw_size = (u32) fw_boot->size;
+
+	rc = request_firmware(&fw_mpg4_dec, VIDC_MPG4_DEC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_MPG4_DEC_FW, rc);
+		status = false;
+		goto boot_fw_free;
+	}
+	vidc_mpg4_dec_fw = (unsigned char *)fw_mpg4_dec->data;
+	vidc_mpg4_dec_fw_size = (u32) fw_mpg4_dec->size;
+
+
+	rc = request_firmware(&fw_h263_dec, VIDC_H263_DEC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_H263_DEC_FW, rc);
+		status = false;
+		goto mp4dec_fw_free;
+	}
+	vidc_h263_dec_fw = (unsigned char *)fw_h263_dec->data;
+	vidc_h263_dec_fw_size = (u32) fw_h263_dec->size;
+
+	rc = request_firmware(&fw_h264_dec, VIDC_H264_DEC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_H264_DEC_FW, rc);
+		status = false;
+		goto h263dec_fw_free;
+	}
+	vidc_h264_dec_fw = (unsigned char *)fw_h264_dec->data;
+	vidc_h264_dec_fw_size = (u32) fw_h264_dec->size;
+
+	rc = request_firmware(&fw_mpg4_enc, VIDC_MPG4_ENC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_MPG4_ENC_FW, rc);
+		status = false;
+		goto h264dec_fw_free;
+	}
+	vidc_mpg4_enc_fw = (unsigned char *)fw_mpg4_enc->data;
+	vidc_mpg4_enc_fw_size = (u32) fw_mpg4_enc->size;
+
+	rc = request_firmware(&fw_h264_enc, VIDC_H264_ENC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_H264_ENC_FW, rc);
+		status = false;
+		goto mp4enc_fw_free;
+	}
+	vidc_h264_enc_fw = (unsigned char *)fw_h264_enc->data;
+	vidc_h264_enc_fw_size = (u32) fw_h264_enc->size;
+
+	rc = request_firmware(&fw_vc1_dec, VIDC_VC1_DEC_FW,
+						  resource_context.device);
+	if (rc) {
+		VCDRES_MSG_ERROR("request_firmware for %s error %d\n",
+				VIDC_VC1_DEC_FW, rc);
+		status = false;
+		goto h264enc_fw_free;
+	}
+	vidc_vc1_dec_fw = (unsigned char *)fw_vc1_dec->data;
+	vidc_vc1_dec_fw_size = (u32) fw_vc1_dec->size;
+	mutex_unlock(&resource_context.lock);
+	return status;
+
+h264enc_fw_free:
+	release_firmware(fw_h264_enc);
+mp4enc_fw_free:
+	release_firmware(fw_mpg4_enc);
+h264dec_fw_free:
+	release_firmware(fw_h264_dec);
+h263dec_fw_free:
+	release_firmware(fw_h263_dec);
+mp4dec_fw_free:
+	release_firmware(fw_mpg4_dec);
+boot_fw_free:
+	release_firmware(fw_boot);
+	mutex_unlock(&resource_context.lock);
+	return false;
+}
+
+static struct ion_client *res_trk_create_ion_client(void){
+	struct ion_client *video_client;
+	VCDRES_MSG_LOW("%s", __func__);
+	video_client = msm_ion_client_create(-1, "video_client");
+	return video_client;
+}
+
+void res_trk_init(struct device *device, u32 irq)
+{
+	VCDRES_MSG_LOW("%s", __func__);
+	if (resource_context.device || resource_context.irq_num ||
+		!device) {
+		VCDRES_MSG_ERROR("%s() Resource Tracker Init error\n",
+				__func__);
+		return;
+	}
+	memset(&resource_context, 0, sizeof(resource_context));
+	mutex_init(&resource_context.lock);
+	resource_context.device = device;
+	resource_context.irq_num = irq;
+	resource_context.core_type = VCD_CORE_720P;
+	resource_context.regulator = regulator_get(NULL, "fs_mfc");
+	resource_context.vidc_platform_data =
+		(struct msm_vidc_platform_data *) device->platform_data;
+	if (resource_context.vidc_platform_data) {
+		resource_context.memtype =
+			resource_context.vidc_platform_data->memtype;
+		VCDRES_MSG_LOW("%s(): resource_context.memtype = 0x%x",
+			__func__, (u32)resource_context.memtype);
+		if (resource_context.vidc_platform_data->enable_ion) {
+			resource_context.res_ion_client =
+				res_trk_create_ion_client();
+			if (!(resource_context.res_ion_client)) {
+				VCDRES_MSG_ERROR("%s()ION createfail\n",
+						__func__);
+				return;
+			}
+			VCDRES_MSG_LOW("%s(): ion_client = 0x%x", __func__,
+				(u32)resource_context.res_ion_client);
+		} else {
+			VCDRES_MSG_ERROR("%s(): ION not disabled\n",
+					__func__);
+		}
+	} else {
+		resource_context.memtype = -1;
+		VCDRES_MSG_ERROR("%s(): vidc_platform_data is NULL",
+			__func__);
+	}
+}
+
+u32 res_trk_get_core_type(void){
+	return resource_context.core_type;
+}
+
+u32 res_trk_get_enable_ion(void)
+{
+	if (resource_context.vidc_platform_data->enable_ion)
+		return 1;
+	else
+		return 0;
+}
+
+struct ion_client *res_trk_get_ion_client(void)
+{
+	return resource_context.res_ion_client;
+}
+
+u32 res_trk_get_mem_type(void)
+{
+	u32 mem_type = ION_HEAP(resource_context.memtype);
+	return mem_type;
+}
+
+void res_trk_set_mem_type(enum ddl_mem_area mem_type)
+{
+	return;
+}
+
+u32 res_trk_get_disable_fullhd(void)
+{
+	return 0;
+}
+
+u32 res_trk_get_ion_flags(void)
+{
+	return 0;
+}
+
+int res_trk_check_for_sec_session()
+{
+	return 0;
+}
+
+void res_trk_secure_unset(void)
+{
+	return;
+}
+
+void res_trk_secure_set(void)
+{
+	return;
+}
+
+int res_trk_open_secure_session()
+{
+	return -EINVAL;
+}
+
+int res_trk_close_secure_session()
+{
+	return 0;
+}
+u32 get_res_trk_perf_level(enum vcd_perf_level perf_level)
+{
+	return -ENOTSUPP;
+}
+u32 res_trk_is_cp_enabled(void)
+{
+	if (resource_context.vidc_platform_data->cp_enabled)
+		return 1;
+	else
+		return 0;
+}
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl)
+{
+	return 0;
+}
+
diff --git a/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.h b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.h
new file mode 100644
index 0000000..e1781b6
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.h
@@ -0,0 +1,60 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VIDEO_720P_RESOURCE_TRACKER_H_
+#define _VIDEO_720P_RESOURCE_TRACKER_H_
+#include <mach/board.h>
+#include <linux/msm_ion.h>
+#include "vcd_res_tracker_api.h"
+
+#define VCD_RESTRK_MIN_PERF_LEVEL 37900
+#define VCD_RESTRK_MAX_PERF_LEVEL 108000
+#define VCD_RESTRK_MIN_FREQ_POINT 61440000
+#define VCD_RESTRK_MAX_FREQ_POINT 170667000
+#define VCD_RESTRK_HZ_PER_1000_PERFLVL 1580250
+
+struct res_trk_context {
+	struct device *device;
+	u32 irq_num;
+	struct mutex lock;
+	struct clk *hclk;
+	struct clk *hclk_div2;
+	struct clk *pclk;
+	unsigned long hclk_rate;
+	unsigned int clock_enabled;
+	unsigned int rail_enabled;
+	struct regulator *regulator;
+	struct msm_vidc_platform_data *vidc_platform_data;
+	u32 core_type;
+	int memtype;
+	u32 secure_session;
+	struct ion_client *res_ion_client;
+	enum ddl_mem_area res_mem_type;
+};
+
+#if DEBUG
+
+#define VCDRES_MSG_LOW(xx_fmt...)	printk(KERN_INFO "\n\t* " xx_fmt)
+#define VCDRES_MSG_MED(xx_fmt...)	printk(KERN_INFO "\n  * " xx_fmt)
+
+#else
+
+#define VCDRES_MSG_LOW(xx_fmt...)
+#define VCDRES_MSG_MED(xx_fmt...)
+
+#endif
+
+#define VCDRES_MSG_HIGH(xx_fmt...)	printk(KERN_WARNING "\n" xx_fmt)
+#define VCDRES_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n err: " xx_fmt)
+#define VCDRES_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n<FATAL> " xx_fmt)
+
+#endif
diff --git a/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h
new file mode 100644
index 0000000..537f3c8
--- /dev/null
+++ b/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h
@@ -0,0 +1,44 @@
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _VIDEO_720P_RESOURCE_TRACKER_API_H_
+#define _VIDEO_720P_RESOURCE_TRACKER_API_H_
+
+#include "vcd_core.h"
+#include "vcd_ddl.h"
+
+void res_trk_init(struct device *device, u32 irq);
+u32 res_trk_power_up(void);
+u32 res_trk_power_down(void);
+u32 res_trk_enable_clocks(void);
+u32 res_trk_disable_clocks(void);
+u32 res_trk_get_max_perf_level(u32 *pn_max_perf_lvl);
+u32 res_trk_set_perf_level(u32 req_perf_lvl, u32 *pn_set_perf_lvl,
+	struct vcd_dev_ctxt *dev_ctxt);
+u32 res_trk_get_curr_perf_level(u32 *pn_perf_lvl);
+u32 res_trk_download_firmware(void);
+u32 res_trk_get_core_type(void);
+u32 res_trk_get_mem_type(void);
+u32 res_trk_get_disable_fullhd(void);
+u32 res_trk_get_ion_flags(void);
+u32 res_trk_get_enable_ion(void);
+u32 res_trk_is_cp_enabled(void);
+struct ion_client *res_trk_get_ion_client(void);
+void res_trk_set_mem_type(enum ddl_mem_area mem_type);
+int res_trk_check_for_sec_session(void);
+int res_trk_open_secure_session(void);
+int res_trk_close_secure_session(void);
+void res_trk_secure_set(void);
+void res_trk_secure_unset(void);
+u32 get_res_trk_perf_level(enum vcd_perf_level perf_level);
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl);
+#endif
diff --git a/drivers/video/msm/vidc/common/dec/vdec.c b/drivers/video/msm/vidc/common/dec/vdec.c
index 1e16ad4..e74f2a6 100644
--- a/drivers/video/msm/vidc/common/dec/vdec.c
+++ b/drivers/video/msm/vidc/common/dec/vdec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -37,9 +37,9 @@
 
 
 
-#define DBG(x...) pr_debug("[VID] " x)
-#define INFO(x...) pr_info("[VID] " x)
-#define ERR(x...) pr_err("[VID] " x)
+#define DBG(x...) pr_debug(x)
+#define INFO(x...) pr_info(x)
+#define ERR(x...) pr_err(x)
 
 #define VID_DEC_NAME "msm_vidc_dec"
 
@@ -271,25 +271,64 @@ static void vid_dec_output_frame_done(struct video_client_ctx *client_ctx,
 				      &phy_addr, &pmem_fd, &file,
 				      &buffer_index) ||
 		(vcd_frame_data->flags & VCD_FRAME_FLAG_EOS)) {
-		
+
+		if (res_trk_check_for_sec_session() &&
+			res_trk_get_enable_sec_metadata() &&
+			event == VCD_EVT_RESP_OUTPUT_DONE) {
+			DBG("Buffer Index = %d", buffer_index);
+			if (buffer_index != -1) {
+				if (client_ctx->meta_addr_table[buffer_index].
+					kernel_vir_addr_iommu &&
+					client_ctx->
+					meta_addr_table[buffer_index].
+					kernel_vir_addr) {
+
+					memcpy(client_ctx->
+						meta_addr_table[buffer_index].
+						kernel_vir_addr_iommu,
+						client_ctx->
+						meta_addr_table[buffer_index].
+						kernel_vir_addr,
+						client_ctx->meta_buf_size);
+					DBG("Copying Meta Buffer from "\
+						"secure memory"
+						"kernel_virt_iommu = %p "
+						"kernel_virt = %p",
+						client_ctx->
+						meta_addr_table[buffer_index].
+						kernel_vir_addr_iommu,
+						client_ctx->
+						meta_addr_table[buffer_index].
+						kernel_vir_addr);
+				}
+			}
+		}
+
+		/* Buffer address in user space */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.bufferaddr =
 		    (u8 *) user_vaddr;
-		
+		/* Data length */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.len =
 		    vcd_frame_data->data_len;
 		vdec_msg->vdec_msg_info.msgdata.output_frame.flags =
 		    vcd_frame_data->flags;
-		
+		/* metadata offset in output buffer for non-secure mode */
+		vdec_msg->vdec_msg_info.msgdata.output_frame.metadata_len =
+			(size_t)vcd_frame_data->metadata_len;
+		/* metadata offset in output buffer for non-secure mode */
+		vdec_msg->vdec_msg_info.msgdata.output_frame.metadata_offset =
+			(size_t)vcd_frame_data->metadata_offset;
+		/* Timestamp pass-through from input frame */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.time_stamp =
 		    vcd_frame_data->time_stamp;
-		
+		/* Output frame client data */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.client_data =
 		    (void *)vcd_frame_data->frm_clnt_data;
-		
+		/* Associated input frame client data */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.
 		    input_frame_clientdata =
 		    (void *)vcd_frame_data->ip_frm_tag;
-		
+		/* Decoded picture width and height */
 		vdec_msg->vdec_msg_info.msgdata.output_frame.framesize.
 		bottom =
 		    vcd_frame_data->dec_op_prop.disp_frm.bottom;
@@ -308,7 +347,7 @@ static void vid_dec_output_frame_done(struct video_client_ctx *client_ctx,
 				output_frame.interlaced_format =
 				VDEC_InterlaceFrameProgressive;
 		}
-		
+		/* Decoded picture type */
 		switch (vcd_frame_data->frame) {
 		case VCD_FRAME_I:
 			pic_type = PICTURE_TYPE_I;
@@ -347,14 +386,12 @@ static void vid_dec_output_frame_done(struct video_client_ctx *client_ctx,
 		ion_flag = vidc_get_fd_info(client_ctx, BUFFER_TYPE_OUTPUT,
 				pmem_fd, kernel_vaddr, buffer_index,
 				&buff_handle);
-		if (ion_flag == CACHED && buff_handle) {
-			DBG("%s: Cache invalidate: vaddr (%p), "\
-				"size %u\n", __func__,
-				(void *)kernel_vaddr,
+		if (ion_flag == ION_FLAG_CACHED && buff_handle) {
+			DBG("%s: Cache invalidate: size %u", __func__,
 				vcd_frame_data->alloc_len);
 			msm_ion_do_cache_op(client_ctx->user_ion_client,
 					buff_handle,
-					(unsigned long *) kernel_vaddr,
+					(unsigned long *) NULL,
 					(unsigned long)vcd_frame_data->\
 					alloc_len,
 					ION_IOC_INV_CACHES);
@@ -386,49 +423,49 @@ static void vid_dec_lean_event(struct video_client_ctx *client_ctx,
 
 	switch (event) {
 	case VCD_EVT_IND_OUTPUT_RECONFIG:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_EVT_CONFIG_CHANGED"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_EVT_CONFIG_CHANGED"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_MSG_EVT_CONFIG_CHANGED;
 		break;
 	case VCD_EVT_IND_RESOURCES_LOST:
-		INFO("msm_vidc_dec: Sending VDEC_EVT_RESOURCES_LOST"
+		DBG("msm_vidc_dec: Sending VDEC_EVT_RESOURCES_LOST"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_EVT_RESOURCES_LOST;
 		break;
 	case VCD_EVT_RESP_FLUSH_INPUT_DONE:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_RESP_FLUSH_INPUT_DONE"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_RESP_FLUSH_INPUT_DONE"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode =
 		    VDEC_MSG_RESP_FLUSH_INPUT_DONE;
 		break;
 	case VCD_EVT_RESP_FLUSH_OUTPUT_DONE:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_RESP_FLUSH_OUTPUT_DONE"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_RESP_FLUSH_OUTPUT_DONE"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode =
 		    VDEC_MSG_RESP_FLUSH_OUTPUT_DONE;
 		break;
 	case VCD_EVT_IND_HWERRFATAL:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_EVT_HW_ERROR"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_EVT_HW_ERROR"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_MSG_EVT_HW_ERROR;
 		break;
 	case VCD_EVT_RESP_START:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_RESP_START_DONE"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_RESP_START_DONE"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_MSG_RESP_START_DONE;
 		break;
 	case VCD_EVT_RESP_STOP:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_RESP_STOP_DONE"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_RESP_STOP_DONE"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_MSG_RESP_STOP_DONE;
 		break;
 	case VCD_EVT_RESP_PAUSE:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_RESP_PAUSE_DONE"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_RESP_PAUSE_DONE"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode = VDEC_MSG_RESP_PAUSE_DONE;
 		break;
 	case VCD_EVT_IND_INFO_OUTPUT_RECONFIG:
-		INFO("msm_vidc_dec: Sending VDEC_MSG_EVT_INFO_CONFIG_CHANGED"
+		DBG("msm_vidc_dec: Sending VDEC_MSG_EVT_INFO_CONFIG_CHANGED"
 			 " to client");
 		vdec_msg->vdec_msg_info.msgcode =
 			 VDEC_MSG_EVT_INFO_CONFIG_CHANGED;
@@ -641,24 +678,49 @@ static u32 vid_dec_set_frame_resolution(struct video_client_ctx *client_ctx,
 		return true;
 }
 
-static u32 vid_dec_set_turbo_clk(struct video_client_ctx *client_ctx)
+static u32 vid_dec_get_curr_perf_level(struct video_client_ctx *client_ctx,
+	u32 *perf_level)
 {
 	struct vcd_property_hdr vcd_property_hdr;
 	u32 vcd_status = VCD_ERR_FAIL;
-	u32 dummy = 0;
+	u32 perf_lvl = 0;
 
 	if (!client_ctx)
 		return false;
-	vcd_property_hdr.prop_id = VCD_I_SET_TURBO_CLK;
-	vcd_property_hdr.sz = sizeof(struct vcd_property_frame_size);
 
-	vcd_status = vcd_set_property(client_ctx->vcd_handle,
-				      &vcd_property_hdr, &dummy);
+	vcd_property_hdr.prop_id = VCD_I_GET_CURR_PERF_LEVEL;
+	vcd_property_hdr.sz = sizeof(u32);
+	vcd_status = vcd_get_property(client_ctx->vcd_handle,
+				      &vcd_property_hdr, &perf_lvl);
+	if (vcd_status) {
+		ERR("VCD_I_GET_PERF_LEVEL failed!!");
+		*perf_level = 0;
+		return false;
+	} else {
+		*perf_level = perf_lvl;
+		return true;
+	}
+}
 
-	if (vcd_status)
+static u32 vid_dec_set_turbo_clk(struct video_client_ctx *client_ctx)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+	struct vcd_property_perf_level perf_level;
+	perf_level.level = VCD_PERF_LEVEL_TURBO;
+
+	if (!client_ctx)
 		return false;
-	else
+	vcd_property_hdr.prop_id = VCD_REQ_PERF_LEVEL;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_perf_level);
+	vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				      &vcd_property_hdr, &perf_level);
+	if (vcd_status) {
+		ERR("%s: set turbo perf_level failed", __func__);
+		return false;
+	} else {
 		return true;
+	}
 }
 
 static u32 vid_dec_get_frame_resolution(struct video_client_ctx *client_ctx,
@@ -703,6 +765,22 @@ static u32 vid_dec_get_progressive_only(struct video_client_ctx *client_ctx,
 		return true;
 }
 
+static u32 vid_dec_get_enable_secure_metadata(struct video_client_ctx
+				*client_ctx, u32 *enable_sec_metadata)
+{
+
+	struct vcd_property_hdr vcd_property_hdr;
+	if (!client_ctx || !enable_sec_metadata)
+		return false;
+	vcd_property_hdr.prop_id = VCD_I_ENABLE_SEC_METADATA;
+	vcd_property_hdr.sz = sizeof(u32);
+	if (vcd_get_property(client_ctx->vcd_handle, &vcd_property_hdr,
+						 enable_sec_metadata))
+		return false;
+	else
+		return true;
+}
+
 static u32 vid_dec_get_disable_dmx_support(struct video_client_ctx *client_ctx,
 					   u32 *disable_dmx)
 {
@@ -838,7 +916,263 @@ static u32 vid_dec_set_idr_only_decoding(struct video_client_ctx *client_ctx)
 		return false;
 	return true;
 }
+static u32 vid_dec_set_meta_buffers(struct video_client_ctx *client_ctx,
+					struct vdec_meta_buffers *meta_buffers)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	struct vcd_property_meta_buffer *vcd_meta_buffer = NULL;
+	struct msm_mapped_buffer *mapped_buffer = NULL;
+	struct msm_mapped_buffer *mapped_buffer_iommu = NULL;
+	u32 vcd_status = VCD_ERR_FAIL;
+	u32 len = 0, flags = 0, len_iommu = 0, flags_iommu = 0, buf_size = 0;
+	struct file *file, *file_iommu;
+	int rc = 0;
+	unsigned long ionflag = 0, ionflag_iommu = 0;
+	unsigned long buffer_size = 0, buffer_size_iommu = 0;
+	unsigned long iova = 0, iova_iommu = 0;
+	int index = -1, num_buffers = 0;
+	u8 *ker_vir_addr = NULL, *ker_vir_addr_iommu = NULL;
+
+	if (!client_ctx || !meta_buffers)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_SET_EXT_METABUFFER;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_meta_buffer);
+	vcd_meta_buffer = &client_ctx->vcd_meta_buffer;
+
+	memset(&client_ctx->vcd_meta_buffer, 0,
+		   sizeof(struct vcd_property_meta_buffer));
+	vcd_meta_buffer->size = meta_buffers->size;
+	vcd_meta_buffer->count = meta_buffers->count;
+	vcd_meta_buffer->pmem_fd = meta_buffers->pmem_fd;
+	vcd_meta_buffer->offset = meta_buffers->offset;
+	vcd_meta_buffer->pmem_fd_iommu = meta_buffers->pmem_fd_iommu;
+
+	if (!vcd_get_ion_status()) {
+		if (get_pmem_file(vcd_meta_buffer->pmem_fd,
+				(unsigned long *) (&(vcd_meta_buffer->
+				physical_addr)),
+				(unsigned long *) (&vcd_meta_buffer->
+							kernel_virtual_addr),
+				(unsigned long *) (&len), &file)) {
+				ERR("%s(): get_pmem_file failed\n", __func__);
+				return false;
+			}
+		put_pmem_file(file);
+		flags = MSM_SUBSYSTEM_MAP_IOVA;
+		mapped_buffer = msm_subsystem_map_buffer(
+			(unsigned long)vcd_meta_buffer->physical_addr,
+				len, flags, vidc_mmu_subsystem,
+				sizeof(vidc_mmu_subsystem)/
+				sizeof(unsigned int));
+		if (IS_ERR(mapped_buffer)) {
+			pr_err("buffer map failed");
+			return false;
+		}
+		vcd_meta_buffer->client_data = (void *) mapped_buffer;
+		vcd_meta_buffer->dev_addr =
+			(u8 *)mapped_buffer->iova[0];
+
+		if (get_pmem_file(vcd_meta_buffer->pmem_fd_iommu,
+				(unsigned long *) (&(vcd_meta_buffer->
+				physical_addr_iommu)),
+				(unsigned long *) (&vcd_meta_buffer->
+				kernel_virt_addr_iommu),
+				(unsigned long *) (&len_iommu), &file_iommu)) {
+				ERR("%s(): get_pmem_file failed\n", __func__);
+				return false;
+			}
+		put_pmem_file(file_iommu);
+		flags_iommu = MSM_SUBSYSTEM_MAP_IOVA;
+		mapped_buffer_iommu = msm_subsystem_map_buffer(
+			(unsigned long)vcd_meta_buffer->physical_addr_iommu,
+				len_iommu, flags_iommu, vidc_mmu_subsystem,
+				sizeof(vidc_mmu_subsystem)/
+				sizeof(unsigned int));
+		if (IS_ERR(mapped_buffer_iommu)) {
+			pr_err("buffer map failed");
+			return false;
+		}
+		vcd_meta_buffer->client_data_iommu =
+					(void *) mapped_buffer_iommu;
+		vcd_meta_buffer->dev_addr_iommu =
+					(u8 *)mapped_buffer_iommu->iova[0];
+	} else {
+		client_ctx->meta_buffer_ion_handle = ion_import_dma_buf(
+					client_ctx->user_ion_client,
+					vcd_meta_buffer->pmem_fd);
+		if (IS_ERR_OR_NULL(client_ctx->meta_buffer_ion_handle)) {
+			ERR("%s(): get_ION_handle failed\n", __func__);
+			goto import_ion_error;
+		}
+		rc = ion_handle_get_flags(client_ctx->user_ion_client,
+					client_ctx->meta_buffer_ion_handle,
+					&ionflag);
+		if (rc) {
+			ERR("%s():get_ION_flags fail\n",
+					 __func__);
+			goto import_ion_error;
+		}
+		vcd_meta_buffer->kernel_virtual_addr =
+			(u8 *) ion_map_kernel(
+			client_ctx->user_ion_client,
+			client_ctx->meta_buffer_ion_handle);
+		if (!vcd_meta_buffer->kernel_virtual_addr) {
+			ERR("%s(): get_ION_kernel virtual addr failed\n",
+				 __func__);
+			goto import_ion_error;
+		}
+		if (res_trk_check_for_sec_session() ||
+		   (res_trk_get_core_type() == (u32)VCD_CORE_720P)) {
+			rc = ion_phys(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle,
+				(unsigned long *) (&(vcd_meta_buffer->
+				physical_addr)), &len);
+			if (rc) {
+				ERR("%s():get_ION_kernel physical addr fail\n",
+					__func__);
+				goto ion_map_error;
+			}
+			vcd_meta_buffer->client_data = NULL;
+			vcd_meta_buffer->dev_addr = (u8 *)
+				vcd_meta_buffer->physical_addr;
+		} else {
+			rc = ion_map_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle,
+				VIDEO_DOMAIN, VIDEO_MAIN_POOL,
+				SZ_4K, 0, (unsigned long *)&iova,
+				(unsigned long *)&buffer_size,
+				0, 0);
+			if (rc || !iova) {
+				ERR("%s():get_ION_kernel physical addr fail,"\
+					" rc = %d iova = 0x%lx\n",
+					__func__, rc, iova);
+				goto ion_map_error;
+			}
+			vcd_meta_buffer->physical_addr = (u8 *) iova;
+			vcd_meta_buffer->client_data = NULL;
+			vcd_meta_buffer->dev_addr = (u8 *) iova;
+		}
+
+		client_ctx->meta_buffer_iommu_ion_handle = ion_import_dma_buf(
+					client_ctx->user_ion_client,
+					vcd_meta_buffer->pmem_fd_iommu);
+		if (IS_ERR_OR_NULL(client_ctx->meta_buffer_iommu_ion_handle)) {
+			ERR("%s(): get_ION_handle failed\n", __func__);
+			goto import_ion_error;
+		}
+		rc = ion_handle_get_flags(client_ctx->user_ion_client,
+					client_ctx->
+					meta_buffer_iommu_ion_handle,
+					&ionflag_iommu);
+		if (rc) {
+			ERR("%s():get_ION_flags fail\n",
+					 __func__);
+			goto import_ion_error;
+		}
+		vcd_meta_buffer->kernel_virt_addr_iommu =
+			(u8 *) ion_map_kernel(
+			client_ctx->user_ion_client,
+			client_ctx->meta_buffer_iommu_ion_handle);
+		if (!vcd_meta_buffer->kernel_virt_addr_iommu) {
+			ERR("%s(): get_ION_kernel virtual addr failed\n",
+				 __func__);
+			goto import_ion_error;
+		}
+		if (res_trk_get_core_type() == (u32)VCD_CORE_720P) {
+			rc = ion_phys(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle,
+				(unsigned long *) (&(vcd_meta_buffer->
+				physical_addr_iommu)), &len_iommu);
+			if (rc) {
+				ERR("%s():get_ION_kernel physical addr fail\n",
+					__func__);
+				goto ion_map_error_iommu;
+			}
+			vcd_meta_buffer->client_data_iommu = NULL;
+			vcd_meta_buffer->dev_addr_iommu = (u8 *)
+				vcd_meta_buffer->physical_addr_iommu;
+		} else {
+			rc = ion_map_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle,
+				VIDEO_DOMAIN, VIDEO_MAIN_POOL,
+				SZ_4K, 0, (unsigned long *)&iova_iommu,
+				(unsigned long *)&buffer_size_iommu,
+				0, 0);
+			if (rc || !iova_iommu) {
+				ERR("%s():get_ION_kernel physical addr fail, "\
+					"rc = %d iova = 0x%lx\n",
+					__func__, rc, iova);
+				goto ion_map_error_iommu;
+			}
+			vcd_meta_buffer->physical_addr_iommu =
+						(u8 *) iova_iommu;
+			vcd_meta_buffer->client_data_iommu = NULL;
+			vcd_meta_buffer->dev_addr_iommu = (u8 *) iova_iommu;
+		}
+	}
+
+	/*fill the meta addr table*/
+	num_buffers = vcd_meta_buffer->count;
+	buf_size = vcd_meta_buffer->size/num_buffers;
+	ker_vir_addr = vcd_meta_buffer->kernel_virtual_addr;
+	ker_vir_addr_iommu = vcd_meta_buffer->kernel_virt_addr_iommu;
+	client_ctx->meta_buf_size = buf_size;
+	for (index = 0; index < num_buffers; index++) {
+		client_ctx->meta_addr_table[index].kernel_vir_addr =
+			ker_vir_addr;
+		client_ctx->meta_addr_table[index].kernel_vir_addr_iommu =
+			ker_vir_addr_iommu;
+		DBG("[%d] kernel_virtual = %p kernel_vir_iommu = %p",
+			index, ker_vir_addr, ker_vir_addr_iommu);
+		ker_vir_addr += buf_size;
+		ker_vir_addr_iommu += buf_size;
+	}
+
+	DBG("Meta Buffer: Virt: %p, Phys %p, fd: %d",
+			vcd_meta_buffer->kernel_virtual_addr,
+			vcd_meta_buffer->physical_addr,
+			vcd_meta_buffer->pmem_fd);
+	DBG("IOMMU Meta Buffer: Virt: %p, Phys %p, fd: %d",
+			vcd_meta_buffer->kernel_virt_addr_iommu,
+			vcd_meta_buffer->physical_addr_iommu,
+			vcd_meta_buffer->pmem_fd_iommu);
+	DBG("Meta_buffer: Dev addr %p", vcd_meta_buffer->dev_addr);
+	DBG("IOMMU Meta_buffer: Dev addr %p",
+			vcd_meta_buffer->dev_addr_iommu);
+	vcd_status = vcd_set_property(client_ctx->vcd_handle,
+					  &vcd_property_hdr,
+					  vcd_meta_buffer);
 
+	if (vcd_status)
+		return false;
+	else
+		return true;
+ion_map_error_iommu:
+	if (vcd_meta_buffer->kernel_virt_addr_iommu) {
+		ion_unmap_kernel(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle);
+		vcd_meta_buffer->kernel_virt_addr_iommu = NULL;
+	}
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_iommu_ion_handle)) {
+		ion_free(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_iommu_ion_handle);
+		 client_ctx->meta_buffer_iommu_ion_handle = NULL;
+	}
+ion_map_error:
+	if (vcd_meta_buffer->kernel_virtual_addr) {
+		ion_unmap_kernel(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle);
+		vcd_meta_buffer->kernel_virtual_addr = NULL;
+	}
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_ion_handle)) {
+		ion_free(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_ion_handle);
+		 client_ctx->meta_buffer_ion_handle = NULL;
+	}
+import_ion_error:
+	return false;
+}
 static u32 vid_dec_set_h264_mv_buffers(struct video_client_ctx *client_ctx,
 					struct vdec_h264_mv *mv_data)
 {
@@ -908,12 +1242,10 @@ static u32 vid_dec_set_h264_mv_buffers(struct video_client_ctx *client_ctx,
 		}
 		vcd_h264_mv_buffer->kernel_virtual_addr = (u8 *) ion_map_kernel(
 			client_ctx->user_ion_client,
-			client_ctx->h264_mv_ion_handle,
-			ionflag);
+			client_ctx->h264_mv_ion_handle);
 		if (!vcd_h264_mv_buffer->kernel_virtual_addr) {
 			ERR("%s(): get_ION_kernel virtual addr failed\n",
 				 __func__);
-			show_mem(SHOW_MEM_FILTER_NODES);
 			goto import_ion_error;
 		}
 		if (res_trk_check_for_sec_session() ||
@@ -936,7 +1268,7 @@ static u32 vid_dec_set_h264_mv_buffers(struct video_client_ctx *client_ctx,
 					VIDEO_DOMAIN, VIDEO_MAIN_POOL,
 					SZ_4K, 0, (unsigned long *)&iova,
 					(unsigned long *)&buffer_size,
-					UNCACHED, 0);
+					0, 0);
 			if (rc || !iova) {
 				ERR(
 				"%s():get_ION_kernel physical addr fail, rc = %d iova = 0x%lx\n",
@@ -1020,6 +1352,65 @@ static u32 vid_dec_get_h264_mv_buffer_size(struct video_client_ctx *client_ctx,
 		return true;
 }
 
+static u32 vid_dec_free_meta_buffers(struct video_client_ctx *client_ctx)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	struct vcd_property_buffer_size meta_buffer_size;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx)
+		return false;
+	if (client_ctx->vcd_meta_buffer.client_data)
+		msm_subsystem_unmap_buffer((struct msm_mapped_buffer *)
+		client_ctx->vcd_meta_buffer.client_data);
+
+	if (client_ctx->vcd_meta_buffer.client_data_iommu)
+		msm_subsystem_unmap_buffer((struct msm_mapped_buffer *)
+		client_ctx->vcd_meta_buffer.client_data_iommu);
+
+	vcd_property_hdr.prop_id = VCD_I_FREE_EXT_METABUFFER;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_buffer_size);
+
+	vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				      &vcd_property_hdr, &meta_buffer_size);
+
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_ion_handle)) {
+		ion_unmap_kernel(client_ctx->user_ion_client,
+					client_ctx->meta_buffer_ion_handle);
+		if (!res_trk_check_for_sec_session() &&
+		   (res_trk_get_core_type() != (u32)VCD_CORE_720P)) {
+			ion_unmap_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle,
+				VIDEO_DOMAIN,
+				VIDEO_MAIN_POOL);
+		}
+		ion_free(client_ctx->user_ion_client,
+					client_ctx->meta_buffer_ion_handle);
+		client_ctx->meta_buffer_ion_handle = NULL;
+	}
+
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_iommu_ion_handle)) {
+		ion_unmap_kernel(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_iommu_ion_handle);
+		if (res_trk_check_for_sec_session() &&
+		   (res_trk_get_core_type() != (u32)VCD_CORE_720P)) {
+			ion_unmap_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle,
+				VIDEO_DOMAIN,
+				VIDEO_MAIN_POOL);
+		}
+		ion_free(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle);
+		client_ctx->meta_buffer_iommu_ion_handle = NULL;
+	}
+
+	if (vcd_status)
+		return false;
+	else
+		return true;
+}
+
+
 static u32 vid_dec_free_h264_mv_buffers(struct video_client_ctx *client_ctx)
 {
 	struct vcd_property_hdr vcd_property_hdr;
@@ -1087,6 +1478,7 @@ static u32 vid_dec_get_buffer_req(struct video_client_ctx *client_ctx,
 		vdec_buf_req->buffer_size = vcd_buf_req.sz;
 		vdec_buf_req->alignment = vcd_buf_req.align;
 		vdec_buf_req->buf_poolid = vcd_buf_req.buf_pool_id;
+		vdec_buf_req->meta_buffer_size = vcd_buf_req.meta_buffer_size;
 
 		return true;
 	}
@@ -1109,7 +1501,7 @@ static u32 vid_dec_set_buffer(struct video_client_ctx *client_ctx,
 		buf_adr_offset = (unsigned long)buffer_info->buffer.offset;
 	}
 	length = buffer_info->buffer.buffer_len;
-	
+	/*If buffer cannot be set, ignore */
 	if (!vidc_insert_addr_table(client_ctx, dir_buffer,
 		(unsigned long)buffer_info->buffer.bufferaddr,
 		&kernel_vaddr, buffer_info->buffer.pmem_fd,
@@ -1145,7 +1537,7 @@ static u32 vid_dec_free_buffer(struct video_client_ctx *client_ctx,
 		buffer = VCD_BUFFER_OUTPUT;
 	}
 
-	
+	/*If buffer NOT set, ignore */
 	if (!vidc_delete_addr_table(client_ctx, dir_buffer,
 				(unsigned long)buffer_info->buffer.bufferaddr,
 				&kernel_vaddr)) {
@@ -1172,11 +1564,11 @@ static u32 vid_dec_pause_resume(struct video_client_ctx *client_ctx, u32 pause)
 	}
 
 	if (pause) {
-		INFO("msm_vidc_dec: PAUSE command from client = %p\n",
+		DBG("msm_vidc_dec: PAUSE command from client = %p\n",
 			 client_ctx);
 		vcd_status = vcd_pause(client_ctx->vcd_handle);
 	} else{
-		INFO("msm_vidc_dec: RESUME command from client = %p\n",
+		DBG("msm_vidc_dec: RESUME command from client = %p\n",
 			 client_ctx);
 		vcd_status = vcd_resume(client_ctx->vcd_handle);
 	}
@@ -1193,7 +1585,7 @@ static u32 vid_dec_start_stop(struct video_client_ctx *client_ctx, u32 start)
 	struct vid_dec_msg *vdec_msg = NULL;
 	u32 vcd_status;
 
-	INFO("msm_vidc_dec: Inside %s()", __func__);
+	DBG("msm_vidc_dec: Inside %s()", __func__);
 	if (!client_ctx) {
 		ERR("\n Invalid client_ctx");
 		return false;
@@ -1201,7 +1593,7 @@ static u32 vid_dec_start_stop(struct video_client_ctx *client_ctx, u32 start)
 
 	if (start) {
 		if (client_ctx->seq_header_set) {
-			INFO("%s(): Seq Hdr set: Send START_DONE to client",
+			DBG("%s(): Seq Hdr set: Send START_DONE to client",
 				 __func__);
 			vdec_msg = kzalloc(sizeof(*vdec_msg), GFP_KERNEL);
 			if (!vdec_msg) {
@@ -1223,7 +1615,7 @@ static u32 vid_dec_start_stop(struct video_client_ctx *client_ctx, u32 start)
 			    client_ctx);
 
 		} else {
-			INFO("%s(): Calling decode_start()", __func__);
+			DBG("%s(): Calling decode_start()", __func__);
 			vcd_status =
 			    vcd_decode_start(client_ctx->vcd_handle, NULL);
 
@@ -1233,6 +1625,8 @@ static u32 vid_dec_start_stop(struct video_client_ctx *client_ctx, u32 start)
 				return false;
 			}
 		}
+
+		client_ctx->stop_called = false;
 	} else {
 		DBG("%s(): Calling vcd_stop()", __func__);
 		mutex_lock(&vid_dec_device_p->lock);
@@ -1259,26 +1653,40 @@ static u32 vid_dec_decode_frame(struct video_client_ctx *client_ctx,
 {
 	struct vcd_frame_data vcd_input_buffer;
 	unsigned long kernel_vaddr, phy_addr, user_vaddr;
+	struct buf_addr_table *buf_addr_table;
 	int pmem_fd;
 	struct file *file;
 	s32 buffer_index = -1;
 	u32 vcd_status = VCD_ERR_FAIL;
 	u32 ion_flag = 0;
+	unsigned long buff_len;
 	struct ion_handle *buff_handle = NULL;
 
 	if (!client_ctx || !input_frame_info)
 		return false;
 
 	user_vaddr = (unsigned long)input_frame_info->bufferaddr;
+	buf_addr_table = client_ctx->input_buf_addr_table;
 
 	if (vidc_lookup_addr_table(client_ctx, BUFFER_TYPE_INPUT,
 				      true, &user_vaddr, &kernel_vaddr,
 				      &phy_addr, &pmem_fd, &file,
 				      &buffer_index)) {
 
-		
+		/* kernel_vaddr  is found. send the frame to VCD */
 		memset((void *)&vcd_input_buffer, 0,
 		       sizeof(struct vcd_frame_data));
+
+		buff_len = buf_addr_table[buffer_index].buff_len;
+		if ((input_frame_info->datalen > buff_len) ||
+					(input_frame_info->offset > buff_len)) {
+			ERR("%s(): offset(%u) or data length(%u) is greater"\
+				" than buffer length(%lu)\n",\
+			__func__, input_frame_info->offset,
+			input_frame_info->datalen, buff_len);
+			return false;
+		}
+
 		vcd_input_buffer.virtual =
 		    (u8 *) (kernel_vaddr + input_frame_info->pmem_offset);
 		vcd_input_buffer.offset = input_frame_info->offset;
@@ -1288,7 +1696,7 @@ static u32 vid_dec_decode_frame(struct video_client_ctx *client_ctx,
 		    (u32) input_frame_info->client_data;
 		vcd_input_buffer.data_len = input_frame_info->datalen;
 		vcd_input_buffer.time_stamp = input_frame_info->timestamp;
-		
+		/* Rely on VCD using the same flags as OMX */
 		vcd_input_buffer.flags = input_frame_info->flags;
 		vcd_input_buffer.desc_buf = desc_buf;
 		vcd_input_buffer.desc_size = desc_size;
@@ -1299,10 +1707,10 @@ static u32 vid_dec_decode_frame(struct video_client_ctx *client_ctx,
 						kernel_vaddr,
 						buffer_index,
 						&buff_handle);
-			if (ion_flag == CACHED && buff_handle) {
+			if (ion_flag == ION_FLAG_CACHED && buff_handle) {
 				msm_ion_do_cache_op(client_ctx->user_ion_client,
 				buff_handle,
-				(unsigned long *)kernel_vaddr,
+				(unsigned long *) NULL,
 				(unsigned long) vcd_input_buffer.data_len,
 				ION_IOC_CLEAN_CACHES);
 			}
@@ -1377,7 +1785,7 @@ static u32 vid_dec_flush(struct video_client_ctx *client_ctx,
 {
 	u32 vcd_status = VCD_ERR_FAIL;
 
-	INFO("msm_vidc_dec: %s() called with dir = %u", __func__,
+	DBG("msm_vidc_dec: %s() called with dir = %u", __func__,
 		 flush_dir);
 	if (!client_ctx) {
 		ERR("\n Invalid client_ctx");
@@ -1523,6 +1931,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_SET_PICRES:
 	{
 		struct vdec_picsize video_resoultion;
+		memset((void *)&video_resoultion, 0,
+			sizeof(struct vdec_picsize));
 		DBG("VDEC_IOCTL_SET_PICRES\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1538,6 +1948,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_GET_PICRES:
 	{
 		struct vdec_picsize video_resoultion;
+		memset((void *)&video_resoultion, 0,
+			sizeof(struct vdec_picsize));
 		DBG("VDEC_IOCTL_GET_PICRES\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1561,6 +1973,10 @@ static long vid_dec_ioctl(struct file *file,
 		struct vdec_allocatorproperty vdec_buf_req;
 		struct vcd_buffer_requirement buffer_req;
 		DBG("VDEC_IOCTL_SET_BUFFER_REQ\n");
+		memset((void *)&vdec_buf_req, 0,
+			sizeof(struct vdec_allocatorproperty));
+		memset((void *)&buffer_req, 0,
+			sizeof(struct vcd_buffer_requirement));
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
 
@@ -1573,6 +1989,19 @@ static long vid_dec_ioctl(struct file *file,
 		buffer_req.max_count = vdec_buf_req.maxcount;
 		buffer_req.min_count = vdec_buf_req.mincount;
 		buffer_req.sz = vdec_buf_req.buffer_size;
+		buffer_req.buf_pool_id = vdec_buf_req.buf_poolid;
+		buffer_req.meta_buffer_size = vdec_buf_req.meta_buffer_size;
+		DBG("SET_BUF_REQ: port = %u, min = %u, max = %u, "\
+			"act = %u, size = %u, align = %u, pool = %u, "\
+			"meta_buf_size = %u",
+			(u32)vdec_buf_req.buffer_type,
+			(u32)buffer_req.min_count,
+			(u32)buffer_req.max_count,
+			(u32)buffer_req.actual_count,
+			(u32)buffer_req.sz,
+			(u32)buffer_req.align,
+			(u32)buffer_req.buf_pool_id,
+			(u32)buffer_req.meta_buffer_size);
 
 		switch (vdec_buf_req.buffer_type) {
 		case VDEC_BUFFER_TYPE_INPUT:
@@ -1597,6 +2026,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_GET_BUFFER_REQ:
 	{
 		struct vdec_allocatorproperty vdec_buf_req;
+		memset((void *)&vdec_buf_req, 0,
+			sizeof(struct vdec_allocatorproperty));
 		DBG("VDEC_IOCTL_GET_BUFFER_REQ\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1605,8 +2036,19 @@ static long vid_dec_ioctl(struct file *file,
 			return -EFAULT;
 
 		result = vid_dec_get_buffer_req(client_ctx, &vdec_buf_req);
-
 		if (result) {
+			DBG("GET_BUF_REQ: port = %u, min = %u, "\
+				"max = %u, act = %u, size = %u, "\
+				"align = %u, pool = %u, "\
+				"meta_buf_size = %u",
+				(u32)vdec_buf_req.buffer_type,
+				(u32)vdec_buf_req.mincount,
+				(u32)vdec_buf_req.maxcount,
+				(u32)vdec_buf_req.actualcount,
+				(u32)vdec_buf_req.buffer_size,
+				(u32)vdec_buf_req.alignment,
+				(u32)vdec_buf_req.buf_poolid,
+				(u32)vdec_buf_req.meta_buffer_size);
 			if (copy_to_user(vdec_msg.out, &vdec_buf_req,
 					sizeof(vdec_buf_req)))
 				return -EFAULT;
@@ -1617,6 +2059,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_SET_BUFFER:
 	{
 		struct vdec_setbuffer_cmd setbuffer;
+		memset((void *)&setbuffer, 0,
+			sizeof(struct vdec_setbuffer_cmd));
 		DBG("VDEC_IOCTL_SET_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1631,6 +2075,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_FREE_BUFFER:
 	{
 		struct vdec_setbuffer_cmd setbuffer;
+		memset((void *)&setbuffer, 0,
+			sizeof(struct vdec_setbuffer_cmd));
 		DBG("VDEC_IOCTL_FREE_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1660,6 +2106,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_CMD_PAUSE:
 	{
+		DBG("VDEC_IOCTL_CMD_PAUSE\n");
 		result = vid_dec_pause_resume(client_ctx, true);
 		if (!result)
 			return -EIO;
@@ -1679,6 +2126,8 @@ static long vid_dec_ioctl(struct file *file,
 		struct vdec_input_frameinfo input_frame_info;
 		u8 *desc_buf = NULL;
 		u32 desc_size = 0;
+		memset((void *)&input_frame_info, 0,
+			sizeof(struct vdec_input_frameinfo));
 		DBG("VDEC_IOCTL_DECODE_FRAME\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1711,14 +2160,35 @@ static long vid_dec_ioctl(struct file *file,
 		}
 		break;
 	}
+	case VDEC_IOCTL_GET_PERF_LEVEL:
+	{
+		u32 curr_perf_level = 0;
+		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
+			return -EFAULT;
+		result = vid_dec_get_curr_perf_level(client_ctx,
+			&curr_perf_level);
+		if (!result) {
+			ERR("get_curr_perf_level failed!!");
+			return -EIO;
+		}
+		DBG("VDEC_IOCTL_GET_PERF_LEVEL %u\n",
+			curr_perf_level);
+		if (copy_to_user(vdec_msg.out,
+			&curr_perf_level, sizeof(u32)))
+			return -EFAULT;
+		break;
+	}
 	case VDEC_IOCTL_SET_PERF_CLK:
 	{
+		DBG("VDEC_IOCTL_SET_PERF_CLK\n");
 		vid_dec_set_turbo_clk(client_ctx);
 		break;
 	}
 	case VDEC_IOCTL_FILL_OUTPUT_BUFFER:
 	{
 		struct vdec_fillbuffer_cmd fill_buffer_cmd;
+		memset((void *)&fill_buffer_cmd, 0,
+			sizeof(struct vdec_fillbuffer_cmd));
 		DBG("VDEC_IOCTL_FILL_OUTPUT_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1748,6 +2218,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_GET_NEXT_MSG:
 	{
 		struct vdec_msginfo vdec_msg_info;
+		memset((void *)&vdec_msg_info, 0,
+			sizeof(struct vdec_msginfo));
 		DBG("VDEC_IOCTL_GET_NEXT_MSG\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1771,6 +2243,10 @@ static long vid_dec_ioctl(struct file *file,
 		struct vdec_seqheader seq_header;
 		struct vcd_sequence_hdr vcd_seq_hdr;
 		unsigned long ionflag;
+		memset((void *)&seq_header, 0,
+			sizeof(struct vdec_seqheader));
+		memset((void *)&vcd_seq_hdr, 0,
+			sizeof(struct vcd_sequence_hdr));
 		DBG("VDEC_IOCTL_SET_SEQUENCE_HEADER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg))) {
 			ERR("Copy from user vdec_msg failed\n");
@@ -1797,7 +2273,7 @@ static long vid_dec_ioctl(struct file *file,
 			client_ctx->seq_hdr_ion_handle = ion_import_dma_buf(
 				client_ctx->user_ion_client,
 				seq_header.pmem_fd);
-			if (!client_ctx->seq_hdr_ion_handle) {
+			if (IS_ERR_OR_NULL(client_ctx->seq_hdr_ion_handle)) {
 				ERR("%s(): get_ION_handle failed\n", __func__);
 				return false;
 			}
@@ -1813,8 +2289,8 @@ static long vid_dec_ioctl(struct file *file,
 			}
 			ker_vaddr = (unsigned long) ion_map_kernel(
 				client_ctx->user_ion_client,
-				client_ctx->seq_hdr_ion_handle, ionflag);
-			if (!ker_vaddr) {
+				client_ctx->seq_hdr_ion_handle);
+			if (IS_ERR_OR_NULL((void *)ker_vaddr)) {
 				ERR("%s():get_ION_kernel virtual addr fail\n",
 							 __func__);
 				ion_free(client_ctx->user_ion_client,
@@ -1857,7 +2333,7 @@ static long vid_dec_ioctl(struct file *file,
 			return -EFAULT;
 		}
 		if (vcd_get_ion_status()) {
-			if (client_ctx->seq_hdr_ion_handle) {
+			if (!IS_ERR_OR_NULL(client_ctx->seq_hdr_ion_handle)) {
 				ion_unmap_kernel(client_ctx->user_ion_client,
 						client_ctx->seq_hdr_ion_handle);
 				ion_free(client_ctx->user_ion_client,
@@ -1878,7 +2354,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_GET_INTERLACE_FORMAT:
 	{
-		u32 progressive_only, interlace_format;
+		u32 progressive_only = 0, interlace_format = 0;
 		DBG("VDEC_IOCTL_GET_INTERLACE_FORMAT\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1896,9 +2372,26 @@ static long vid_dec_ioctl(struct file *file,
 		break;
 	}
 
+	case VDEC_IOCTL_GET_ENABLE_SEC_METADATA:
+	{
+		u32 enable_sec_metadata = 0;
+		DBG("VDEC_IOCTL_GET_ENABLE_SEC_METADATA\n");
+		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
+			return -EFAULT;
+		result = vid_dec_get_enable_secure_metadata(client_ctx,
+					&enable_sec_metadata);
+		if (result) {
+			if (copy_to_user(vdec_msg.out, &enable_sec_metadata,
+					sizeof(u32)))
+				return -EFAULT;
+		} else
+			return -EIO;
+		break;
+	}
+
 	case VDEC_IOCTL_GET_DISABLE_DMX_SUPPORT:
 	{
-		u32 disable_dmx;
+		u32 disable_dmx = 0;
 		DBG("VDEC_IOCTL_GET_DISABLE_DMX_SUPPORT\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1914,7 +2407,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_GET_DISABLE_DMX:
 	{
-		u32 disable_dmx;
+		u32 disable_dmx = 0;
 		DBG("VDEC_IOCTL_GET_DISABLE_DMX\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1939,7 +2432,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_SET_PICTURE_ORDER:
 	{
-		u32 picture_order;
+		u32 picture_order = 0;
 		DBG("VDEC_IOCTL_SET_PICTURE_ORDER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1954,6 +2447,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_SET_FRAME_RATE:
 	{
 		struct vdec_framerate frame_rate;
+		memset((void *)&frame_rate, 0,
+			sizeof(struct vdec_framerate));
 		DBG("VDEC_IOCTL_SET_FRAME_RATE\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1967,7 +2462,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_SET_EXTRADATA:
 	{
-		u32 extradata_flag;
+		u32 extradata_flag = 0;
 		DBG("VDEC_IOCTL_SET_EXTRADATA\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1979,9 +2474,43 @@ static long vid_dec_ioctl(struct file *file,
 			return -EIO;
 		break;
 	}
+	case VDEC_IOCTL_SET_META_BUFFERS:
+	{
+		struct vdec_meta_buffers meta_buffers;
+		memset((void *)&meta_buffers, 0,
+			sizeof(struct vdec_meta_buffers));
+		DBG("VDEC_IOCTL_SET_META_BUFFERS\n");
+		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
+			return -EFAULT;
+		if (copy_from_user(&meta_buffers, vdec_msg.in,
+						   sizeof(meta_buffers)))
+			return -EFAULT;
+		if (res_trk_get_enable_sec_metadata())
+			result =
+			vid_dec_set_meta_buffers(client_ctx, &meta_buffers);
+		else
+			ERR("ERROR : Meta data is not enabled.\n");
+
+		if (!result)
+			return -EIO;
+		break;
+	}
+	case VDEC_IOCTL_FREE_META_BUFFERS:
+	{
+		DBG("VDEC_IOCTL_FREE_META_BUFFERS\n");
+		if (res_trk_get_enable_sec_metadata())
+			result = vid_dec_free_meta_buffers(client_ctx);
+		else
+			ERR("ERROR : Can't free. Meta data is not enabled.\n");
+		if (!result)
+			return -EIO;
+		break;
+	}
 	case VDEC_IOCTL_SET_H264_MV_BUFFER:
 	{
 		struct vdec_h264_mv mv_data;
+		memset((void *)&mv_data, 0,
+			sizeof(struct vdec_h264_mv));
 		DBG("VDEC_IOCTL_SET_H264_MV_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2005,6 +2534,8 @@ static long vid_dec_ioctl(struct file *file,
 	case VDEC_IOCTL_GET_MV_BUFFER_SIZE:
 	{
 		struct vdec_mv_buff_size mv_buff;
+		memset((void *)&mv_buff, 0,
+			sizeof(struct vdec_mv_buff_size));
 		DBG("VDEC_IOCTL_GET_MV_BUFFER_SIZE\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2025,6 +2556,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_SET_IDR_ONLY_DECODING:
 	{
+		DBG("VDEC_IOCTL_SET_IDR_ONLY_DECODING\n");
 		result = vid_dec_set_idr_only_decoding(client_ctx);
 		if (!result)
 			return -EIO;
@@ -2032,6 +2564,7 @@ static long vid_dec_ioctl(struct file *file,
 	}
 	case VDEC_IOCTL_SET_CONT_ON_RECONFIG:
 	{
+		DBG("VDEC_IOCTL_SET_CONT_ON_RECONFIG\n");
 		result = vid_dec_set_cont_on_reconfig(client_ctx);
 		if (!result)
 			return -EIO;
@@ -2051,7 +2584,7 @@ static u32 vid_dec_close_client(struct video_client_ctx *client_ctx)
 	struct vid_dec_msg *vdec_msg;
 	u32 vcd_status;
 
-	INFO("msm_vidc_dec: Inside %s()", __func__);
+	DBG("msm_vidc_dec: Inside %s()", __func__);
 	if (!client_ctx || (!client_ctx->vcd_handle)) {
 		ERR("\n Invalid client_ctx");
 		return false;
@@ -2116,7 +2649,7 @@ int vid_dec_open_client(struct video_client_ctx **vid_clnt_ctx, int flags)
 	}
 
 	client_index = vid_dec_get_empty_client_index();
-	if (client_index == -1) {
+	if (client_index < 0) {
 		ERR("%s() : No free clients client_index == -1\n", __func__);
 		rc = -ENOMEM;
 		goto client_failure;
@@ -2162,7 +2695,7 @@ int vid_dec_open_client(struct video_client_ctx **vid_clnt_ctx, int flags)
 
 static int vid_dec_open_secure(struct inode *inode, struct file *file)
 {
-	int rc = 0;
+	int rc = 0, close_client = 0;
 	struct video_client_ctx *client_ctx;
 	mutex_lock(&vid_dec_device_p->lock);
 	rc = vid_dec_open_client(&client_ctx, VCD_CP_SESSION);
@@ -2176,6 +2709,9 @@ static int vid_dec_open_secure(struct inode *inode, struct file *file)
 	file->private_data = client_ctx;
 	if (res_trk_open_secure_session()) {
 		ERR("Secure session operation failure\n");
+		close_client = 1;
+		client_ctx->stop_called = 1;
+		client_ctx->stop_sync_cb = 1;
 		rc = -EACCES;
 		goto error;
 	}
@@ -2183,6 +2719,8 @@ static int vid_dec_open_secure(struct inode *inode, struct file *file)
 	return 0;
 error:
 	mutex_unlock(&vid_dec_device_p->lock);
+	if (close_client)
+		vid_dec_close_client(client_ctx);
 	return rc;
 }
 
@@ -2278,8 +2816,8 @@ static int vid_dec_vcd_init(void)
 	struct vcd_init_config vcd_init_config;
 	u32 i;
 
-	
-	INFO("msm_vidc_dec: Inside %s()", __func__);
+	/* init_timer(&hw_timer); */
+	DBG("msm_vidc_dec: Inside %s()", __func__);
 	vid_dec_device_p->num_clients = 0;
 
 	for (i = 0; i < VIDC_MAX_NUM_CLIENTS; i++) {
@@ -2321,7 +2859,7 @@ static int __init vid_dec_init(void)
 	int rc = 0, i = 0, j = 0;
 	struct device *class_devp;
 
-	INFO("msm_vidc_dec: Inside %s()", __func__);
+	DBG("msm_vidc_dec: Inside %s()", __func__);
 	vid_dec_device_p = kzalloc(sizeof(struct vid_dec_dev), GFP_KERNEL);
 	if (!vid_dec_device_p) {
 		ERR("%s Unable to allocate memory for vid_dec_dev\n",
@@ -2373,8 +2911,8 @@ static int __init vid_dec_init(void)
 			goto error_vid_dec_cdev_add;
 		}
 	}
-	vid_dec_vcd_init();
-	return 0;
+	rc = vid_dec_vcd_init();
+	return rc;
 
 error_vid_dec_cdev_add:
 	for (j = i-1; j >= 0; j--)
@@ -2399,7 +2937,7 @@ static void __exit vid_dec_exit(void)
 	class_destroy(vid_dec_class);
 	unregister_chrdev_region(vid_dec_dev_num, NUM_OF_DRIVER_NODES);
 	kfree(vid_dec_device_p);
-	INFO("msm_vidc_dec: Return from %s()", __func__);
+	DBG("msm_vidc_dec: Return from %s()", __func__);
 }
 
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/msm/vidc/common/dec/vdec_internal.h b/drivers/video/msm/vidc/common/dec/vdec_internal.h
index 89da9a2..a7a32a5 100644
--- a/drivers/video/msm/vidc/common/dec/vdec_internal.h
+++ b/drivers/video/msm/vidc/common/dec/vdec_internal.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, 2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/common/enc/venc.c b/drivers/video/msm/vidc/common/enc/venc.c
index 75e14ce..591126c 100644
--- a/drivers/video/msm/vidc/common/enc/venc.c
+++ b/drivers/video/msm/vidc/common/enc/venc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,22 +35,22 @@
 #include "vcd_res_tracker_api.h"
 
 #define VID_ENC_NAME	"msm_vidc_enc"
+static char *node_name[2] = {"", "_sec"};
 
-extern u32 vidc_msg_debug;
-#define DBG(x...)				\
-	if (vidc_msg_debug) {			\
-		printk(KERN_DEBUG "[VID] " x);	\
-	}
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
 
-#define INFO(x...) printk(KERN_INFO "[VID] " x)
-#define ERR(x...) printk(KERN_ERR "[VID] " x)
+#define INFO(x...) printk(KERN_INFO x)
+#define ERR(x...) printk(KERN_ERR x)
 
 static struct vid_enc_dev *vid_enc_device_p;
 static dev_t vid_enc_dev_num;
 static struct class *vid_enc_class;
 static long vid_enc_ioctl(struct file *file,
 	unsigned cmd, unsigned long arg);
-static int stop_cmd;
 
 static s32 vid_enc_get_empty_client_index(void)
 {
@@ -74,29 +74,6 @@ static s32 vid_enc_get_empty_client_index(void)
 	}
 }
 
-static u32 vid_enc_set_turbo_clk(struct video_client_ctx *client_ctx)
-{
-    struct vcd_property_hdr vcd_property_hdr;
-    u32 vcd_status = VCD_ERR_FAIL;
-    u32 dummy = 0;
-    if (!client_ctx)
-      return false;
-
-    vcd_property_hdr.prop_id = VCD_I_SET_TURBO_CLK;
-    vcd_property_hdr.sz = sizeof(struct vcd_property_frame_size);
-    vcd_status = vcd_set_property(client_ctx->vcd_handle,
-                                &vcd_property_hdr, &dummy);
-
-    if (vcd_status)
-    {
-      pr_err("\n %s: set turbo mode failed\n", __FUNCTION__);
-      return false;
-    }
-    else
-    {
-      return true;
-    }
-}
 
 u32 vid_enc_get_status(u32 status)
 {
@@ -241,15 +218,15 @@ static void vid_enc_output_frame_done(struct video_client_ctx *client_ctx,
 
 	switch (event) {
 	case VCD_EVT_RESP_OUTPUT_DONE:
-	   DBG("Send INPUT_DON message to client = %p\n",
+	   DBG("Send OUTPUT_DON message to client = %p\n",
 			client_ctx);
 	   break;
 	case VCD_EVT_RESP_OUTPUT_FLUSHED:
-	   DBG("Send INPUT_FLUSHED message to client = %p\n",
+	   DBG("Send OUTPUT_FLUSHED message to client = %p\n",
 		   client_ctx);
 	   break;
 	default:
-	   ERR("QVD: vid_enc_output_frame_done invalid cmd type: %d\n", event);
+	   ERR("vid_enc_output_frame_done invalid cmd type: %d\n", event);
 	   venc_msg->venc_msg_info.statuscode = VEN_S_EFATAL;
 	   break;
 	}
@@ -262,23 +239,32 @@ static void vid_enc_output_frame_done(struct video_client_ctx *client_ctx,
 		&phy_addr, &pmem_fd, &file,
 		&buffer_index)) {
 
-		
+		/* Buffer address in user space */
 		venc_msg->venc_msg_info.buf.ptrbuffer =	(u8 *) user_vaddr;
-		
+		/* Buffer address in user space */
 		venc_msg->venc_msg_info.buf.clientdata = (void *)
 		vcd_frame_data->frm_clnt_data;
-		
+		/* Data length */
 		venc_msg->venc_msg_info.buf.len =
 			vcd_frame_data->data_len;
 		venc_msg->venc_msg_info.buf.flags =
 			vcd_frame_data->flags;
-		
+		/* Timestamp pass-through from input frame */
 		venc_msg->venc_msg_info.buf.timestamp =
 			vcd_frame_data->time_stamp;
 		venc_msg->venc_msg_info.buf.sz =
 			vcd_frame_data->alloc_len;
-
-		
+		/* Metadata length */
+		venc_msg->venc_msg_info.buf.metadata_len =
+			vcd_frame_data->metadata_len;
+		/* Metadata offset */
+		venc_msg->venc_msg_info.buf.metadata_offset =
+			vcd_frame_data->metadata_offset;
+		/* Current ltr id */
+		venc_msg->venc_msg_info.buf.metadata_ltrid =
+			vcd_frame_data->curr_ltr_id;
+
+		/* Decoded picture width and height */
 		venc_msg->venc_msg_info.msgdata_size =
 			sizeof(struct venc_buffer);
 	} else {
@@ -290,10 +276,10 @@ static void vid_enc_output_frame_done(struct video_client_ctx *client_ctx,
 		ion_flag = vidc_get_fd_info(client_ctx, BUFFER_TYPE_OUTPUT,
 					pmem_fd, kernel_vaddr, buffer_index,
 					&buff_handle);
-		if (ion_flag == CACHED && buff_handle) {
+		if (ion_flag == ION_FLAG_CACHED && buff_handle) {
 			msm_ion_do_cache_op(client_ctx->user_ion_client,
 				buff_handle,
-				(unsigned long *) kernel_vaddr,
+				(unsigned long *) NULL,
 				(unsigned long)venc_msg->venc_msg_info.buf.sz,
 				ION_IOC_CLEAN_INV_CACHES);
 		}
@@ -327,39 +313,46 @@ static void vid_enc_lean_event(struct video_client_ctx *client_ctx,
 
 	switch (event) {
 	case VCD_EVT_RESP_FLUSH_INPUT_DONE:
-		INFO(" msm_vidc_enc: Sending VCD_EVT_RESP_FLUSH_INPUT_DONE"
+		INFO("\n msm_vidc_enc: Sending VCD_EVT_RESP_FLUSH_INPUT_DONE"
 			 " to client");
 		venc_msg->venc_msg_info.msgcode =
 			VEN_MSG_FLUSH_INPUT_DONE;
 		break;
 	case VCD_EVT_RESP_FLUSH_OUTPUT_DONE:
-		INFO(" msm_vidc_enc: Sending VCD_EVT_RESP_FLUSH_OUTPUT_DONE"
+		INFO("\n msm_vidc_enc: Sending VCD_EVT_RESP_FLUSH_OUTPUT_DONE"
 			 " to client");
 		venc_msg->venc_msg_info.msgcode =
 			VEN_MSG_FLUSH_OUPUT_DONE;
 		break;
 
 	case VCD_EVT_RESP_START:
-		INFO(" msm_vidc_enc: Sending VCD_EVT_RESP_START"
+		INFO("\n msm_vidc_enc: Sending VCD_EVT_RESP_START"
 			 " to client");
 		venc_msg->venc_msg_info.msgcode =
 			VEN_MSG_START;
 		break;
 
 	case VCD_EVT_RESP_STOP:
-		INFO(" msm_vidc_enc: Sending VCD_EVT_RESP_STOP"
+		INFO("\n msm_vidc_enc: Sending VCD_EVT_RESP_STOP"
 			 " to client");
 		venc_msg->venc_msg_info.msgcode =
 			VEN_MSG_STOP;
 		break;
 
 	case VCD_EVT_RESP_PAUSE:
-		INFO(" msm_vidc_enc: Sending VCD_EVT_RESP_PAUSE"
+		INFO("\n msm_vidc_enc: Sending VCD_EVT_RESP_PAUSE"
 			 " to client");
 		venc_msg->venc_msg_info.msgcode =
 			VEN_MSG_PAUSE;
 		break;
 
+	case VCD_EVT_IND_INFO_LTRUSE_FAILED:
+		INFO("\n msm_vidc_enc: Sending VEN_MSG_LTRUSE_FAILED"\
+			" to client");
+		venc_msg->venc_msg_info.msgcode =
+			VEN_MSG_LTRUSE_FAILED;
+		break;
+
 	default:
 		ERR("%s() : unknown event type %u\n",
 			__func__, event);
@@ -417,6 +410,7 @@ void vid_enc_vcd_cb(u32 event, u32 status,
 	case VCD_EVT_IND_OUTPUT_RECONFIG:
 	case VCD_EVT_IND_HWERRFATAL:
 	case VCD_EVT_IND_RESOURCES_LOST:
+	case VCD_EVT_IND_INFO_LTRUSE_FAILED:
 		vid_enc_lean_event(client_ctx, event, status);
 		break;
 
@@ -443,10 +437,9 @@ static u32 vid_enc_msg_pending(struct video_client_ctx *client_ctx)
 				__func__);
 			return client_ctx->stop_msg;
 		}
-	} else {
+	} else
 		DBG("%s(): vid_enc msg queue Not empty\n",
 			__func__);
-		}
 
 	return !islist_empty;
 }
@@ -492,7 +485,7 @@ static u32 vid_enc_close_client(struct video_client_ctx *client_ctx)
 	u32 vcd_status;
 	int rc;
 
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
 	if (!client_ctx || (!client_ctx->vcd_handle)) {
 		ERR("\n %s(): Invalid client_ctx", __func__);
 		return false;
@@ -500,7 +493,7 @@ static u32 vid_enc_close_client(struct video_client_ctx *client_ctx)
 
 	mutex_lock(&vid_enc_device_p->lock);
 
-	if (!stop_cmd) {
+	if (!client_ctx->stop_called) {
 		vcd_status = vcd_stop(client_ctx->vcd_handle);
 		DBG("Waiting for VCD_STOP: Before Timeout\n");
 		if (!vcd_status) {
@@ -537,51 +530,50 @@ static u32 vid_enc_close_client(struct video_client_ctx *client_ctx)
 		sizeof(struct video_client_ctx));
 
 	vid_enc_device_p->num_clients--;
-	stop_cmd = 0;
+	client_ctx->stop_called = 0;
 	mutex_unlock(&vid_enc_device_p->lock);
 	return true;
 }
 
-
-static int vid_enc_open(struct inode *inode, struct file *file)
+static int vid_enc_open_client(struct video_client_ctx **vid_clnt_ctx,
+							   int flags)
 {
 	s32 client_index;
 	struct video_client_ctx *client_ctx;
 	int rc = 0;
 	u8 client_count = 0;
 
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
-
-	mutex_lock(&vid_enc_device_p->lock);
-
-	stop_cmd = 0;
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
+	if (!vid_clnt_ctx) {
+		ERR("Invalid input\n");
+		rc = -EINVAL;
+		goto client_failure;
+	}
+	*vid_clnt_ctx = NULL;
 	client_count = vcd_get_num_of_clients();
 	if (client_count == VIDC_MAX_NUM_CLIENTS) {
-		ERR("ERROR : vid_enc_open() max number of clients"
-		    "limit reached\n");
-		mutex_unlock(&vid_enc_device_p->lock);
-		return -ENODEV;
+		ERR("ERROR : vid_enc_open() max number of clients\n");
+		rc = -ENODEV;
+		goto client_failure;
 	}
 
 	DBG(" Virtual Address of ioremap is %p\n", vid_enc_device_p->virt_base);
 	if (!vid_enc_device_p->num_clients) {
-		if (!vidc_load_firmware())
-			return -ENODEV;
+		if (!vidc_load_firmware()) {
+			rc = -ENODEV;
+			goto client_failure;
+		}
 	}
 
 	client_index = vid_enc_get_empty_client_index();
 
-	if (client_index == -1) {
+	if (client_index < 0) {
 		ERR("%s() : No free clients client_index == -1\n",
 			__func__);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto client_failure;
 	}
 
-	
-	if (client_index == -ENOMEM)
-		return -ENOMEM;
-	
-
 	client_ctx =
 		&vid_enc_device_p->venc_clients[client_index];
 	vid_enc_device_p->num_clients++;
@@ -595,27 +587,46 @@ static int vid_enc_open(struct inode *inode, struct file *file)
 		client_ctx->user_ion_client = vcd_get_ion_client();
 		if (!client_ctx->user_ion_client) {
 			ERR("vcd_open ion get client failed");
-			return -EFAULT;
+			rc = -EFAULT;
+			goto client_failure;
 		}
 	}
 	rc = vcd_open(vid_enc_device_p->device_handle, false,
-		vid_enc_vcd_cb, client_ctx, 0);
+		vid_enc_vcd_cb, client_ctx, flags);
 	client_ctx->stop_msg = 0;
+	client_ctx->stop_called = 1;
 
 	if (!rc) {
 		wait_for_completion(&client_ctx->event);
 		if (client_ctx->event_status) {
 			ERR("callback for vcd_open returned error: %u",
 				client_ctx->event_status);
-			mutex_unlock(&vid_enc_device_p->lock);
-			return -EFAULT;
+			rc =  -EFAULT;
+			goto client_failure;
 		}
 	} else {
 		ERR("vcd_open returned error: %u", rc);
-		mutex_unlock(&vid_enc_device_p->lock);
-		return rc;
+		goto client_failure;
 	}
-	file->private_data = client_ctx;
+	*vid_clnt_ctx = client_ctx;
+client_failure:
+	return rc;
+}
+static int vid_enc_open(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	struct video_client_ctx *client_ctx = NULL;
+	INFO("msm_vidc_venc: Inside %s()", __func__);
+	mutex_lock(&vid_enc_device_p->lock);
+	rc = vid_enc_open_client(&client_ctx, 0);
+	if (rc)
+		pr_err("%s() open failed rc=%d\n", __func__, rc);
+	else if (!client_ctx) {
+		pr_err("%s() client_ctx is NULL\n", __func__);
+		rc = -ENOMEM;
+	}
+	if (!rc)
+		file->private_data = client_ctx;
 	mutex_unlock(&vid_enc_device_p->lock);
 	return rc;
 }
@@ -623,21 +634,73 @@ static int vid_enc_open(struct inode *inode, struct file *file)
 static int vid_enc_release(struct inode *inode, struct file *file)
 {
 	struct video_client_ctx *client_ctx = file->private_data;
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
+	vidc_cleanup_addr_table(client_ctx, BUFFER_TYPE_OUTPUT);
+	vidc_cleanup_addr_table(client_ctx, BUFFER_TYPE_INPUT);
 	vid_enc_close_client(client_ctx);
 	vidc_release_firmware();
 #ifndef USE_RES_TRACKER
 	vidc_disable_clk();
 #endif
-	INFO(" msm_vidc_enc: Return from %s()", __func__);
+	INFO("\n msm_vidc_enc: Return from %s()", __func__);
 	return 0;
 }
+static int vid_enc_open_secure(struct inode *inode, struct file *file)
+{
+	int rc = 0, vcd_status = 0;
+	struct video_client_ctx *client_ctx = NULL;
+	struct vcd_property_hdr vcd_property_hdr;
+	struct vcd_property_sps_pps_for_idr_enable idr_enable;
+
+	INFO("msm_vidc_enc: Inside %s()", __func__);
+	mutex_lock(&vid_enc_device_p->lock);
+	rc = vid_enc_open_client(&client_ctx, VCD_CP_SESSION);
+	if (rc || !client_ctx) {
+		pr_err("%s() open failed rc=%d\n", __func__, rc);
+		if (!client_ctx)
+			rc = -ENOMEM;
+		goto error;
+	}
+	file->private_data = client_ctx;
+	vcd_property_hdr.prop_id = VCD_I_ENABLE_SPS_PPS_FOR_IDR;
+	vcd_property_hdr.sz =
+		sizeof(struct vcd_property_sps_pps_for_idr_enable);
+	idr_enable.sps_pps_for_idr_enable_flag = 1;
+	vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				&vcd_property_hdr, &idr_enable);
+	if (vcd_status) {
+		ERR("Setting SPS with IDR failed\n");
+		rc = -EACCES;
+		goto close_client;
+	}
 
-static const struct file_operations vid_enc_fops = {
-	.owner = THIS_MODULE,
-	.open = vid_enc_open,
-	.release = vid_enc_release,
-	.unlocked_ioctl = vid_enc_ioctl,
+	if (res_trk_open_secure_session()) {
+		rc = -EACCES;
+		goto close_client;
+	}
+	mutex_unlock(&vid_enc_device_p->lock);
+	return rc;
+
+close_client:
+	vid_enc_close_client(client_ctx);
+	ERR("Secure session operation failure\n");
+error:
+	mutex_unlock(&vid_enc_device_p->lock);
+	return rc;
+}
+static const struct file_operations vid_enc_fops[NUM_OF_DRIVER_NODES] = {
+	{
+		.owner = THIS_MODULE,
+		.open = vid_enc_open,
+		.release = vid_enc_release,
+		.unlocked_ioctl = vid_enc_ioctl,
+	},
+	{
+		.owner = THIS_MODULE,
+		.open = vid_enc_open_secure,
+		.release = vid_enc_release,
+		.unlocked_ioctl = vid_enc_ioctl,
+	},
 };
 
 void vid_enc_interrupt_deregister(void)
@@ -663,7 +726,7 @@ static int vid_enc_vcd_init(void)
 	struct vcd_init_config vcd_init_config;
 	u32 i;
 
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
 	vid_enc_device_p->num_clients = 0;
 
 	for (i = 0; i < VIDC_MAX_NUM_CLIENTS; i++) {
@@ -702,10 +765,10 @@ static int vid_enc_vcd_init(void)
 
 static int __init vid_enc_init(void)
 {
-	int rc = 0;
+	int rc = 0, i = 0, j = 0;
 	struct device *class_devp;
 
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
 	vid_enc_device_p = kzalloc(sizeof(struct vid_enc_dev),
 					 GFP_KERNEL);
 	if (!vid_enc_device_p) {
@@ -713,14 +776,13 @@ static int __init vid_enc_init(void)
 			__func__);
 		return -ENOMEM;
 	}
-
-	rc = alloc_chrdev_region(&vid_enc_dev_num, 0, 1, VID_ENC_NAME);
+	rc = alloc_chrdev_region(&vid_enc_dev_num, 0, NUM_OF_DRIVER_NODES,
+			VID_ENC_NAME);
 	if (rc < 0) {
 		ERR("%s: alloc_chrdev_region Failed rc = %d\n",
 			__func__, rc);
 		goto error_vid_enc_alloc_chrdev_region;
 	}
-
 	vid_enc_class = class_create(THIS_MODULE, VID_ENC_NAME);
 	if (IS_ERR(vid_enc_class)) {
 		rc = PTR_ERR(vid_enc_class);
@@ -728,32 +790,40 @@ static int __init vid_enc_init(void)
 			__func__, rc);
 		goto error_vid_enc_class_create;
 	}
+	for (i = 0; i < NUM_OF_DRIVER_NODES; i++) {
+		class_devp = device_create(vid_enc_class, NULL,
+					(vid_enc_dev_num + i), NULL,
+					VID_ENC_NAME "%s", node_name[i]);
 
-	class_devp = device_create(vid_enc_class, NULL,
-				vid_enc_dev_num, NULL, VID_ENC_NAME);
-
-	if (IS_ERR(class_devp)) {
-		rc = PTR_ERR(class_devp);
-		ERR("%s: class device_create failed %d\n",
-		__func__, rc);
-		goto error_vid_enc_class_device_create;
-	}
+		if (IS_ERR(class_devp)) {
+			rc = PTR_ERR(class_devp);
+			ERR("%s: class device_create failed %d\n",
+			__func__, rc);
+			if (!i)
+				goto error_vid_enc_class_device_create;
+			else
+				goto error_vid_enc_cdev_add;
+		}
 
-	vid_enc_device_p->device = class_devp;
+		vid_enc_device_p->device[i] = class_devp;
 
-	cdev_init(&vid_enc_device_p->cdev, &vid_enc_fops);
-	vid_enc_device_p->cdev.owner = THIS_MODULE;
-	rc = cdev_add(&(vid_enc_device_p->cdev), vid_enc_dev_num, 1);
+		cdev_init(&vid_enc_device_p->cdev[i], &vid_enc_fops[i]);
+		vid_enc_device_p->cdev[i].owner = THIS_MODULE;
+		rc = cdev_add(&(vid_enc_device_p->cdev[i]),
+					 (vid_enc_dev_num + i), 1);
 
-	if (rc < 0) {
-		ERR("%s: cdev_add failed %d\n",
-		__func__, rc);
-		goto error_vid_enc_cdev_add;
+		if (rc < 0) {
+			ERR("%s: cdev_add failed %d\n",
+			__func__, rc);
+			goto error_vid_enc_cdev_add;
+		}
 	}
-	vid_enc_vcd_init();
-	return 0;
+	rc = vid_enc_vcd_init();
+	return rc;
 
 error_vid_enc_cdev_add:
+	for (j = i-1; j >= 0; j--)
+		cdev_del(&(vid_enc_device_p->cdev[j]));
 	device_destroy(vid_enc_class, vid_enc_dev_num);
 error_vid_enc_class_device_create:
 	class_destroy(vid_enc_class);
@@ -767,13 +837,15 @@ static int __init vid_enc_init(void)
 
 static void __exit vid_enc_exit(void)
 {
-	INFO(" msm_vidc_enc: Inside %s()", __func__);
-	cdev_del(&(vid_enc_device_p->cdev));
+	int i = 0;
+	INFO("\n msm_vidc_enc: Inside %s()", __func__);
+	for (i = 0; i < NUM_OF_DRIVER_NODES; i++)
+		cdev_del(&(vid_enc_device_p->cdev[i]));
 	device_destroy(vid_enc_class, vid_enc_dev_num);
 	class_destroy(vid_enc_class);
 	unregister_chrdev_region(vid_enc_dev_num, 1);
 	kfree(vid_enc_device_p);
-	INFO(" msm_vidc_enc: Return from %s()", __func__);
+	INFO("\n msm_vidc_enc: Return from %s()", __func__);
 }
 static long vid_enc_ioctl(struct file *file,
 		unsigned cmd, unsigned long u_arg)
@@ -796,6 +868,7 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_CMD_READ_NEXT_MSG:
 	{
 		struct venc_msg cb_msg;
+		memset((void *)&cb_msg, 0, sizeof(struct venc_msg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_CMD_READ_NEXT_MSG\n");
@@ -817,6 +890,7 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_CMD_FILL_OUTPUT_BUFFER:
 	{
 		struct venc_buffer enc_buffer;
+		memset((void *)&enc_buffer, 0, sizeof(struct venc_buffer));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_CMD_ENCODE_FRAME"
@@ -842,6 +916,8 @@ static long vid_enc_ioctl(struct file *file,
 	{
 		enum venc_buffer_dir buffer_dir;
 		struct venc_bufferpayload buffer_info;
+		memset((void *)&buffer_info, 0,
+			sizeof(struct venc_bufferpayload));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_SET_INPUT_BUFFER/VEN_IOCTL_SET_OUTPUT_BUFFER\n");
@@ -865,6 +941,8 @@ static long vid_enc_ioctl(struct file *file,
 	{
 		enum venc_buffer_dir buffer_dir;
 		struct venc_bufferpayload buffer_info;
+		memset((void *)&buffer_info, 0,
+			sizeof(struct venc_bufferpayload));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -892,6 +970,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_SET_OUTPUT_BUFFER_REQ:
 	{
 		struct venc_allocatorproperty allocatorproperty;
+		memset((void *)&allocatorproperty, 0,
+			sizeof(struct venc_allocatorproperty));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -919,6 +999,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_OUTPUT_BUFFER_REQ:
 	{
 		struct venc_allocatorproperty allocatorproperty;
+		memset((void *)&allocatorproperty, 0,
+			sizeof(struct venc_allocatorproperty));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -941,6 +1023,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_CMD_FLUSH:
 	{
 		struct venc_bufferflush bufferflush;
+		memset((void *)&bufferflush, 0,
+			sizeof(struct venc_bufferflush));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -948,7 +1032,7 @@ static long vid_enc_ioctl(struct file *file,
 		if (copy_from_user(&bufferflush, venc_msg.in,
 			sizeof(bufferflush)))
 			return -EFAULT;
-		INFO(" %s(): Calling vid_enc_flush with mode = %lu",
+		INFO("\n %s(): Calling vid_enc_flush with mode = %lu",
 			 __func__, bufferflush.flush_mode);
 		result = vid_enc_flush(client_ctx, &bufferflush);
 
@@ -960,28 +1044,29 @@ static long vid_enc_ioctl(struct file *file,
 	}
 	case VEN_IOCTL_CMD_START:
 	{
-		INFO(" %s(): Executing VEN_IOCTL_CMD_START", __func__);
+		INFO("\n %s(): Executing VEN_IOCTL_CMD_START", __func__);
 		result = vid_enc_start_stop(client_ctx, true);
 		if (!result) {
 			ERR("setting VEN_IOCTL_CMD_START failed\n");
 			return -EIO;
-		}
+		} else
+			client_ctx->stop_called = 0;
 		break;
 	}
 	case VEN_IOCTL_CMD_STOP:
 	{
-		INFO(" %s(): Executing VEN_IOCTL_CMD_STOP", __func__);
+		INFO("\n %s(): Executing VEN_IOCTL_CMD_STOP", __func__);
 		result = vid_enc_start_stop(client_ctx, false);
 		if (!result) {
 			ERR("setting VEN_IOCTL_CMD_STOP failed\n");
 			return -EIO;
 		}
-		stop_cmd = 1;
+		client_ctx->stop_called = 1;
 		break;
 	}
 	case VEN_IOCTL_CMD_PAUSE:
 	{
-		INFO(" %s(): Executing VEN_IOCTL_CMD_PAUSE", __func__);
+		INFO("\n %s(): Executing VEN_IOCTL_CMD_PAUSE", __func__);
 		result = vid_enc_pause_resume(client_ctx, true);
 		if (!result) {
 			ERR("setting VEN_IOCTL_CMD_PAUSE failed\n");
@@ -991,7 +1076,7 @@ static long vid_enc_ioctl(struct file *file,
 	}
 	case VEN_IOCTL_CMD_RESUME:
 	{
-		INFO(" %s(): Executing VEN_IOCTL_CMD_RESUME", __func__);
+		INFO("\n %s(): Executing VEN_IOCTL_CMD_RESUME", __func__);
 		result = vid_enc_pause_resume(client_ctx, false);
 		if (!result) {
 			ERR("setting VEN_IOCTL_CMD_RESUME failed\n");
@@ -1002,6 +1087,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_SET_RECON_BUFFER:
 	{
 		struct venc_recon_addr venc_recon;
+		memset((void *)&venc_recon, 0,
+			sizeof(struct venc_recon_addr));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_SET_RECON_BUFFER\n");
@@ -1019,6 +1106,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_FREE_RECON_BUFFER:
 	{
 		struct venc_recon_addr venc_recon;
+		memset((void *)&venc_recon, 0,
+			sizeof(struct venc_recon_addr));
 		DBG("VEN_IOCTL_FREE_RECON_BUFFER\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1036,6 +1125,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_RECON_BUFFER_SIZE:
 	{
 		struct venc_recon_buff_size venc_recon_size;
+		memset((void *)&venc_recon_size, 0,
+			sizeof(struct venc_recon_buff_size));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_GET_RECON_BUFFER_SIZE\n");
@@ -1059,6 +1150,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_QP_RANGE:
 	{
 		struct venc_qprange qprange;
+		memset((void *)&qprange, 0,
+			sizeof(struct venc_qprange));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_G(S)ET_QP_RANGE\n");
@@ -1087,6 +1180,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_HEC:
 	{
 		struct venc_headerextension headerextension;
+		memset((void *)&headerextension, 0,
+			sizeof(struct venc_headerextension));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_HEC\n");
@@ -1117,6 +1212,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_TARGET_BITRATE:
 	{
 		struct venc_targetbitrate targetbitrate;
+		memset((void *)&targetbitrate, 0,
+			sizeof(struct venc_targetbitrate));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_TARGET_BITRATE\n");
@@ -1146,6 +1243,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_FRAME_RATE:
 	{
 		struct venc_framerate framerate;
+		memset((void *)&framerate, 0,
+			sizeof(struct venc_framerate));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_FRAME_RATE\n");
@@ -1175,6 +1274,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_VOP_TIMING_CFG:
 	{
 		struct venc_voptimingcfg voptimingcfg;
+		memset((void *)&voptimingcfg, 0,
+			sizeof(struct venc_voptimingcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1204,6 +1305,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_RATE_CTRL_CFG:
 	{
 		struct venc_ratectrlcfg ratectrlcfg;
+		memset((void *)&ratectrlcfg, 0,
+			sizeof(struct venc_ratectrlcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_RATE_CTRL_CFG\n");
@@ -1233,6 +1336,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_MULTI_SLICE_CFG:
 	{
 		struct venc_multiclicecfg multiclicecfg;
+		memset((void *)&multiclicecfg, 0,
+			sizeof(struct venc_multiclicecfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_MULTI_SLICE_CFG\n");
@@ -1262,6 +1367,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_INTRA_REFRESH:
 	{
 		struct venc_intrarefresh intrarefresh;
+		memset((void *)&intrarefresh, 0,
+			sizeof(struct venc_intrarefresh));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_INTRA_REFRESH\n");
@@ -1290,6 +1397,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_DEBLOCKING_CFG:
 	{
 		struct venc_dbcfg dbcfg;
+		memset((void *)&dbcfg, 0,
+			sizeof(struct venc_dbcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1319,6 +1428,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_ENTROPY_CFG:
 	{
 		struct venc_entropycfg entropy_cfg;
+		memset((void *)&entropy_cfg, 0,
+			sizeof(struct venc_entropycfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_ENTROPY_CFG\n");
@@ -1346,6 +1457,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_SEQUENCE_HDR:
 	{
 		struct venc_seqheader seq_header;
+		memset((void *)&seq_header, 0,
+			sizeof(struct venc_seqheader));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1354,6 +1467,12 @@ static long vid_enc_ioctl(struct file *file,
 			return -EFAULT;
 
 		DBG("VEN_IOCTL_GET_SEQUENCE_HDR\n");
+		if (!access_ok(VERIFY_WRITE, seq_header.hdrbufptr,
+			seq_header.bufsize)) {
+			ERR("VEN_IOCTL_GET_SEQUENCE_HDR:"\
+				" Userspace address verification failed.\n");
+			return -EFAULT;
+		}
 		result = vid_enc_get_sequence_header(client_ctx,
 				&seq_header);
 		if (!result) {
@@ -1382,6 +1501,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_INTRA_PERIOD:
 	{
 		struct venc_intraperiod intraperiod;
+		memset((void *)&intraperiod, 0,
+			sizeof(struct venc_intraperiod));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_INTRA_PERIOD\n");
@@ -1410,6 +1531,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_SESSION_QP:
 	{
 		struct venc_sessionqp session_qp;
+		memset((void *)&session_qp, 0,
+			sizeof(struct venc_sessionqp));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_SESSION_QP\n");
@@ -1438,6 +1561,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_PROFILE_LEVEL:
 	{
 		struct ven_profilelevel profile_level;
+		memset((void *)&profile_level, 0,
+			sizeof(struct ven_profilelevel));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1467,6 +1592,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_CODEC_PROFILE:
 	{
 		struct venc_profile profile;
+		memset((void *)&profile, 0,
+			sizeof(struct venc_profile));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1496,6 +1623,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_SHORT_HDR:
 	{
 		struct venc_switch encoder_switch;
+		memset((void *)&encoder_switch, 0,
+			sizeof(struct venc_switch));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("Getting VEN_IOCTL_(G)SET_SHORT_HDR\n");
@@ -1525,6 +1654,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_BASE_CFG:
 	{
 		struct venc_basecfg base_config;
+		memset((void *)&base_config, 0,
+			sizeof(struct venc_basecfg));
 		DBG("VEN_IOCTL_SET_BASE_CFG\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1553,6 +1684,8 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_GET_LIVE_MODE:
 	{
 		struct venc_switch encoder_switch;
+		memset((void *)&encoder_switch, 0,
+			sizeof(struct venc_switch));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1590,9 +1723,11 @@ static long vid_enc_ioctl(struct file *file,
 	}
 	case VEN_IOCTL_SET_METABUFFER_MODE:
 	{
-		u32 metabuffer_mode, vcd_status;
+		u32 metabuffer_mode = 0, vcd_status = 0;
 		struct vcd_property_hdr vcd_property_hdr;
 		struct vcd_property_live live_mode;
+		memset((void *)&live_mode, 0,
+			sizeof(struct vcd_property_live));
 
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1614,7 +1749,7 @@ static long vid_enc_ioctl(struct file *file,
 	case VEN_IOCTL_SET_EXTRADATA:
 	case VEN_IOCTL_GET_EXTRADATA:
 	{
-		u32 extradata_flag;
+		u32 extradata_flag = 0;
 		DBG("VEN_IOCTL_(G)SET_EXTRADATA\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1653,17 +1788,221 @@ static long vid_enc_ioctl(struct file *file,
 		}
 		break;
 	}
-    case VEN_IOCTL_SET_PERF_CLK:
-    {
-        u32 vcd_status = VCD_ERR_FAIL;
-        vcd_status = vid_enc_set_turbo_clk(client_ctx);
-        if(!vcd_status)
-        {
-            pr_err("\n %s: Setting turbo mode failed \n", __FUNCTION__);
-            return -EIO;
-        }
-        break;
-    }
+	case VEN_IOCTL_SET_SPS_PPS_FOR_IDR:
+	{
+		struct vcd_property_hdr vcd_property_hdr;
+		struct vcd_property_sps_pps_for_idr_enable idr_enable;
+		u32 vcd_status = VCD_ERR_FAIL;
+		u32 enabled = 1;
+		memset((void *)&idr_enable, 0,
+			sizeof(struct vcd_property_sps_pps_for_idr_enable));
+
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+
+		vcd_property_hdr.prop_id = VCD_I_ENABLE_SPS_PPS_FOR_IDR;
+		vcd_property_hdr.sz = sizeof(idr_enable);
+
+		if (copy_from_user(&enabled, venc_msg.in, sizeof(u32)))
+			return -EFAULT;
+
+		idr_enable.sps_pps_for_idr_enable_flag = enabled;
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				&vcd_property_hdr, &idr_enable);
+		if (vcd_status) {
+			pr_err("Setting sps/pps per IDR failed");
+			return -EIO;
+		}
+		break;
+	}
+	case VEN_IOCTL_SET_VUI_BITSTREAM_RESTRICT_FLAG:
+	{
+		struct vcd_property_hdr vcd_property_hdr;
+		struct vcd_property_bitstream_restrict_enable vcd_property_val;
+
+		u32 vcd_status = VCD_ERR_FAIL;
+		memset((void *)&vcd_property_val, 0,
+			sizeof(struct vcd_property_bitstream_restrict_enable));
+		vcd_property_hdr.prop_id =
+			VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG;
+		vcd_property_hdr.sz = sizeof(struct
+				vcd_property_bitstream_restrict_enable);
+
+		vcd_property_val.bitstream_restrict_enable_flag = true;
+
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				&vcd_property_hdr, &vcd_property_val);
+		if (vcd_status) {
+			pr_err("Setting bitstream restrict flag failed");
+			return -EIO;
+		}
+		break;
+	}
+	case VEN_IOCTL_GET_PERF_LEVEL:
+	{
+		u32 curr_perf_level = 0;
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+		result = vid_enc_get_curr_perf_level(client_ctx,
+			&curr_perf_level);
+		if (!result) {
+			ERR("get_curr_perf_level failed!!");
+			return -EIO;
+		}
+		DBG("VEN_IOCTL_GET_PERF_LEVEL %u\n",
+			curr_perf_level);
+		if (copy_to_user(venc_msg.out,
+			&curr_perf_level, sizeof(u32)))
+			return -EFAULT;
+		break;
+	}
+	case VEN_IOCTL_SET_LTRMODE:
+	case VEN_IOCTL_GET_LTRMODE:
+	{
+		struct venc_ltrmode encoder_ltrmode;
+		memset((void *)&encoder_ltrmode, 0,
+			sizeof(struct venc_ltrmode));
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+		if (cmd == VEN_IOCTL_SET_LTRMODE) {
+			DBG("VEN_IOCTL_SET_LTRMODE\n");
+			if (copy_from_user(&encoder_ltrmode, venc_msg.in,
+				sizeof(encoder_ltrmode)))
+				return -EFAULT;
+			result = vid_enc_set_get_ltrmode(client_ctx,
+				&encoder_ltrmode, true);
+		} else {
+			DBG("VEN_IOCTL_GET_LTRMODE\n");
+			result = vid_enc_set_get_ltrmode(client_ctx,
+				&encoder_ltrmode, false);
+			if (result) {
+				if (copy_to_user(venc_msg.out, &encoder_ltrmode,
+					sizeof(encoder_ltrmode)))
+					return -EFAULT;
+			}
+		}
+		if (!result) {
+			ERR("VEN_IOCTL_(G)SET_LTRMODE failed\n");
+			return -EIO;
+		}
+		break;
+	}
+	case VEN_IOCTL_SET_LTRCOUNT:
+	case VEN_IOCTL_GET_LTRCOUNT:
+	{
+		struct venc_ltrcount encoder_ltrcount;
+		memset((void *)&encoder_ltrcount, 0,
+			sizeof(struct venc_ltrcount));
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+		if (cmd == VEN_IOCTL_SET_LTRCOUNT) {
+			DBG("VEN_IOCTL_SET_LTRCOUNT\n");
+			if (copy_from_user(&encoder_ltrcount, venc_msg.in,
+				sizeof(encoder_ltrcount)))
+				return -EFAULT;
+			result = vid_enc_set_get_ltrcount(client_ctx,
+				&encoder_ltrcount, true);
+		} else {
+			DBG("VEN_IOCTL_GET_LTRCOUNT\n");
+			result = vid_enc_set_get_ltrcount(client_ctx,
+				&encoder_ltrcount, false);
+			if (result) {
+				if (copy_to_user(venc_msg.out,
+					&encoder_ltrcount,
+					sizeof(encoder_ltrcount)))
+					return -EFAULT;
+			}
+		}
+		if (!result) {
+			ERR("VEN_IOCTL_(G)SET_LTRCOUNT failed\n");
+			return -EIO;
+		}
+		break;
+	}
+	case VEN_IOCTL_SET_LTRPERIOD:
+	case VEN_IOCTL_GET_LTRPERIOD:
+	{
+		struct venc_ltrperiod encoder_ltrperiod;
+		memset((void *)&encoder_ltrperiod, 0,
+			sizeof(struct venc_ltrperiod));
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+		if (cmd == VEN_IOCTL_SET_LTRPERIOD) {
+			DBG("VEN_IOCTL_SET_LTRPERIOD\n");
+			if (copy_from_user(&encoder_ltrperiod, venc_msg.in,
+				sizeof(encoder_ltrperiod)))
+				return -EFAULT;
+			result = vid_enc_set_get_ltrperiod(client_ctx,
+				&encoder_ltrperiod, true);
+		} else {
+			DBG("VEN_IOCTL_GET_LTRPERIOD\n");
+			result = vid_enc_set_get_ltrperiod(client_ctx,
+				&encoder_ltrperiod, false);
+			if (result) {
+				if (copy_to_user(venc_msg.out,
+					&encoder_ltrperiod,
+					sizeof(encoder_ltrperiod)))
+					return -EFAULT;
+			}
+		}
+		if (!result) {
+			ERR("VEN_IOCTL_(G)SET_LTRPERIOD failed\n");
+			return -EIO;
+		}
+		break;
+	}
+	case VEN_IOCTL_GET_CAPABILITY_LTRCOUNT:
+	{
+		struct venc_range venc_capltrcount;
+		memset((void *)&venc_capltrcount, 0,
+			sizeof(struct venc_range));
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+			DBG("VEN_IOCTL_GET_CAPABILITY_LTRCOUNT\n");
+			result = vid_enc_get_capability_ltrcount(client_ctx,
+				&venc_capltrcount);
+			if (result) {
+				if (copy_to_user(venc_msg.out, &venc_capltrcount,
+					sizeof(venc_capltrcount)))
+					return -EFAULT;
+			} else {
+				ERR("VEN_IOCTL_GET_CAPABILITY_LTRCOUNT failed\n");
+				return -EIO;
+			}
+			break;
+	}
+	case VEN_IOCTL_SET_LTRUSE:
+	case VEN_IOCTL_GET_LTRUSE:
+	{
+		struct venc_ltruse encoder_ltruse;
+		memset((void *)&encoder_ltruse, 0,
+			sizeof(struct venc_ltruse));
+		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
+			return -EFAULT;
+		if (cmd == VEN_IOCTL_SET_LTRUSE) {
+			DBG("VEN_IOCTL_SET_LTRUSE\n");
+			if (copy_from_user(&encoder_ltruse, venc_msg.in,
+				sizeof(encoder_ltruse)))
+				return -EFAULT;
+			result = vid_enc_set_get_ltruse(client_ctx,
+				&encoder_ltruse, true);
+		} else {
+			DBG("VEN_IOCTL_GET_LTRUSE\n");
+			result = vid_enc_set_get_ltruse(client_ctx,
+				&encoder_ltruse, false);
+			if (result) {
+				if (copy_to_user(venc_msg.out,
+					&encoder_ltruse,
+					sizeof(encoder_ltruse)))
+					return -EFAULT;
+			}
+		}
+		if (!result) {
+			ERR("VEN_IOCTL_(G)SET_LTRUSE failed\n");
+			return -EIO;
+		}
+		break;
+	}
 	case VEN_IOCTL_SET_AC_PREDICTION:
 	case VEN_IOCTL_GET_AC_PREDICTION:
 	case VEN_IOCTL_SET_RVLC:
diff --git a/drivers/video/msm/vidc/common/enc/venc_internal.c b/drivers/video/msm/vidc/common/enc/venc_internal.c
index 07abc83..ddad23a 100644
--- a/drivers/video/msm/vidc/common/enc/venc_internal.c
+++ b/drivers/video/msm/vidc/common/enc/venc_internal.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -34,13 +34,13 @@
 #include "vcd_res_tracker_api.h"
 #include "venc_internal.h"
 
-extern u32 vidc_msg_debug;
-#define DBG(x...)				\
-	if (vidc_msg_debug) {			\
-		printk(KERN_DEBUG "[VID] " x);	\
-	}
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
 
-#define ERR(x...) printk(KERN_ERR "[VID] " x)
+#define ERR(x...) printk(KERN_ERR x)
 static unsigned int vidc_mmu_subsystem[] = {
 	MSM_SUBSYSTEM_VIDEO};
 
@@ -123,6 +123,10 @@ u32 vid_enc_set_get_inputformat(struct video_client_ctx *client_ctx,
 			format.buffer_format =
 				VCD_BUFFER_FORMAT_NV12_16M2KA;
 			break;
+		case VEN_INPUTFMT_NV21_16M2KA:
+			format.buffer_format =
+				VCD_BUFFER_FORMAT_NV21_16M2KA;
+			break;
 		default:
 			status = false;
 			break;
@@ -152,6 +156,9 @@ u32 vid_enc_set_get_inputformat(struct video_client_ctx *client_ctx,
 			case VCD_BUFFER_FORMAT_TILE_4x2:
 				*input_format = VEN_INPUTFMT_NV21;
 				break;
+			case VCD_BUFFER_FORMAT_NV21_16M2KA:
+				*input_format = VEN_INPUTFMT_NV21_16M2KA;
+				break;
 			default:
 				status = false;
 				break;
@@ -353,6 +360,42 @@ u32 vid_enc_set_get_extradata(struct video_client_ctx *client_ctx,
 	return true;
 }
 
+u32 vid_enc_set_get_extradata_cfg(struct video_client_ctx *client_ctx,
+		u32 *extradata_flag, u32 set_flag)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	struct vcd_property_meta_data_enable vcd_meta_data;
+	u32 vcd_status = VCD_ERR_FAIL;
+	if (!client_ctx || !extradata_flag)
+		return false;
+	vcd_property_hdr.prop_id = VCD_I_METADATA_ENABLE;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_meta_data_enable);
+	if (set_flag) {
+		DBG("vcd_set_property: VCD_I_METADATA_ENABLE = %d\n",
+			*extradata_flag);
+		vcd_meta_data.meta_data_enable_flag = *extradata_flag;
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_meta_data);
+		if (vcd_status) {
+			ERR("%s(): Set VCD_I_METADATA_ENABLE Failed\n",
+				__func__);
+			return false;
+		}
+	} else {
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_meta_data);
+		if (vcd_status) {
+			ERR("%s(): Get VCD_I_METADATA_ENABLE Failed\n",
+				__func__);
+			return false;
+		}
+		*extradata_flag = vcd_meta_data.meta_data_enable_flag;
+		DBG("vcd_get_property: VCD_I_METADATA_ENABLE = 0x%x\n",
+			(u32)*extradata_flag);
+	}
+	return true;
+}
+
 u32 vid_enc_set_get_framerate(struct video_client_ctx *client_ctx,
 		struct venc_framerate *frame_rate, u32 set_flag)
 {
@@ -928,7 +971,7 @@ u32 vid_enc_set_get_entropy_cfg(struct video_client_ctx *client_ctx,
 	vcd_property_hdr.sz =
 		sizeof(struct vcd_property_entropy_control);
 	if (set_flag) {
-		switch (entropy_cfg->longentropysel) {
+		switch (entropy_cfg->entropysel) {
 		case VEN_ENTROPY_MODEL_CAVLC:
 			control.entropy_sel = VCD_ENTROPY_SEL_CAVLC;
 			break;
@@ -981,11 +1024,11 @@ u32 vid_enc_set_get_entropy_cfg(struct video_client_ctx *client_ctx,
 		} else {
 			switch (control.entropy_sel) {
 			case VCD_ENTROPY_SEL_CABAC:
-				entropy_cfg->cabacmodel =
+				entropy_cfg->entropysel =
 					VEN_ENTROPY_MODEL_CABAC;
 				break;
 			case VCD_ENTROPY_SEL_CAVLC:
-				entropy_cfg->cabacmodel =
+				entropy_cfg->entropysel =
 					VEN_ENTROPY_MODEL_CAVLC;
 				break;
 			default:
@@ -1587,7 +1630,7 @@ u32 vid_enc_set_buffer(struct video_client_ctx *client_ctx,
 		vcd_buffer_t = VCD_BUFFER_OUTPUT;
 	}
 	length = buffer_info->sz;
-	
+	/*If buffer cannot be set, ignore */
 	if (!vidc_insert_addr_table(client_ctx, dir_buffer,
 					(unsigned long)buffer_info->pbuffer,
 					&kernel_vaddr,
@@ -1615,31 +1658,51 @@ u32 vid_enc_free_buffer(struct video_client_ctx *client_ctx,
 {
 	enum vcd_buffer_type buffer_vcd = VCD_BUFFER_INPUT;
 	enum buffer_dir dir_buffer = BUFFER_TYPE_INPUT;
-	u32 vcd_status = VCD_ERR_FAIL;
-	unsigned long kernel_vaddr;
+	unsigned long kernel_vaddr = 0;
+	unsigned long user_vaddr = 0;
+	unsigned long phy_addr = 0;
+	int pmem_fd = 0;
+	struct file *file;
+	s32 buffer_index = -1;
 
-	if (!client_ctx || !buffer_info)
+	if (!client_ctx || !buffer_info) {
+		ERR("%s(): wrong buffer, 0x%x, 0x%x", __func__,
+			(u32)client_ctx, (u32)buffer_info);
 		return false;
+	}
 
 	if (buffer == VEN_BUFFER_TYPE_OUTPUT) {
 		dir_buffer = BUFFER_TYPE_OUTPUT;
 		buffer_vcd = VCD_BUFFER_OUTPUT;
 	}
-	
+
+	user_vaddr = (unsigned long)buffer_info->pbuffer;
+	if (!vidc_lookup_addr_table(client_ctx, dir_buffer,
+				true, &user_vaddr, &kernel_vaddr,
+				&phy_addr, &pmem_fd, &file,
+				&buffer_index)) {
+		ERR("%s(): WNG: user_virt_addr = %p has not been set",
+		    __func__, buffer_info->pbuffer);
+		return true;
+	}
+
+	if (vcd_free_buffer(client_ctx->vcd_handle, buffer_vcd,
+				(u8 *)kernel_vaddr)) {
+		ERR("%s(): WNG: vcd_free_buffer(0x%x, %u, 0x%x) failed.",
+		    __func__, (u32)client_ctx->vcd_handle,
+		    (u32)buffer_vcd, (u32)kernel_vaddr);
+	}
+
+	/*If buffer NOT set, ignore */
 	if (!vidc_delete_addr_table(client_ctx, dir_buffer,
 				(unsigned long)buffer_info->pbuffer,
 				&kernel_vaddr)) {
-		DBG("%s() : user_virt_addr = %p has not been set.",
+		ERR("%s(): WNG: user_virt_addr = %p has not been set.",
 		    __func__, buffer_info->pbuffer);
 		return true;
 	}
-	vcd_status = vcd_free_buffer(client_ctx->vcd_handle, buffer_vcd,
-					 (u8 *)kernel_vaddr);
 
-	if (!vcd_status)
-		return true;
-	else
-		return false;
+	return true;
 }
 
 u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
@@ -1647,10 +1710,12 @@ u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
 {
 	struct vcd_frame_data vcd_input_buffer;
 	unsigned long kernel_vaddr, phy_addr, user_vaddr;
+	struct buf_addr_table *buf_addr_table;
 	int pmem_fd;
 	struct file *file;
 	s32 buffer_index = -1;
 	u32 ion_flag = 0;
+	unsigned long buff_len;
 	struct ion_handle *buff_handle = NULL;
 
 	u32 vcd_status = VCD_ERR_FAIL;
@@ -1659,16 +1724,28 @@ u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
 		return false;
 
 	user_vaddr = (unsigned long)input_frame_info->ptrbuffer;
+	buf_addr_table = client_ctx->input_buf_addr_table;
 
 	if (vidc_lookup_addr_table(client_ctx, BUFFER_TYPE_INPUT,
 			true, &user_vaddr, &kernel_vaddr,
 			&phy_addr, &pmem_fd, &file,
 			&buffer_index)) {
 
-		
+		/* kernel_vaddr  is found. send the frame to VCD */
 		memset((void *)&vcd_input_buffer, 0,
 					sizeof(struct vcd_frame_data));
 
+		buff_len = buf_addr_table[buffer_index].buff_len;
+
+		if ((input_frame_info->len > buff_len) ||
+					(input_frame_info->offset > buff_len)) {
+			ERR("%s(): offset(%lu) or data length(%lu) is greater"\
+				" than buffer length(%lu)\n",\
+			__func__, input_frame_info->offset,
+			input_frame_info->len, buff_len);
+			return false;
+		}
+
 		vcd_input_buffer.virtual =
 		(u8 *) (kernel_vaddr + input_frame_info->offset);
 
@@ -1680,7 +1757,7 @@ u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
 		vcd_input_buffer.data_len = input_frame_info->len;
 		vcd_input_buffer.time_stamp = input_frame_info->timestamp;
 
-		
+		/* Rely on VCD using the same flags as OMX */
 		vcd_input_buffer.flags = input_frame_info->flags;
 
 		ion_flag = vidc_get_fd_info(client_ctx, BUFFER_TYPE_INPUT,
@@ -1688,11 +1765,11 @@ u32 vid_enc_encode_frame(struct video_client_ctx *client_ctx,
 				&buff_handle);
 
 		if (vcd_input_buffer.data_len > 0) {
-			if (ion_flag == CACHED && buff_handle) {
+			if (ion_flag == ION_FLAG_CACHED && buff_handle) {
 				msm_ion_do_cache_op(
 				client_ctx->user_ion_client,
 				buff_handle,
-				(unsigned long *) vcd_input_buffer.virtual,
+				(unsigned long *) NULL,
 				(unsigned long) vcd_input_buffer.data_len,
 				ION_IOC_CLEAN_CACHES);
 			}
@@ -1837,8 +1914,7 @@ u32 vid_enc_set_recon_buffers(struct video_client_ctx *client_ctx,
 		}
 		control->kernel_virtual_addr = (u8 *) ion_map_kernel(
 			client_ctx->user_ion_client,
-			client_ctx->recon_buffer_ion_handle[i],
-			ionflag);
+			client_ctx->recon_buffer_ion_handle[i]);
 		if (!control->kernel_virtual_addr) {
 			ERR("%s(): get_ION_kernel virtual addr fail\n",
 				 __func__);
@@ -1864,10 +1940,10 @@ u32 vid_enc_set_recon_buffers(struct video_client_ctx *client_ctx,
 					VIDEO_DOMAIN,
 					VIDEO_MAIN_POOL,
 					SZ_4K,
-					0,
+					control->buffer_size * 2,
 					(unsigned long *)&iova,
 					(unsigned long *)&buffer_size,
-					UNCACHED, 0);
+					0, 0);
 			if (rc || !iova) {
 				ERR(
 				"%s():ION map iommu addr fail, rc = %d, iova = 0x%lx\n",
@@ -1996,3 +2072,239 @@ u32 vid_enc_get_recon_buffer_size(struct video_client_ctx *client_ctx,
 			return false;
 		}
 }
+
+u32 vid_enc_get_curr_perf_level(struct video_client_ctx *client_ctx,
+		u32 *curr_perf_level)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+	u32 curr_perf_lvl = 0;
+
+	if (!client_ctx)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_GET_CURR_PERF_LEVEL;
+	vcd_property_hdr.sz = sizeof(u32);
+	vcd_status = vcd_get_property(client_ctx->vcd_handle,
+					&vcd_property_hdr, &curr_perf_lvl);
+	if (vcd_status) {
+		ERR("VCD_I_GET_PERF_LEVEL failed!!");
+		*curr_perf_level = 0;
+		return false;
+	} else {
+		*curr_perf_level = curr_perf_lvl;
+		return true;
+	}
+}
+
+u32 vid_enc_set_get_ltrmode(struct video_client_ctx *client_ctx,
+		struct venc_ltrmode *venc_ltrmode, u32 set_flag)
+{
+	struct vcd_property_ltrmode_type vcd_property_ltrmode;
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx || !venc_ltrmode)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_LTR_MODE;
+	vcd_property_hdr.sz =
+		sizeof(struct vcd_property_ltrmode_type);
+
+	if (set_flag) {
+		vcd_property_ltrmode.ltr_mode = (enum vcd_property_ltrmode)
+			venc_ltrmode->ltr_mode;
+		DBG("%s: Set ltr_mode = %u", __func__,
+			(u32)vcd_property_ltrmode.ltr_mode);
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrmode);
+		if (vcd_status) {
+			ERR("%s(): Set VCD_I_LTR_MODE Failed\n",
+				__func__);
+			return false;
+		}
+	} else {
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrmode);
+		if (vcd_status) {
+			ERR("%s(): Get VCD_I_LTR_MODE Failed\n",
+				__func__);
+			return false;
+		} else {
+			venc_ltrmode->ltr_mode = (unsigned long)
+				vcd_property_ltrmode.ltr_mode;
+			DBG("%s: Got ltr_mode = %u", __func__,
+				(u32)vcd_property_ltrmode.ltr_mode);
+		}
+	}
+
+	return true;
+}
+
+u32 vid_enc_set_get_ltrcount(struct video_client_ctx *client_ctx,
+		struct venc_ltrcount *venc_ltrcount, u32 set_flag)
+{
+	struct vcd_property_ltrcount_type vcd_property_ltrcount;
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx || !venc_ltrcount)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_LTR_COUNT;
+	vcd_property_hdr.sz =
+		sizeof(struct vcd_property_ltrcount_type);
+
+	if (set_flag) {
+		vcd_property_ltrcount.ltr_count = (u32)
+			venc_ltrcount->ltr_count;
+		DBG("%s: Set ltr_count = %u", __func__,
+			(u32)vcd_property_ltrcount.ltr_count);
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrcount);
+		if (vcd_status) {
+			ERR("%s(): Set VCD_I_LTR_COUNT Failed\n",
+				__func__);
+			return false;
+		}
+	} else {
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrcount);
+		if (vcd_status) {
+			ERR("%s(): Get VCD_I_LTR_COUNT Failed\n",
+				__func__);
+			return false;
+		} else {
+			venc_ltrcount->ltr_count = (unsigned long)
+				vcd_property_ltrcount.ltr_count;
+			DBG("%s: Got ltr_count = %u", __func__,
+				(u32)vcd_property_ltrcount.ltr_count);
+		}
+	}
+
+	return true;
+}
+
+u32 vid_enc_set_get_ltrperiod(struct video_client_ctx *client_ctx,
+		struct venc_ltrperiod *venc_ltrperiod, u32 set_flag)
+{
+	struct vcd_property_ltrperiod_type vcd_property_ltrperiod;
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx || !venc_ltrperiod)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_LTR_PERIOD;
+	vcd_property_hdr.sz =
+		sizeof(struct vcd_property_ltrperiod_type);
+
+	if (set_flag) {
+		vcd_property_ltrperiod.ltr_period = (u32)
+			venc_ltrperiod->ltr_period;
+		DBG("%s: Set ltr_period = %u", __func__,
+			(u32)vcd_property_ltrperiod.ltr_period);
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrperiod);
+		if (vcd_status) {
+			ERR("%s(): Set VCD_I_LTR_PERIOD Failed\n",
+				__func__);
+			return false;
+		}
+	} else {
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltrperiod);
+		if (vcd_status) {
+			ERR("%s(): Get VCD_I_LTR_PERIOD Failed\n",
+				__func__);
+			return false;
+		} else {
+			venc_ltrperiod->ltr_period = (unsigned long)
+				vcd_property_ltrperiod.ltr_period;
+			DBG("%s: Got ltr_period = %u", __func__,
+				(u32)vcd_property_ltrperiod.ltr_period);
+		}
+	}
+
+	return true;
+}
+
+u32 vid_enc_set_get_ltruse(struct video_client_ctx *client_ctx,
+		struct venc_ltruse *venc_ltruse, u32 set_flag)
+{
+	struct vcd_property_ltruse_type vcd_property_ltruse;
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx || !venc_ltruse)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_LTR_USE;
+	vcd_property_hdr.sz =
+		sizeof(struct vcd_property_ltruse_type);
+
+	if (set_flag) {
+		vcd_property_ltruse.ltr_id = (u32)
+			venc_ltruse->ltr_id;
+		vcd_property_ltruse.ltr_frames = (u32)
+			venc_ltruse->ltr_frames;
+		DBG("%s: Set ltr_id = %u, ltr_frames = %u",
+			__func__, vcd_property_ltruse.ltr_id,
+			vcd_property_ltruse.ltr_frames);
+		vcd_status = vcd_set_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltruse);
+		if (vcd_status) {
+			ERR("%s(): Set VCD_I_LTR_USE Failed\n",
+				__func__);
+			return false;
+		}
+	} else {
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+			&vcd_property_hdr, &vcd_property_ltruse);
+		if (vcd_status) {
+			ERR("%s(): Get VCD_I_LTR_USE Failed\n",
+				__func__);
+			return false;
+		} else {
+			venc_ltruse->ltr_id = (unsigned long)
+				vcd_property_ltruse.ltr_id;
+			venc_ltruse->ltr_frames = (unsigned long)
+				vcd_property_ltruse.ltr_frames;
+			DBG("%s: Got ltr_id = %u, ltr_frames = %u",
+				__func__, vcd_property_ltruse.ltr_id,
+				vcd_property_ltruse.ltr_frames);
+		}
+	}
+
+	return true;
+}
+
+u32 vid_enc_get_capability_ltrcount(struct video_client_ctx *client_ctx,
+		struct venc_range *venc_capltrcount)
+{
+	struct vcd_property_range_type vcd_property_range;
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+
+	if (!client_ctx || !venc_capltrcount)
+		return false;
+
+	vcd_property_hdr.prop_id = VCD_I_CAPABILITY_LTR_COUNT;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_range_type);
+	vcd_status = vcd_get_property(client_ctx->vcd_handle,
+		&vcd_property_hdr, &vcd_property_range);
+	if (vcd_status) {
+		ERR("%s(): Get VCD_I_CAPABILITY_LTR_COUNT Failed\n",
+			__func__);
+		return false;
+	} else {
+		venc_capltrcount->min = vcd_property_range.min;
+		venc_capltrcount->max = vcd_property_range.max;
+		venc_capltrcount->step_size = vcd_property_range.step_size;
+		DBG("%s: Got min: %lu, max: %lu, step_size: %lu", __func__,
+			venc_capltrcount->min, venc_capltrcount->max,
+			venc_capltrcount->step_size);
+	}
+
+	return true;
+}
diff --git a/drivers/video/msm/vidc/common/enc/venc_internal.h b/drivers/video/msm/vidc/common/enc/venc_internal.h
index 8a07fdb..397babf 100644
--- a/drivers/video/msm/vidc/common/enc/venc_internal.h
+++ b/drivers/video/msm/vidc/common/enc/venc_internal.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,6 +18,7 @@
 #include <linux/cdev.h>
 #include <media/msm/vidc_init.h>
 
+#define NUM_OF_DRIVER_NODES 2
 #define VID_ENC_MAX_NUM_OF_BUFF 100
 
 enum venc_buffer_dir{
@@ -32,8 +33,8 @@ struct vid_enc_msg {
 
 struct vid_enc_dev {
 
-	struct cdev cdev;
-	struct device *device;
+	struct cdev cdev[NUM_OF_DRIVER_NODES];
+	struct device *device[NUM_OF_DRIVER_NODES];
 	resource_size_t phys_base;
 	void __iomem *virt_base;
 	unsigned int irq;
@@ -151,4 +152,22 @@ u32 vid_enc_free_recon_buffers(struct video_client_ctx *client_ctx,
 u32 vid_enc_get_recon_buffer_size(struct video_client_ctx *client_ctx,
 		struct venc_recon_buff_size *venc_recon_size);
 
+u32 vid_enc_get_curr_perf_level(struct video_client_ctx *client_ctx,
+		u32 *curr_perf_level);
+
+u32 vid_enc_set_get_ltrmode(struct video_client_ctx *client_ctx,
+		struct venc_ltrmode *encoder_ltrmode, u32 set_flag);
+
+u32 vid_enc_set_get_ltrcount(struct video_client_ctx *client_ctx,
+		struct venc_ltrcount *encoder_ltrcount, u32 set_flag);
+
+u32 vid_enc_set_get_ltrperiod(struct video_client_ctx *client_ctx,
+		struct venc_ltrperiod *encoder_ltrperiod, u32 set_flag);
+
+u32 vid_enc_get_capability_ltrcount(struct video_client_ctx *client_ctx,
+		struct venc_range *venc_capltrcount);
+
+u32 vid_enc_set_get_ltruse(struct video_client_ctx *client_ctx,
+		struct venc_ltruse *encoder_ltruse, u32 set_flag);
+
 #endif
diff --git a/drivers/video/msm/vidc/common/init/vidc_init.c b/drivers/video/msm/vidc/common/init/vidc_init.c
index 9a3f18c..6e6235c 100644
--- a/drivers/video/msm/vidc/common/init/vidc_init.c
+++ b/drivers/video/msm/vidc/common/init/vidc_init.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -36,14 +36,15 @@
 #include "vidc_init_internal.h"
 #include "vcd_res_tracker_api.h"
 
-#define DBG(x...)				\
-	if (vidc_msg_debug) {			\
-		printk(KERN_DEBUG "[VID] " x);	\
-	}
+#if DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
+#else
+#define DBG(x...)
+#endif
 
 #define VIDC_NAME "msm_vidc_reg"
 
-#define ERR(x...) printk(KERN_ERR "[VID] " x)
+#define ERR(x...) printk(KERN_ERR x)
 
 static struct vidc_dev *vidc_device_p;
 static dev_t vidc_dev_num;
@@ -62,7 +63,7 @@
 static irqreturn_t vidc_isr(int irq, void *dev);
 static spinlock_t vidc_spin_lock;
 
-u32 vidc_msg_timing, vidc_msg_pmem, vidc_msg_register, vidc_msg_debug;
+u32 vidc_msg_timing, vidc_msg_pmem, vidc_msg_register;
 
 #ifdef VIDC_ENABLE_DBGFS
 struct dentry *vidc_debugfs_root;
@@ -312,8 +313,6 @@ static int __init vidc_init(void)
 				(u32 *) &vidc_msg_pmem);
 		vidc_debugfs_file_create(root, "vidc_msg_register",
 				(u32 *) &vidc_msg_register);
-		vidc_debugfs_file_create(root, "vidc_msg_debug",
-				(u32 *) &vidc_msg_debug);
 	}
 #endif
 	return 0;
@@ -404,7 +403,7 @@ void vidc_cleanup_addr_table(struct video_client_ctx *client_ctx,
 				enum buffer_dir buffer)
 {
 	u32 *num_of_buffers = NULL;
-	u32 i = 0;
+	u32 i = 0, len = 0;
 	struct buf_addr_table *buf_addr_table;
 	if (buffer == BUFFER_TYPE_INPUT) {
 		buf_addr_table = client_ctx->input_buf_addr_table;
@@ -430,10 +429,9 @@ void vidc_cleanup_addr_table(struct video_client_ctx *client_ctx,
 		}
 		if (!IS_ERR_OR_NULL(buf_addr_table[i].buff_ion_handle)) {
 			if (!IS_ERR_OR_NULL(client_ctx->user_ion_client)) {
-				ion_unmap_kernel(client_ctx->user_ion_client,
-						buf_addr_table[i].
-						buff_ion_handle);
-				if (!res_trk_check_for_sec_session()) {
+				if (!res_trk_check_for_sec_session() &&
+				   (res_trk_get_core_type() !=
+				   (u32)VCD_CORE_720P)) {
 					ion_unmap_iommu(
 						client_ctx->user_ion_client,
 						buf_addr_table[i].
@@ -448,6 +446,38 @@ void vidc_cleanup_addr_table(struct video_client_ctx *client_ctx,
 			}
 		}
 	}
+	len = sizeof(client_ctx->recon_buffer)/
+		sizeof(struct vcd_property_enc_recon_buffer);
+	for (i = 0; i < len; i++) {
+		if (!vcd_get_ion_status()) {
+			if (client_ctx->recon_buffer[i].client_data) {
+				msm_subsystem_unmap_buffer(
+				(struct msm_mapped_buffer *)
+				client_ctx->recon_buffer[i].client_data);
+				client_ctx->recon_buffer[i].client_data = NULL;
+			}
+		} else  {
+			if (!IS_ERR_OR_NULL(
+				client_ctx->recon_buffer_ion_handle[i])) {
+				ion_unmap_kernel(client_ctx->user_ion_client,
+				client_ctx->recon_buffer_ion_handle[i]);
+				if (!res_trk_check_for_sec_session() &&
+				   (res_trk_get_core_type() !=
+					(u32)VCD_CORE_720P)) {
+					ion_unmap_iommu(client_ctx->
+						user_ion_client,
+						client_ctx->
+						recon_buffer_ion_handle[i],
+						VIDEO_DOMAIN,
+						VIDEO_MAIN_POOL);
+				}
+				ion_free(client_ctx->user_ion_client,
+				client_ctx->recon_buffer_ion_handle[i]);
+				client_ctx->recon_buffer_ion_handle[i] = NULL;
+			}
+		}
+	}
+
 	if (client_ctx->vcd_h264_mv_buffer.client_data) {
 		msm_subsystem_unmap_buffer((struct msm_mapped_buffer *)
 		client_ctx->vcd_h264_mv_buffer.client_data);
@@ -469,6 +499,42 @@ void vidc_cleanup_addr_table(struct video_client_ctx *client_ctx,
 			client_ctx->h264_mv_ion_handle = NULL;
 		}
 	}
+
+	if (client_ctx->vcd_meta_buffer.client_data)
+		msm_subsystem_unmap_buffer((struct msm_mapped_buffer *)
+		client_ctx->vcd_meta_buffer.client_data);
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_ion_handle)) {
+			ion_unmap_kernel(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle);
+		if (!res_trk_check_for_sec_session() &&
+		   (res_trk_get_core_type() != (u32)VCD_CORE_720P)) {
+			ion_unmap_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_ion_handle,
+				VIDEO_DOMAIN,
+				VIDEO_MAIN_POOL);
+		}
+		ion_free(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_ion_handle);
+		client_ctx->meta_buffer_ion_handle = NULL;
+	}
+
+	if (client_ctx->vcd_meta_buffer.client_data_iommu)
+		msm_subsystem_unmap_buffer((struct msm_mapped_buffer *)
+		client_ctx->vcd_meta_buffer.client_data_iommu);
+	if (!IS_ERR_OR_NULL(client_ctx->meta_buffer_iommu_ion_handle)) {
+		ion_unmap_kernel(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_iommu_ion_handle);
+		if (res_trk_check_for_sec_session() &&
+		   (res_trk_get_core_type() != (u32)VCD_CORE_720P)) {
+			ion_unmap_iommu(client_ctx->user_ion_client,
+				client_ctx->meta_buffer_iommu_ion_handle,
+				VIDEO_DOMAIN,
+				VIDEO_MAIN_POOL);
+		}
+		ion_free(client_ctx->user_ion_client,
+			client_ctx->meta_buffer_iommu_ion_handle);
+		client_ctx->meta_buffer_iommu_ion_handle = NULL;
+	}
 bail_out_cleanup:
 	return;
 }
@@ -528,28 +594,27 @@ u32 vidc_lookup_addr_table(struct video_client_ctx *client_ctx,
 		*pmem_fd = buf_addr_table[i].pmem_fd;
 		*file = buf_addr_table[i].file;
 		*buffer_index = i;
-		if (search_with_user_vaddr) {
+
+		if (search_with_user_vaddr)
 			DBG("kernel_vaddr = 0x%08lx, phy_addr = 0x%08lx "
 			" pmem_fd = %d, struct *file	= %p "
 			"buffer_index = %d\n", *kernel_vaddr,
 			*phy_addr, *pmem_fd, *file, *buffer_index);
-		} else {
+		else
 			DBG("user_vaddr = 0x%08lx, phy_addr = 0x%08lx "
 			" pmem_fd = %d, struct *file	= %p "
 			"buffer_index = %d\n", *user_vaddr, *phy_addr,
 			*pmem_fd, *file, *buffer_index);
-			}
 		mutex_unlock(&client_ctx->enrty_queue_lock);
 		return true;
 	} else {
-		if (search_with_user_vaddr) {
+		if (search_with_user_vaddr)
 			DBG("%s() : client_ctx = %p user_virt_addr = 0x%08lx"
 			" Not Found.\n", __func__, client_ctx, *user_vaddr);
-		} else {
+		else
 			DBG("%s() : client_ctx = %p kernel_virt_addr = 0x%08lx"
 			" Not Found.\n", __func__, client_ctx,
 			*kernel_vaddr);
-			}
 		mutex_unlock(&client_ctx->enrty_queue_lock);
 		return false;
 	}
@@ -574,6 +639,10 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 	int ret = 0;
 	unsigned long buffer_size  = 0;
 	size_t ion_len;
+	struct vcd_property_hdr vcd_property_hdr;
+	struct vcd_property_codec codec;
+	unsigned long mapped_length = length;
+	u32 vcd_status = VCD_ERR_FAIL;
 
 	if (!client_ctx || !length)
 		return false;
@@ -589,7 +658,21 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 		num_of_buffers = &client_ctx->num_of_output_buffers;
 		DBG("%s(): buffer = OUTPUT #Buf = %d\n",
 			__func__, *num_of_buffers);
-		length = length * 2; 
+		vcd_property_hdr.prop_id = VCD_I_CODEC;
+		vcd_property_hdr.sz = sizeof(struct vcd_property_codec);
+		vcd_status = vcd_get_property(client_ctx->vcd_handle,
+						&vcd_property_hdr, &codec);
+		if (vcd_status) {
+			ERR("%s(): get codec failed", __func__);
+		} else {
+			if (codec.codec != VCD_CODEC_H264) {
+				/* workaround for iommu video h/w bug */
+				DBG("%s(): Double iommu map size from %u "\
+				"to %u for non-H264", __func__,
+				(u32)length, (u32)(length * 2));
+				mapped_length = length * 2;
+			}
+		}
 	}
 
 	if (*num_of_buffers == max_num_buffers) {
@@ -619,7 +702,7 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 			? MSM_SUBSYSTEM_MAP_IOVA :
 			MSM_SUBSYSTEM_MAP_IOVA|MSM_SUBSYSTEM_ALIGN_IOVA_8K;
 			mapped_buffer = msm_subsystem_map_buffer(phys_addr,
-			length, flags, vidc_mmu_subsystem,
+			mapped_length, flags, vidc_mmu_subsystem,
 			sizeof(vidc_mmu_subsystem)/sizeof(unsigned int));
 			if (IS_ERR(mapped_buffer)) {
 				pr_err("buffer map failed");
@@ -644,18 +727,6 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 				 __func__);
 				goto bail_out_add;
 			}
-			*kernel_vaddr = (unsigned long)
-				ion_map_kernel(
-				client_ctx->user_ion_client,
-				buff_ion_handle,
-				ionflag);
-			if (IS_ERR_OR_NULL((void *)*kernel_vaddr)) {
-				ERR("%s():ION virtual addr fail\n",
-				 __func__);
-				*kernel_vaddr = (unsigned long)NULL;
-				show_mem(SHOW_MEM_FILTER_NODES);
-				goto ion_free_error;
-			}
 			if (res_trk_check_for_sec_session() ||
 			   (res_trk_get_core_type() == (u32)VCD_CORE_720P)) {
 				if (ion_phys(client_ctx->user_ion_client,
@@ -676,11 +747,10 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 						VIDEO_DOMAIN,
 						VIDEO_MAIN_POOL,
 						SZ_8K,
-						length,
+						mapped_length,
 						(unsigned long *) &iova,
 						(unsigned long *) &buffer_size,
-						UNCACHED,
-						ION_IOMMU_UNMAP_DELAYED);
+						0, 0);
 				if (ret || !iova) {
 					ERR(
 					"%s():ION iommu map fail, ret = %d, iova = 0x%lx\n",
@@ -694,12 +764,14 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 						 iova;
 			}
 		}
+		(*kernel_vaddr) = phys_addr;
 		phys_addr += buffer_addr_offset;
 		(*kernel_vaddr) += buffer_addr_offset;
 		buf_addr_table[*num_of_buffers].user_vaddr = user_vaddr;
 		buf_addr_table[*num_of_buffers].kernel_vaddr = *kernel_vaddr;
 		buf_addr_table[*num_of_buffers].pmem_fd = pmem_fd;
 		buf_addr_table[*num_of_buffers].file = file;
+		buf_addr_table[*num_of_buffers].buff_len = length;
 		buf_addr_table[*num_of_buffers].phy_addr = phys_addr;
 		buf_addr_table[*num_of_buffers].buff_ion_handle =
 						buff_ion_handle;
@@ -714,9 +786,6 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 	mutex_unlock(&client_ctx->enrty_queue_lock);
 	return true;
 ion_map_error:
-	if (*kernel_vaddr && buff_ion_handle)
-		ion_unmap_kernel(client_ctx->user_ion_client, buff_ion_handle);
-ion_free_error:
 	if (!IS_ERR_OR_NULL(buff_ion_handle))
 		ion_free(client_ctx->user_ion_client, buff_ion_handle);
 bail_out_add:
@@ -725,6 +794,10 @@ u32 vidc_insert_addr_table(struct video_client_ctx *client_ctx,
 }
 EXPORT_SYMBOL(vidc_insert_addr_table);
 
+/*
+ * Similar to vidc_insert_addr_table except intended for in-kernel
+ * use where buffers have already been alloced and mapped properly
+ */
 u32 vidc_insert_addr_table_kernel(struct video_client_ctx *client_ctx,
 	enum buffer_dir buffer, unsigned long user_vaddr,
 	unsigned long kernel_vaddr, unsigned long phys_addr,
@@ -777,6 +850,7 @@ u32 vidc_insert_addr_table_kernel(struct video_client_ctx *client_ctx,
 		buf_addr_table[*num_of_buffers].kernel_vaddr = kernel_vaddr;
 		buf_addr_table[*num_of_buffers].pmem_fd = -1;
 		buf_addr_table[*num_of_buffers].file = NULL;
+		buf_addr_table[*num_of_buffers].buff_len = length;
 		buf_addr_table[*num_of_buffers].phy_addr = phys_addr;
 		buf_addr_table[*num_of_buffers].buff_ion_handle = NULL;
 		*num_of_buffers = *num_of_buffers + 1;
@@ -833,8 +907,6 @@ u32 vidc_delete_addr_table(struct video_client_ctx *client_ctx,
 	}
 	*kernel_vaddr = buf_addr_table[i].kernel_vaddr;
 	if (buf_addr_table[i].buff_ion_handle) {
-		ion_unmap_kernel(client_ctx->user_ion_client,
-				buf_addr_table[i].buff_ion_handle);
 		if (!res_trk_check_for_sec_session() &&
 		   (res_trk_get_core_type() != (u32)VCD_CORE_720P)) {
 			ion_unmap_iommu(client_ctx->user_ion_client,
@@ -861,6 +933,8 @@ u32 vidc_delete_addr_table(struct video_client_ctx *client_ctx,
 			buf_addr_table[*num_of_buffers - 1].pmem_fd;
 		buf_addr_table[i].file =
 			buf_addr_table[*num_of_buffers - 1].file;
+		buf_addr_table[i].buff_len =
+			buf_addr_table[*num_of_buffers - 1].buff_len;
 		buf_addr_table[i].buff_ion_handle =
 			buf_addr_table[*num_of_buffers - 1].buff_ion_handle;
 	}
@@ -910,7 +984,7 @@ void  vidc_timer_start(void *timer_handle, u32 time_out)
 	struct vidc_timer *hw_timer = (struct vidc_timer *)timer_handle;
 	DBG("%s(): start timer\n ", __func__);
 	if (hw_timer) {
-		hw_timer->hw_timeout.expires = jiffies + 5*HZ;
+		hw_timer->hw_timeout.expires = jiffies + 1*HZ;
 		add_timer(&hw_timer->hw_timeout);
 	}
 }
diff --git a/drivers/video/msm/vidc/common/init/vidc_init_internal.h b/drivers/video/msm/vidc/common/init/vidc_init_internal.h
index 1d903ad..b62280f 100644
--- a/drivers/video/msm/vidc/common/init/vidc_init_internal.h
+++ b/drivers/video/msm/vidc/common/init/vidc_init_internal.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/common/vcd/vcd.h b/drivers/video/msm/vidc/common/vcd/vcd.h
index 4e13265..185d811 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,7 +20,6 @@
 #include "vcd_client_sm.h"
 #include "vcd_core.h"
 #include "vcd_device_sm.h"
-extern u32 vidc_msg_debug;
 
 void vcd_reset_device_channels(struct vcd_dev_ctxt *dev_ctxt);
 
@@ -328,6 +327,7 @@ u32 vcd_enable_clock(struct vcd_dev_ctxt *dev_ctxt,
 
 u32 vcd_disable_clock(struct vcd_dev_ctxt *dev_ctxt);
 
+u32 vcd_get_curr_perf_level(struct vcd_dev_ctxt *dev_ctxt);
 u32 vcd_set_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl);
 
 u32 vcd_update_clnt_perf_lvl
@@ -399,4 +399,11 @@ u32 vcd_req_perf_level(struct vcd_clnt_ctxt *cctxt,
 u32 vcd_update_decoder_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl);
 
 u32 vcd_set_perf_turbo_level(struct vcd_clnt_ctxt *cctxt);
+
+struct vcd_transc *vcd_get_first_in_use_trans_for_clnt(
+	struct vcd_clnt_ctxt *cctxt);
+
+u32 vcd_handle_ltr_use_failed(struct vcd_clnt_ctxt *cctxt,
+	void *payload, size_t sz, u32 status);
+
 #endif
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_api.c b/drivers/video/msm/vidc/common/vcd/vcd_api.c
index 5cfa948..fd2d01b 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_api.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_api.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -117,37 +117,20 @@ static int is_session_invalid(u32 decoding, u32 flags)
 	int is_secure;
 	struct client_security_info sec_info;
 	int client_count = 0;
-	int secure_session_running = 0;
+	int secure_session_running = 0, non_secure_running = 0;
 	is_secure = (flags & VCD_CP_SESSION) ? 1 : 0;
 	client_count = vcd_get_clients_security_info(&sec_info);
 	secure_session_running = (sec_info.secure_enc > 0) ||
 			(sec_info.secure_dec > 0);
-	if (!decoding && is_secure) {
-		if ((sec_info.secure_dec == 1)) {
-			VCD_MSG_LOW("SE-SD: SUCCESS\n");
-		}
-		else {
-			VCD_MSG_LOW("SE is permitted only with SD: FAILURE\n");
-			return -EACCES;
-		}
-	} else if (!decoding && !is_secure) {
+	non_secure_running = sec_info.non_secure_dec + sec_info.non_secure_enc;
+	if (!is_secure) {
 		if (secure_session_running) {
-			VCD_MSG_LOW("SD-NSE: FAILURE\n");
-			VCD_MSG_LOW("SE-NSE: FAILURE\n");
-			return -EACCES;
-		}
-	} else if (decoding && is_secure) {
-		if (client_count > 0) {
-			VCD_MSG_LOW("S/NS-SD: FAILURE\n");
-			if (sec_info.secure_enc > 0 ||
-				sec_info.non_secure_enc > 0) {
-				return -EAGAIN;
-			}
+			pr_err("non secure session failed secure running\n");
 			return -EACCES;
 		}
 	} else {
-		if (sec_info.secure_dec > 0) {
-			VCD_MSG_LOW("SD-NSD: FAILURE\n");
+		if (non_secure_running) {
+			pr_err("Secure session failed non secure running\n");
 			return -EACCES;
 		}
 	}
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c b/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c
index 1636478..fc5d650 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -503,7 +503,7 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
 
 	rc = ddl_set_property(cctxt->ddl_handle, prop_hdr, prop_val);
 	if (rc) {
-		
+		/* Some properties aren't known to ddl that we can handle */
 		if (prop_hdr->prop_id != VCD_I_VOP_TIMING_CONSTANT_DELTA)
 			VCD_FAILED_RETURN(rc, "Failed: ddl_set_property");
 	}
@@ -543,7 +543,8 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
 		}
 	case VCD_I_SET_TURBO_CLK:
 	{
-        rc = vcd_set_perf_turbo_level(cctxt);
+		if (cctxt->sched_clnt_hdl)
+			rc = vcd_set_perf_turbo_level(cctxt);
 		break;
 	}
 	case VCD_I_INTRA_PERIOD:
@@ -583,7 +584,8 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
     (struct vcd_clnt_ctxt *cctxt,
      struct vcd_property_hdr *prop_hdr, void *prop_val)
 {
-	int rc;
+	int rc = VCD_ERR_FAIL;
+	u32 prop_handled = true;
 	VCD_MSG_LOW("vcd_get_property_cmn in %d:", cctxt->clnt_state.state);
 	VCD_MSG_LOW("property Id = %d", prop_hdr->prop_id);
 	if (!prop_hdr->sz || !prop_hdr->prop_id) {
@@ -591,13 +593,6 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
 
 		return VCD_ERR_ILLEGAL_PARM;
 	}
-	rc = ddl_get_property(cctxt->ddl_handle, prop_hdr, prop_val);
-	if (rc) {
-		
-		if (prop_hdr->prop_id != VCD_I_VOP_TIMING_CONSTANT_DELTA)
-			VCD_FAILED_RETURN(rc, "Failed: ddl_set_property");
-	}
-
 	switch (prop_hdr->prop_id) {
 	case VCD_I_VOP_TIMING_CONSTANT_DELTA:
 	{
@@ -607,8 +602,30 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
 		delta->constant_delta = cctxt->time_frame_delta;
 		rc = VCD_S_SUCCESS;
 	}
+	break;
+	case VCD_I_GET_CURR_PERF_LEVEL:
+	{
+		u32 curr_perf_level = 0;
+		curr_perf_level = vcd_get_curr_perf_level(
+			cctxt->dev_ctxt);
+		*(u32 *)prop_val = curr_perf_level;
+		VCD_MSG_LOW("%s: curr_perf_level = %u",
+			__func__, curr_perf_level);
+		rc = VCD_S_SUCCESS;
 	}
-	return rc;
+	break;
+	default:
+		prop_handled = false;
+	break;
+	}
+
+	if (prop_handled) {
+		VCD_MSG_LOW("%s: property %u handled at vcd level",
+			__func__, prop_hdr->prop_id);
+		return rc;
+	}
+
+	return ddl_get_property(cctxt->ddl_handle, prop_hdr, prop_val);
 }
 
 static u32 vcd_set_buffer_requirements_cmn
@@ -963,6 +980,12 @@ static u32  vcd_stop_in_invalid(struct vcd_clnt_ctxt *cctxt)
 			vcd_handle_ind_info_output_reconfig(cctxt, status);
 			break;
 		}
+	case VCD_EVT_IND_INFO_LTRUSE_FAILED:
+		{
+			rc = vcd_handle_ltr_use_failed(cctxt,
+				payload, sz, status);
+			break;
+		}
 	default:
 		{
 			VCD_MSG_ERROR
@@ -1621,6 +1644,7 @@ void vcd_do_client_state_transition(struct vcd_clnt_ctxt *cctxt,
 	if (!cctxt || to_state >= VCD_CLIENT_STATE_MAX) {
 		VCD_MSG_ERROR("Bad parameters. cctxt=%p, to_state=%d",
 			      cctxt, to_state);
+		return;
 	}
 
 	state_ctxt = &cctxt->clnt_state;
@@ -1743,7 +1767,7 @@ void vcd_do_client_state_transition(struct vcd_clnt_ctxt *cctxt,
 	 vcd_get_buffer_requirements_cmn,
 	 NULL,
 	 NULL,
-	 NULL,
+	 vcd_free_buffer_cmn,
 	 vcd_fill_output_buffer_cmn,
 	 vcd_clnt_cb_in_flushing,
 	 },
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_client_sm.h b/drivers/video/msm/vidc/common/vcd/vcd_client_sm.h
index 9f2d63d..ba1884d 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_client_sm.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd_client_sm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_core.h b/drivers/video/msm/vidc/common/vcd/vcd_core.h
index 8126a0e..9508a8d 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_core.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd_core.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,7 +13,7 @@
 #ifndef _VCD_CORE_H_
 #define _VCD_CORE_H_
 
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <media/msm/vcd_api.h>
 #include "vcd_ddl_api.h"
 
@@ -147,7 +147,6 @@ struct vcd_dev_ctxt {
 	u32 reqd_perf_lvl;
 	u32 curr_perf_lvl;
 	u32 set_perf_lvl_pending;
-	u32 turbo_mode_set;
 };
 
 struct vcd_clnt_status {
@@ -214,6 +213,7 @@ struct vcd_clnt_ctxt {
 	u32 meta_mode;
 	int perf_set_by_client;
 	int secure;
+	bool is_turbo_enabled;
 };
 
 #define VCD_BUFFERPOOL_INUSE_DECREMENT(val) \
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
index eac8d37..9074358 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -36,6 +36,7 @@ void vcd_do_device_state_transition(struct vcd_drv_ctxt *drv_ctxt,
 	if (!drv_ctxt || to_state >= VCD_DEVICE_STATE_MAX) {
 		VCD_MSG_ERROR("Bad parameters. drv_ctxt=%p, to_state=%d",
 				  drv_ctxt, to_state);
+		return;
 	}
 
 	state_ctxt = &drv_ctxt->dev_state;
@@ -219,8 +220,6 @@ u32 vcd_init_device_context(struct vcd_drv_ctxt *drv_ctxt,
 						   VCD_DEVICE_STATE_INITING,
 						   ev_code);
 	}
-	dev_ctxt->turbo_mode_set = 0;
-
 	return rc;
 }
 
@@ -323,11 +322,11 @@ u32 vcd_reset_device_context(struct vcd_drv_ctxt *drv_ctxt,
 	rc = vcd_power_event(&drv_ctxt->dev_ctxt, NULL,
 						 VCD_EVT_PWR_DEV_TERM_BEGIN);
 	VCD_FAILED_RETURN(rc, "VCD_EVT_PWR_DEV_TERM_BEGIN failed");
-	if (ddl_reset_hw(0)) {
+	if (ddl_reset_hw(0))
 		VCD_MSG_HIGH("HW Reset done");
-	} else {
+	else
 		VCD_MSG_FATAL("HW Reset failed");
-	}
+
 	(void)vcd_power_event(dev_ctxt, NULL, VCD_EVT_PWR_DEV_TERM_END);
 
 	return VCD_S_SUCCESS;
@@ -759,7 +758,6 @@ static u32  vcd_term_in_invalid(struct vcd_drv_ctxt *drv_ctxt,
 	client = dev_ctxt->cctxt_list_head;
 	dev_ctxt->cctxt_list_head = cctxt;
 	cctxt->next = client;
-	dev_ctxt->turbo_mode_set = 0;
 
 	*clnt_cctxt = cctxt;
 
@@ -1070,7 +1068,7 @@ static void  vcd_hw_timeout_cmn(struct vcd_drv_ctxt *drv_ctxt,
 
 	vcd_handle_device_err_fatal(dev_ctxt, NULL);
 
-	
+	/* Reset HW. */
 	(void) vcd_reset_device_context(drv_ctxt,
 		DEVICE_STATE_EVENT_NUMBER(timeout));
 }
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.h b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.h
index 2443c33..898f284 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_device_sm.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd_device_sm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c b/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c
index 674fe04..d525768 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -188,14 +188,28 @@ u32 vcd_client_power_event(
 			if (cctxt) {
 				rc = VCD_S_SUCCESS;
 				if (cctxt->status.req_perf_lvl) {
+					VCD_MSG_HIGH("%s: reduce client(0x%x) "\
+					"perf level(%u) from device "\
+					"perf level(%u)", __func__,
+					(u32)cctxt, cctxt->reqd_perf_lvl,
+					dev_ctxt->reqd_perf_lvl);
+
 					dev_ctxt->reqd_perf_lvl -=
 						cctxt->reqd_perf_lvl;
 					cctxt->status.req_perf_lvl = false;
 					rc = vcd_set_perf_level(dev_ctxt,
 						dev_ctxt->reqd_perf_lvl);
+
+					if ((cctxt->perf_set_by_client) &&
+						(event ==
+						VCD_EVT_PWR_CLNT_LAST_FRAME)) {
+						VCD_MSG_HIGH("%s: disable "\
+							"perf_set_by_client (0x%x)",
+							__func__, (u32)cctxt);
+						cctxt->perf_set_by_client = 0;
+					}
 				}
 			}
-
 			break;
 		}
 
@@ -205,6 +219,12 @@ u32 vcd_client_power_event(
 			if (cctxt) {
 				rc = VCD_S_SUCCESS;
 				if (!cctxt->status.req_perf_lvl) {
+					VCD_MSG_HIGH("%s: add client(0x%x) "\
+					"perf level(%u) to device "\
+					"perf level(%u)", __func__,
+					(u32)cctxt, cctxt->reqd_perf_lvl,
+					dev_ctxt->reqd_perf_lvl);
+
 					dev_ctxt->reqd_perf_lvl +=
 						cctxt->reqd_perf_lvl;
 					cctxt->status.req_perf_lvl = true;
@@ -279,6 +299,11 @@ u32 vcd_disable_clock(struct vcd_dev_ctxt *dev_ctxt)
 	return rc;
 }
 
+u32 vcd_get_curr_perf_level(struct vcd_dev_ctxt *dev_ctxt)
+{
+	return dev_ctxt->reqd_perf_lvl;
+}
+
 u32 vcd_set_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl)
 {
 	u32 rc = VCD_S_SUCCESS;
@@ -303,7 +328,7 @@ u32 vcd_set_perf_turbo_level(struct vcd_clnt_ctxt *cctxt)
 	u32 rc = VCD_S_SUCCESS;
 #ifdef CONFIG_MSM_BUS_SCALING
 	struct vcd_dev_ctxt *dev_ctxt = cctxt->dev_ctxt;
-	pr_info("\n Setting Turbo mode !! \n");
+	pr_err("\n Setting Turbo mode !!");
 
 	if (res_trk_update_bus_perf_level(dev_ctxt,
 			RESTRK_1080P_TURBO_PERF_LEVEL) < 0) {
@@ -341,7 +366,12 @@ u32 vcd_update_clnt_perf_lvl(
 	u32 new_perf_lvl;
 	new_perf_lvl = frm_p_units *\
 		(fps->fps_numerator / fps->fps_denominator);
-
+	if (cctxt->perf_set_by_client) {
+		new_perf_lvl = cctxt->reqd_perf_lvl;
+		VCD_MSG_HIGH("%s: perf_set_by_client (0x%x), "\
+			"perf level = %u\n", __func__,
+			(u32)cctxt, new_perf_lvl);
+	}
 	if ((fps->fps_numerator * 1000) / fps->fps_denominator
 		 > VCD_MAXPERF_FPS_THRESHOLD_X_1000) {
 		u32 max_perf_level = 0;
@@ -360,7 +390,11 @@ u32 vcd_update_clnt_perf_lvl(
 		rc = vcd_set_perf_level(cctxt->dev_ctxt,
 			dev_ctxt->reqd_perf_lvl);
 	}
-	cctxt->reqd_perf_lvl = new_perf_lvl;
+	if (!cctxt->perf_set_by_client)
+		cctxt->reqd_perf_lvl = new_perf_lvl;
+	VCD_MSG_HIGH("%s: updated client perf level = %u, "\
+		"device perf level = %u", __func__,
+		cctxt->reqd_perf_lvl, dev_ctxt->reqd_perf_lvl);
 	return rc;
 }
 
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_power_sm.h b/drivers/video/msm/vidc/common/vcd/vcd_power_sm.h
index 26ce019..aecbc8d 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_power_sm.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd_power_sm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c b/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
index 7412398..e0b2b4d 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -75,10 +75,10 @@ u32 vcd_sched_add_client(struct vcd_clnt_ctxt *cctxt)
 	if (!cctxt) {
 		VCD_MSG_ERROR("%s(): Invalid parameter", __func__);
 		rc = VCD_ERR_ILLEGAL_PARM;
-	} else if (cctxt->sched_clnt_hdl) {
+	} else if (cctxt->sched_clnt_hdl)
 		VCD_MSG_HIGH(
 			"%s(): Scheduler client already exists!", __func__);
-	} else {
+	else {
 		sched_cctxt = (struct vcd_sched_clnt_ctx *)
 			kmalloc(sizeof(struct vcd_sched_clnt_ctx),
 					GFP_KERNEL);
@@ -88,8 +88,13 @@ u32 vcd_sched_add_client(struct vcd_clnt_ctxt *cctxt)
 			prop_hdr.sz = sizeof(cctxt->frm_p_units);
 			rc = ddl_get_property(cctxt->ddl_handle, &prop_hdr,
 						  &cctxt->frm_p_units);
-			VCD_FAILED_RETURN(rc,
-				"Failed: Get DDL_I_FRAME_PROC_UNITS");
+			if (VCD_FAILED(rc)) {
+				kfree(sched_cctxt);
+				VCD_MSG_ERROR(
+					"Failed: Get DDL_I_FRAME_PROC_UNITS");
+				return rc;
+			}
+
 			if (cctxt->decoding) {
 				cctxt->frm_rate.fps_numerator =
 					VCD_DEC_INITIAL_FRAME_RATE;
@@ -99,14 +104,21 @@ u32 vcd_sched_add_client(struct vcd_clnt_ctxt *cctxt)
 				prop_hdr.sz = sizeof(cctxt->frm_rate);
 				rc = ddl_get_property(cctxt->ddl_handle,
 						&prop_hdr, &cctxt->frm_rate);
-				VCD_FAILED_RETURN(rc,
-					"Failed: Get VCD_I_FRAME_RATE");
+				if (VCD_FAILED(rc)) {
+					kfree(sched_cctxt);
+					VCD_MSG_ERROR(
+						"Failed: Get VCD_I_FRAME_RATE");
+					return rc;
+				}
 			}
 			if (!cctxt->perf_set_by_client)
 				cctxt->reqd_perf_lvl = cctxt->frm_p_units *
 					cctxt->frm_rate.fps_numerator /
 					cctxt->frm_rate.fps_denominator;
-
+			VCD_MSG_HIGH("%s: client perf level = %u, "\
+				"perf_set_by_client = %u", __func__,
+				cctxt->reqd_perf_lvl,
+				cctxt->perf_set_by_client);
 			cctxt->sched_clnt_hdl = sched_cctxt;
 			memset(sched_cctxt, 0,
 				sizeof(struct vcd_sched_clnt_ctx));
@@ -215,8 +227,13 @@ u32 vcd_sched_mark_client_eof(struct vcd_sched_clnt_ctx *sched_cctxt)
 		buffer = list_entry(sched_cctxt->ip_frm_list.prev,
 			struct vcd_buffer_entry, sched_list);
 		buffer->frame.flags |= VCD_FRAME_FLAG_EOS;
-	} else
+		VCD_MSG_LOW("%s: added EOS flag to last buffer entry",
+			__func__);
+	} else {
 		rc = VCD_ERR_QEMPTY;
+		VCD_MSG_HIGH("%s: EOS need to be processed as last buffer",
+			__func__);
+	}
 	return rc;
 }
 
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_sub.c b/drivers/video/msm/vidc/common/vcd/vcd_sub.c
index 55eb7ca..c342191 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_sub.c
+++ b/drivers/video/msm/vidc/common/vcd/vcd_sub.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -92,7 +92,7 @@ static int vcd_pmem_alloc(size_t sz, u8 **kernel_vaddr, u8 **phy_addr,
 	} else {
 		map_buffer->alloc_handle = ion_alloc(
 			    cctxt->vcd_ion_client, sz, SZ_4K,
-			    memtype);
+			    memtype, res_trk_get_ion_flags());
 		if (!map_buffer->alloc_handle) {
 			pr_err("%s() ION alloc failed", __func__);
 			goto bailout;
@@ -105,8 +105,7 @@ static int vcd_pmem_alloc(size_t sz, u8 **kernel_vaddr, u8 **phy_addr,
 		}
 		*kernel_vaddr = (u8 *) ion_map_kernel(
 				cctxt->vcd_ion_client,
-				map_buffer->alloc_handle,
-				ionflag);
+				map_buffer->alloc_handle);
 		if (!(*kernel_vaddr)) {
 			pr_err("%s() ION map failed", __func__);
 			goto ion_free_bailout;
@@ -120,7 +119,7 @@ static int vcd_pmem_alloc(size_t sz, u8 **kernel_vaddr, u8 **phy_addr,
 				0,
 				(unsigned long *)&iova,
 				(unsigned long *)&buffer_size,
-				UNCACHED, 0);
+				0, 0);
 			if (ret || !iova) {
 				pr_err(
 				"%s() ION iommu map failed, ret = %d, iova = 0x%lx",
@@ -244,7 +243,6 @@ u8 *vcd_pmem_get_physical(struct video_client_ctx *client_ctx,
 		return (u8 *) phy_addr;
 	} else {
 		VCD_MSG_ERROR("Couldn't get physical address");
-		show_mem(SHOW_MEM_FILTER_NODES);
 
 		return NULL;
 	}
@@ -767,8 +765,8 @@ u32 vcd_free_one_buffer_internal(
 
 	buf_entry = vcd_find_buffer_pool_entry(buf_pool, buffer);
 	if (!buf_entry) {
-		VCD_MSG_ERROR("Buffer addr %p not found. Can't free buffer, buffer_type: %d",
-				buffer, buffer_type);
+		VCD_MSG_ERROR("Buffer addr %p not found. Can't free buffer",
+				  buffer);
 
 		return VCD_ERR_ILLEGAL_PARM;
 	}
@@ -786,7 +784,11 @@ u32 vcd_free_one_buffer_internal(
 		buf_pool->allocated--;
 	}
 
-	memset(buf_entry, 0, sizeof(struct vcd_buffer_entry));
+	buf_entry->valid = buf_entry->allocated = buf_entry->in_use = 0;
+	buf_entry->alloc = buf_entry->virtual = buf_entry->physical = NULL;
+	buf_entry->sz = 0;
+	memset(&buf_entry->frame, 0, sizeof(struct vcd_frame_data));
+
 	buf_pool->validated--;
 	if (buf_pool->validated == 0)
 		vcd_free_buffer_pool_entries(buf_pool);
@@ -922,18 +924,7 @@ struct vcd_buffer_entry *vcd_find_buffer_pool_entry
 	u32 i;
 	u32 found = false;
 
-	if (!pool) {
-		pr_info("[VID] %s: pool is NULL\n", __func__);
-		show_mem(SHOW_MEM_FILTER_NODES);
-		return NULL;
-	}
-	if (!(pool->entries)) {
-		pr_info("[VID] %s: pool->entries is NULL\n", __func__);
-		show_mem(SHOW_MEM_FILTER_NODES);
-		return NULL;
-	}
-
-	for (i = 0; i <= pool->count && !found; i++) {
+	for (i = 1; i <= pool->count && !found; i++) {
 		if (pool->entries[i].virtual == addr)
 			found = true;
 
@@ -1693,7 +1684,7 @@ u32 vcd_process_cmd_sess_start(struct vcd_clnt_ctxt *cctxt)
 void vcd_send_frame_done_in_eos(struct vcd_clnt_ctxt *cctxt,
 	 struct vcd_frame_data *input_frame, u32 valid_opbuf)
 {
-	VCD_MSG_LOW("vcd_send_frame_done_in_eos:");
+	VCD_MSG_HIGH("vcd_send_frame_done_in_eos:");
 
 	if (!input_frame->virtual && !valid_opbuf) {
 		VCD_MSG_MED("Sending NULL output with EOS");
@@ -1735,6 +1726,7 @@ void vcd_send_frame_done_in_eos_for_dec(
 	u32 rc;
 	struct ddl_frame_data_tag ddl_frm;
 
+	VCD_MSG_LOW("%s: ", __func__);
 	prop_hdr.prop_id = DDL_I_DPB_RETRIEVE;
 	prop_hdr.sz = sizeof(struct ddl_frame_data_tag);
 	memset(&ddl_frm, 0, sizeof(ddl_frm));
@@ -1813,36 +1805,79 @@ void vcd_send_frame_done_in_eos_for_enc(
 	}
 }
 
+struct vcd_transc *vcd_get_first_in_use_trans_for_clnt(
+	struct vcd_clnt_ctxt *cctxt)
+{
+	u32 i;
+	struct vcd_dev_ctxt *dev_ctxt;
+	VCD_MSG_HIGH("%s: ", __func__);
+	dev_ctxt = cctxt->dev_ctxt;
+	if (!dev_ctxt->trans_tbl) {
+		VCD_MSG_ERROR("%s: Null trans_tbl", __func__);
+		return NULL;
+	}
+	i = 0;
+	while (i < dev_ctxt->trans_tbl_size) {
+		if ((cctxt == dev_ctxt->trans_tbl[i].cctxt) &&
+			(dev_ctxt->trans_tbl[i].in_use)) {
+			VCD_MSG_MED("%s: found transc = 0x%p",
+				__func__, &dev_ctxt->trans_tbl[i]);
+			break;
+		}
+		i++;
+	}
+	if (i == dev_ctxt->trans_tbl_size) {
+		VCD_MSG_ERROR("%s: in_use transction not found",
+			__func__);
+		return NULL;
+	} else
+		return &dev_ctxt->trans_tbl[i];
+}
+
 u32 vcd_handle_recvd_eos(
 	struct vcd_clnt_ctxt *cctxt,
 	 struct vcd_frame_data *input_frame, u32 *pb_eos_handled)
 {
 	u32 rc;
-
+	struct vcd_transc *transc;
 	VCD_MSG_LOW("vcd_handle_recvd_eos:");
 
 	*pb_eos_handled = false;
 
 	if (input_frame->virtual &&
-			input_frame->data_len)
+			input_frame->data_len) {
+		VCD_MSG_LOW("%s: data available with EOS buffer", __func__);
 		return VCD_S_SUCCESS;
+	}
 
 	input_frame->data_len = 0;
 	rc = vcd_sched_mark_client_eof(cctxt->sched_clnt_hdl);
-	if (VCD_FAILED(rc) && rc != VCD_ERR_QEMPTY)
+	if (VCD_FAILED(rc) && rc != VCD_ERR_QEMPTY) {
+		VCD_MSG_LOW("%s: rc = %u", __func__, rc);
 		return rc;
+	}
 
-	if (rc == VCD_S_SUCCESS)
+	if (rc == VCD_S_SUCCESS) {
 		*pb_eos_handled = true;
-	else if (cctxt->decoding && !input_frame->virtual)
+		VCD_MSG_LOW("%s: EOS handled", __func__);
+	} else if (cctxt->decoding && !input_frame->virtual) {
 		cctxt->sched_clnt_hdl->tkns++;
-	else if (!cctxt->decoding) {
-		vcd_send_frame_done_in_eos(cctxt, input_frame, false);
-		if (cctxt->status.mask & VCD_EOS_WAIT_OP_BUF) {
-			vcd_do_client_state_transition(cctxt,
-				VCD_CLIENT_STATE_EOS,
-				CLIENT_STATE_EVENT_NUMBER
-				(encode_frame));
+		VCD_MSG_LOW("%s: decoding & virtual addr is NULL", __func__);
+	} else if (!cctxt->decoding && !cctxt->status.frame_delayed) {
+		if (!cctxt->status.frame_submitted) {
+			vcd_send_frame_done_in_eos(cctxt, input_frame, false);
+			if (cctxt->status.mask & VCD_EOS_WAIT_OP_BUF)
+				vcd_do_client_state_transition(cctxt,
+					VCD_CLIENT_STATE_EOS,
+					CLIENT_STATE_EVENT_NUMBER
+					(encode_frame));
+		} else {
+			transc = vcd_get_first_in_use_trans_for_clnt(cctxt);
+			if (transc) {
+				transc->flags |= VCD_FRAME_FLAG_EOS;
+				VCD_MSG_HIGH("%s: Add EOS flag to transc",
+				       __func__);
+			}
 		}
 		*pb_eos_handled = true;
 	}
@@ -1850,6 +1885,8 @@ u32 vcd_handle_recvd_eos(
 	if (*pb_eos_handled &&
 		input_frame->virtual &&
 		!input_frame->data_len) {
+		VCD_MSG_LOW("%s: sending INPUT_DONE as eos was handled",
+			__func__);
 		cctxt->callback(VCD_EVT_RESP_INPUT_DONE,
 				  VCD_S_SUCCESS,
 				  input_frame,
@@ -1893,9 +1930,16 @@ u32 vcd_setup_with_ddl_capabilities(struct vcd_dev_ctxt *dev_ctxt)
 		Prop_hdr.prop_id = DDL_I_CAPABILITY;
 		Prop_hdr.sz = sizeof(capability);
 
+		/*
+		** Since this is underlying core's property we don't need a
+		** ddl client handle.
+		*/
 		rc = ddl_get_property(NULL, &Prop_hdr, &capability);
 
 		if (!VCD_FAILED(rc)) {
+			/*
+			** Allocate the transaction table.
+			*/
 			dev_ctxt->trans_tbl_size =
 				(VCD_MAX_CLIENT_TRANSACTIONS *
 				capability.max_num_client) +
@@ -1986,12 +2030,12 @@ u32 vcd_handle_input_done(
 	transc = (struct vcd_transc *)frame->vcd_frm.ip_frm_tag;
 	orig_frame = vcd_find_buffer_pool_entry(&cctxt->in_buf_pool,
 					 transc->ip_buf_entry->virtual);
-	
+
 	if (!orig_frame) {
-		VCD_MSG_ERROR("Bad buffer addr: %p", transc->ip_buf_entry->virtual);
-		return VCD_ERR_FAIL;
+		rc = VCD_ERR_ILLEGAL_PARM;
+		VCD_FAILED_RETURN(rc, "Couldn't find buffer");
 	}
-	
+
 	if ((transc->ip_buf_entry->frame.virtual !=
 		 frame->vcd_frm.virtual)
 		|| !transc->ip_buf_entry->in_use) {
@@ -2018,8 +2062,11 @@ u32 vcd_handle_input_done(
 		return VCD_ERR_FAIL;
 	}
 
-	if (orig_frame != transc->ip_buf_entry)
+	if (orig_frame != transc->ip_buf_entry) {
+		VCD_MSG_HIGH("%s: free duplicate buffer", __func__);
 		kfree(transc->ip_buf_entry);
+		transc->ip_buf_entry = NULL;
+	}
 	transc->ip_buf_entry = NULL;
 	transc->input_done = true;
 
@@ -2030,7 +2077,7 @@ u32 vcd_handle_input_done(
 	}
 
 	if (VCD_FAILED(status)) {
-		VCD_MSG_ERROR("INPUT_DONE returned err = 0x%x", status);
+		VCD_MSG_HIGH("INPUT_DONE returned err = 0x%x", status);
 		vcd_handle_input_done_failed(cctxt, transc);
 	} else
 		cctxt->status.mask |= VCD_FIRST_IP_DONE;
@@ -2312,15 +2359,25 @@ u32 vcd_handle_frame_done(
 	op_frm->vcd_frm.time_stamp = transc->time_stamp;
 	op_frm->vcd_frm.ip_frm_tag = transc->ip_frm_tag;
 
-	if (transc->flags & VCD_FRAME_FLAG_EOSEQ)
-		op_frm->vcd_frm.flags |= VCD_FRAME_FLAG_EOSEQ;
-	else
-		op_frm->vcd_frm.flags &= ~VCD_FRAME_FLAG_EOSEQ;
+	if (!(op_frm->vcd_frm.flags & VCD_FRAME_FLAG_EOSEQ)) {
+		if (transc->flags & VCD_FRAME_FLAG_EOSEQ)
+			op_frm->vcd_frm.flags |= VCD_FRAME_FLAG_EOSEQ;
+		else
+			op_frm->vcd_frm.flags &= ~VCD_FRAME_FLAG_EOSEQ;
+	}
 
 	if (cctxt->decoding)
 		op_frm->vcd_frm.frame = transc->frame;
-	else
+	else {
 		transc->frame = op_frm->vcd_frm.frame;
+		if ((transc->flags & VCD_FRAME_FLAG_EOS) &&
+			!(op_frm->vcd_frm.flags & VCD_FRAME_FLAG_EOS)) {
+			op_frm->vcd_frm.flags |= VCD_FRAME_FLAG_EOS;
+			VCD_MSG_HIGH("%s: add EOS flag to the output "\
+				"from transc(0x%x)",
+				__func__, (u32)transc);
+		}
+	}
 	transc->frame_done = true;
 
 	if (transc->input_done && transc->frame_done) {
@@ -2442,6 +2499,7 @@ u32 vcd_handle_first_fill_output_buffer_for_enc(
 	struct vcd_sequence_hdr seq_hdr;
 	struct vcd_property_sps_pps_for_idr_enable idr_enable;
 	struct vcd_property_codec codec;
+	u8 *kernel_vaddr = NULL;
 	*handled = true;
 	prop_hdr.prop_id = DDL_I_SEQHDR_PRESENT;
 	prop_hdr.sz = sizeof(seqhdr_present);
@@ -2457,10 +2515,38 @@ u32 vcd_handle_first_fill_output_buffer_for_enc(
 	rc = ddl_get_property(cctxt->ddl_handle, &prop_hdr, &codec);
 	if (!VCD_FAILED(rc)) {
 		if (codec.codec != VCD_CODEC_H263) {
+			/*
+			 * The seq. header is stored in a seperate internal
+			 * buffer and is memcopied into the output buffer
+			 * that we provide.  In secure sessions, we aren't
+			 * allowed to touch these buffers.  In these cases
+			 * seq. headers are returned to client as part of
+			 * I-frames. So for secure session, just return
+			 * empty buffer.
+			 */
 			if (!cctxt->secure) {
 				prop_hdr.prop_id = VCD_I_SEQ_HEADER;
 				prop_hdr.sz = sizeof(struct vcd_sequence_hdr);
-				seq_hdr.sequence_header = frm_entry->virtual;
+				if (vcd_get_ion_status()) {
+					kernel_vaddr = (u8 *)ion_map_kernel(
+						cctxt->vcd_ion_client,
+						frm_entry->buff_ion_handle);
+					if (IS_ERR_OR_NULL(kernel_vaddr)) {
+						VCD_MSG_ERROR("%s: 0x%x = "\
+						"ion_map_kernel(0x%x, 0x%x) fail",
+						__func__,
+						(u32)kernel_vaddr,
+						(u32)cctxt->vcd_ion_client,
+						(u32)frm_entry->
+						buff_ion_handle);
+						return VCD_ERR_FAIL;
+					}
+				} else {
+					VCD_MSG_ERROR("%s: ION status is NULL",
+						__func__);
+					return VCD_ERR_FAIL;
+				}
+				seq_hdr.sequence_header = kernel_vaddr;
 				seq_hdr.sequence_header_len =
 					frm_entry->alloc_len;
 				rc = ddl_get_property(cctxt->ddl_handle,
@@ -2471,11 +2557,17 @@ u32 vcd_handle_first_fill_output_buffer_for_enc(
 					frm_entry->time_stamp = 0;
 					frm_entry->flags |=
 						VCD_FRAME_FLAG_CODECCONFIG;
+					VCD_MSG_LOW("%s: header len = %u",
+						__func__, frm_entry->data_len);
 				} else
 					VCD_MSG_ERROR("rc = 0x%x. Failed:"
 							"ddl_get_property: VCD_I_SEQ_HEADER",
 							rc);
 			} else {
+				/*
+				 * First check that the proper props are enabled
+				 * so  client can get the proper info eventually
+				 */
 				prop_hdr.prop_id = VCD_I_ENABLE_SPS_PPS_FOR_IDR;
 				prop_hdr.sz = sizeof(idr_enable);
 				rc = ddl_get_property(cctxt->ddl_handle,
@@ -2487,7 +2579,7 @@ u32 vcd_handle_first_fill_output_buffer_for_enc(
 							"needs to be enabled");
 						rc = VCD_ERR_BAD_STATE;
 					} else {
-						
+						/* Send zero len frame */
 						frm_entry->data_len = 0;
 						frm_entry->time_stamp = 0;
 						frm_entry->flags = 0;
@@ -2508,6 +2600,16 @@ u32 vcd_handle_first_fill_output_buffer_for_enc(
 		VCD_MSG_ERROR(
 			"rc = 0x%x. Failed: ddl_get_property:VCD_I_CODEC",
 			rc);
+	if (kernel_vaddr) {
+		if (!IS_ERR_OR_NULL(frm_entry->buff_ion_handle)) {
+			ion_map_kernel(cctxt->vcd_ion_client,
+				frm_entry->buff_ion_handle);
+		} else {
+			VCD_MSG_ERROR("%s: Invalid ion_handle (0x%x)",
+				__func__, (u32)frm_entry->buff_ion_handle);
+			rc = VCD_ERR_FAIL;
+		}
+	}
 	return rc;
 }
 
@@ -2775,6 +2877,7 @@ u32 vcd_handle_input_frame(
 	struct vcd_frame_data *frm_entry;
 	u32 rc = VCD_S_SUCCESS;
 	u32 eos_handled = false;
+	u32 duplicate_buffer = false;
 
 	VCD_MSG_LOW("vcd_handle_input_frame:");
 
@@ -2825,6 +2928,10 @@ u32 vcd_handle_input_frame(
 	}
 
 	if (orig_frame->in_use) {
+		/*
+		 * This path only allowed for enc., dec. not allowed
+		 * to queue same buffer multiple times
+		 */
 		if (cctxt->decoding) {
 			VCD_MSG_ERROR("An inuse input frame is being "
 					"re-queued to scheduler");
@@ -2838,6 +2945,10 @@ u32 vcd_handle_input_frame(
 		}
 
 		INIT_LIST_HEAD(&buf_entry->sched_list);
+		/*
+		 * Pre-emptively poisoning this, as these dupe entries
+		 * shouldn't get added to any list
+		 */
 		INIT_LIST_HEAD(&buf_entry->list);
 		buf_entry->list.next = LIST_POISON1;
 		buf_entry->list.prev = LIST_POISON2;
@@ -2848,8 +2959,10 @@ u32 vcd_handle_input_frame(
 		buf_entry->physical = orig_frame->physical;
 		buf_entry->sz = orig_frame->sz;
 		buf_entry->allocated = orig_frame->allocated;
-		buf_entry->in_use = 1; 
+		buf_entry->in_use = 1; /* meaningless for the dupe buffers */
 		buf_entry->frame = orig_frame->frame;
+		duplicate_buffer = true;
+		VCD_MSG_HIGH("%s: duplicate buffer", __func__);
 	} else
 		buf_entry = orig_frame;
 
@@ -2873,6 +2986,10 @@ u32 vcd_handle_input_frame(
 	if (VCD_FAILED(rc) || eos_handled) {
 		VCD_MSG_HIGH("rc = 0x%x, eos_handled = %d", rc,
 				 eos_handled);
+		if ((duplicate_buffer) && (buf_entry)) {
+			kfree(buf_entry);
+			buf_entry = NULL;
+		}
 
 		return rc;
 	}
@@ -3039,23 +3156,31 @@ u32 vcd_req_perf_level(
 	 struct vcd_property_perf_level *perf_level)
 {
 	u32 rc;
-	
-	s32 res_trk_perf_level;
-	
+	u32 res_trk_perf_level;
+	u32 turbo_perf_level;
 	if (!perf_level) {
 		VCD_MSG_ERROR("Invalid parameters\n");
 		return -EINVAL;
 	}
 	res_trk_perf_level = get_res_trk_perf_level(perf_level->level);
-	if (res_trk_perf_level < 0) {
+	if ((int)res_trk_perf_level < 0) {
 		rc = -ENOTSUPP;
+		VCD_MSG_ERROR("%s: unsupported perf level(%d)",
+			__func__, res_trk_perf_level);
 		goto perf_level_not_supp;
 	}
+	turbo_perf_level = get_res_trk_perf_level(VCD_PERF_LEVEL_TURBO);
 	rc = vcd_set_perf_level(cctxt->dev_ctxt, res_trk_perf_level);
 	if (!rc) {
 		cctxt->reqd_perf_lvl = res_trk_perf_level;
 		cctxt->perf_set_by_client = 1;
+		if (res_trk_perf_level == turbo_perf_level)
+			cctxt->is_turbo_enabled = true;
 	}
+	VCD_MSG_HIGH("%s: client perf level = %u, "\
+		"perf_set_by_client = %u, is_turbo_enabled = %u",
+		__func__, cctxt->reqd_perf_lvl, cctxt->perf_set_by_client,
+		cctxt->is_turbo_enabled);
 perf_level_not_supp:
 	return rc;
 }
@@ -3463,3 +3588,14 @@ u32 vcd_set_num_slices(struct vcd_clnt_ctxt *cctxt)
 	}
 	return rc;
 }
+
+u32 vcd_handle_ltr_use_failed(struct vcd_clnt_ctxt *cctxt,
+	void *payload, size_t sz, u32 status)
+{
+	u32 rc = VCD_S_SUCCESS;
+	if (payload && cctxt) {
+		cctxt->callback(VCD_EVT_IND_INFO_LTRUSE_FAILED,
+			status, payload, sz, cctxt, cctxt->client_data);
+	}
+	return rc;
+}
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_util.c b/drivers/video/msm/vidc/common/vcd/vcd_util.c
new file mode 100644
index 0000000..98bc7f5
--- /dev/null
+++ b/drivers/video/msm/vidc/common/vcd/vcd_util.c
@@ -0,0 +1,106 @@
+/* Copyright (c) 2010, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "vidc_type.h"
+#include "vcd_util.h"
+
+u32 vcd_critical_section_create(u32 **p_cs)
+{
+	struct mutex *lock;
+	if (!p_cs) {
+		VCD_MSG_ERROR("Bad critical section ptr");
+		return VCD_ERR_BAD_POINTER;
+	} else {
+		lock = kmalloc(sizeof(struct mutex), GFP_KERNEL);
+		if (!lock) {
+			VCD_MSG_ERROR("Failed: vcd_critical_section_create");
+			return VCD_ERR_ALLOC_FAIL;
+		}
+		mutex_init(lock);
+		*p_cs = (u32 *) lock;
+		return VCD_S_SUCCESS;
+	}
+}
+
+u32 vcd_critical_section_release(u32 *cs)
+{
+	struct mutex *lock = (struct mutex *)cs;
+	if (!lock) {
+		VCD_MSG_ERROR("Bad critical section object");
+		return VCD_ERR_BAD_POINTER;
+	}
+
+	mutex_destroy(lock);
+	kfree(cs);
+	return VCD_S_SUCCESS;
+}
+
+u32 vcd_critical_section_enter(u32 *cs)
+{
+	struct mutex *lock = (struct mutex *)cs;
+	if (!lock) {
+		VCD_MSG_ERROR("Bad critical section object");
+		return VCD_ERR_BAD_POINTER;
+	} else
+		mutex_lock(lock);
+
+	return VCD_S_SUCCESS;
+}
+
+u32 vcd_critical_section_leave(u32 *cs)
+{
+	struct mutex *lock = (struct mutex *)cs;
+
+	if (!lock) {
+		VCD_MSG_ERROR("Bad critical section object");
+
+		return VCD_ERR_BAD_POINTER;
+	} else
+		mutex_unlock(lock);
+
+	return VCD_S_SUCCESS;
+}
+
+int vcd_pmem_alloc(u32 size, u8 **kernel_vaddr, u8 **phy_addr)
+{
+	*phy_addr =
+	    (u8 *) pmem_kalloc(size, PMEM_MEMTYPE | PMEM_ALIGNMENT_4K);
+
+	if (!IS_ERR((void *)*phy_addr)) {
+
+		*kernel_vaddr = ioremap((unsigned long)*phy_addr, size);
+
+		if (!*kernel_vaddr) {
+			pr_err("%s: could not ioremap in kernel pmem buffers\n",
+			       __func__);
+			pmem_kfree((s32) *phy_addr);
+			return -ENOMEM;
+		}
+		pr_debug("write buf: phy addr 0x%08x kernel addr 0x%08x\n",
+			 (u32) *phy_addr, (u32) *kernel_vaddr);
+		return 0;
+	} else {
+		pr_err("%s: could not allocte in kernel pmem buffers\n",
+		       __func__);
+		return -ENOMEM;
+	}
+
+}
+
+int vcd_pmem_free(u8 *kernel_vaddr, u8 *phy_addr)
+{
+	iounmap((void *)kernel_vaddr);
+	pmem_kfree((s32) phy_addr);
+
+	return 0;
+}
diff --git a/drivers/video/msm/vidc/common/vcd/vcd_util.h b/drivers/video/msm/vidc/common/vcd/vcd_util.h
index 44a9387..7571b25 100644
--- a/drivers/video/msm/vidc/common/vcd/vcd_util.h
+++ b/drivers/video/msm/vidc/common/vcd/vcd_util.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,21 +15,22 @@
 #include <media/msm/vidc_type.h>
 #include <media/msm/vcd_api.h>
 
-#define VCD_MSG_LOW(xx_fmt...)				\
-if (vidc_msg_debug) {				\
-		printk(KERN_INFO "\n\t* [VID] " xx_fmt);\
-	}
-#define VCD_MSG_MED(xx_fmt...)				\
-	if (vidc_msg_debug) {				\
-		printk(KERN_INFO "\n  * [VID] " xx_fmt);\
-	}
-#define VCD_MSG_HIGH(xx_fmt...)				\
-	if (vidc_msg_debug) {				\
-		printk(KERN_WARNING "\n [VID] " xx_fmt);\
-	}
-
-#define VCD_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n [VID] err: " xx_fmt)
-#define VCD_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n [VID] <FATAL> " xx_fmt)
+#if DEBUG
+
+#define VCD_MSG_LOW(xx_fmt...)		printk(KERN_INFO "\n\t* " xx_fmt)
+#define VCD_MSG_MED(xx_fmt...)		printk(KERN_INFO "\n  * " xx_fmt)
+#define VCD_MSG_HIGH(xx_fmt...)		printk(KERN_WARNING "\n" xx_fmt)
+
+#else
+
+#define VCD_MSG_LOW(xx_fmt...)
+#define VCD_MSG_MED(xx_fmt...)
+#define VCD_MSG_HIGH(xx_fmt...)
+
+#endif
+
+#define VCD_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n err: " xx_fmt)
+#define VCD_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n<FATAL> " xx_fmt)
 
 #define VCD_FAILED_RETURN(rc, xx_fmt...)		\
 	do {						\
diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c
index 313a998..80e4645 100644
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@ -14,74 +14,11 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include "internal.h"
-#include <linux/ion.h>
-#include <linux/msm_kgsl.h>
 
 void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
 {
 }
 
-void show_meminfo(void)
-{
-	struct sysinfo i;
-	struct vmalloc_info vmi;
-	long cached;
-	unsigned long pages[NR_LRU_LISTS];
-	int lru;
-	unsigned long ion_alloc  = ion_iommu_heap_dump_size();
-	unsigned long kgsl_alloc = kgsl_get_alloc_size(1);
-	unsigned long subtotal;
-
-#define K(x) ((x) << (PAGE_SHIFT - 10))
-	si_meminfo(&i);
-	si_swapinfo(&i);
-	cached = global_page_state(NR_FILE_PAGES) -
-		total_swapcache_pages - i.bufferram;
-
-	if (cached < 0)
-		cached = 0;
-
-	get_vmalloc_info(&vmi);
-
-	for (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)
-		pages[lru] = global_page_state(NR_LRU_BASE + lru);
-
-	subtotal = K(i.freeram) + K(i.bufferram) +
-		K(cached) + K(global_page_state(NR_SHMEM)) + K(global_page_state(NR_MLOCK)) +
-		K(global_page_state(NR_ANON_PAGES)) +
-		K(global_page_state(NR_SLAB_RECLAIMABLE) + global_page_state(NR_SLAB_UNRECLAIMABLE)) +
-		(global_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024) +
-		K(global_page_state(NR_PAGETABLE)) +
-		(vmi.alloc >> 10) + (kgsl_alloc >> 10) + (ion_alloc >> 10);
-
-	printk("MemFree:        %8lu kB\n"
-			"Buffers:        %8lu kB\n"
-			"Cached:         %8lu kB\n"
-			"Shmem:          %8lu kB\n"
-			"Mlocked:        %8lu kB\n"
-			"AnonPages:      %8lu kB\n"
-			"Slab:           %8lu kB\n"
-			"PageTables:     %8lu kB\n"
-			"KernelStack:    %8lu kB\n"
-			"VmallocAlloc:   %8lu kB\n"
-			"ION_Alloc:      %8lu kB\n"
-			"KGSL_Alloc:     %8lu kB\n"
-			"Subtotal:       %8lu kB\n",
-			K(i.freeram),
-			K(i.bufferram),
-			K(cached),
-			K(global_page_state(NR_SHMEM)),
-			K(global_page_state(NR_MLOCK)),
-			K(global_page_state(NR_ANON_PAGES)),
-			K(global_page_state(NR_SLAB_RECLAIMABLE) + global_page_state(NR_SLAB_UNRECLAIMABLE)),
-			K(global_page_state(NR_PAGETABLE)),
-			global_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,
-			(vmi.alloc >> 10),
-			(ion_alloc >> 10),
-			(kgsl_alloc >> 10),
-			subtotal);
-}
-
 static int meminfo_proc_show(struct seq_file *m, void *v)
 {
 	struct sysinfo i;
@@ -91,8 +28,10 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 	long cached;
 	unsigned long pages[NR_LRU_LISTS];
 	int lru;
-	unsigned long kgsl_alloc = kgsl_get_alloc_size(0);
 
+/*
+ * display in kilobytes.
+ */
 #define K(x) ((x) << (PAGE_SHIFT - 10))
 	si_meminfo(&i);
 	si_swapinfo(&i);
@@ -110,6 +49,9 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 	for (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)
 		pages[lru] = global_page_state(NR_LRU_BASE + lru);
 
+	/*
+	 * Tagged format, for easy grepping and expansion.
+	 */
 	seq_printf(m,
 		"MemTotal:       %8lu kB\n"
 		"MemFree:        %8lu kB\n"
@@ -155,14 +97,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 		"Committed_AS:   %8lu kB\n"
 		"VmallocTotal:   %8lu kB\n"
 		"VmallocUsed:    %8lu kB\n"
-		"VmallocIoRemap: %8lu kB\n"
-		"VmallocAlloc:   %8lu kB\n"
-		"VmallocMap:     %8lu kB\n"
-		"VmallocUserMap: %8lu kB\n"
-		"VmallocVpage:   %8lu kB\n"
 		"VmallocChunk:   %8lu kB\n"
-		"KGSL_ALLOC:     %8lu kB\n"
-		"ION_ALLOC:      %8d kB\n"
 #ifdef CONFIG_MEMORY_FAILURE
 		"HardwareCorrupted: %5lu kB\n"
 #endif
@@ -221,14 +156,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 		K(committed),
 		(unsigned long)VMALLOC_TOTAL >> 10,
 		vmi.used >> 10,
-		vmi.ioremap >> 10,
-		vmi.alloc >> 10,
-		vmi.map >> 10,
-		vmi.usermap >> 10,
-		vmi.vpages >> 10,
-		vmi.largest_chunk >> 10,
-		kgsl_alloc >> 10,
-		ion_iommu_heap_dump_size() >> 10
+		vmi.largest_chunk >> 10
 #ifdef CONFIG_MEMORY_FAILURE
 		,atomic_long_read(&mce_bad_pages) << (PAGE_SHIFT - 10)
 #endif
diff --git a/include/asm-generic/dma-coherent.h b/include/asm-generic/dma-coherent.h
index 41c14c4..abfb268 100644
--- a/include/asm-generic/dma-coherent.h
+++ b/include/asm-generic/dma-coherent.h
@@ -2,10 +2,19 @@
 #define DMA_COHERENT_H
 
 #ifdef CONFIG_HAVE_GENERIC_DMA_COHERENT
+/*
+ * These three functions are only for dma allocator.
+ * Don't use them in device drivers.
+ */
 int dma_alloc_from_coherent(struct device *dev, ssize_t size,
 				       dma_addr_t *dma_handle, void **ret);
 int dma_release_from_coherent(struct device *dev, int order, void *vaddr);
 
+int dma_mmap_from_coherent(struct device *dev, struct vm_area_struct *vma,
+			    void *cpu_addr, size_t size, int *ret);
+/*
+ * Standard interface
+ */
 #define ARCH_HAS_DMA_DECLARE_COHERENT_MEMORY
 extern int
 dma_declare_coherent_memory(struct device *dev, dma_addr_t bus_addr,
diff --git a/include/asm-generic/pci-dma-compat.h b/include/asm-generic/pci-dma-compat.h
index aff252d..03cbc89 100644
--- a/include/asm-generic/pci-dma-compat.h
+++ b/include/asm-generic/pci-dma-compat.h
@@ -1,9 +1,21 @@
 
-#ifndef _ASM_GENERIC_PCI_DMA_COMPAT_H
+
 #define _ASM_GENERIC_PCI_DMA_COMPAT_H
 
 #include <linux/dma-mapping.h>
 
+#define dma_map_single_attrs(dev, cpu_addr, size, dir, attrs) \
+	dma_map_single(dev, cpu_addr, size, dir)
+
+#define dma_unmap_single_attrs(dev, dma_addr, size, dir, attrs) \
+	dma_unmap_single(dev, dma_addr, size, dir)
+
+#define dma_map_sg_attrs(dev, sgl, nents, dir, attrs) \
+	dma_map_sg(dev, sgl, nents, dir)
+
+#define dma_unmap_sg_attrs(dev, sgl, nents, dir, attrs) \
+	dma_unmap_sg(dev, sgl, nents, dir)
+	
 static inline int
 pci_dma_supported(struct pci_dev *hwdev, u64 mask)
 {
@@ -111,4 +123,4 @@ static inline int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 }
 #endif
 
-#endif
+
diff --git a/include/linux/device.h b/include/linux/device.h
index f33b8cd..3abbc0e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -35,6 +35,7 @@
 struct bus_type;
 struct device_node;
 struct iommu_ops;
+struct iommu_group;
 
 struct bus_attribute {
 	struct attribute	attr;
diff --git a/include/linux/dma-attrs.h b/include/linux/dma-attrs.h
index e164e70..18513e3 100644
--- a/include/linux/dma-attrs.h
+++ b/include/linux/dma-attrs.h
@@ -5,16 +5,27 @@
 #include <linux/bitops.h>
 #include <linux/bug.h>
 
+/**
+ * an enum dma_attr represents an attribute associated with a DMA
+ * mapping. The semantics of each attribute should be defined in
+ * Documentation/DMA-attributes.txt.
+ */
 enum dma_attr {
 	DMA_ATTR_WRITE_BARRIER,
 	DMA_ATTR_WEAK_ORDERING,
 	DMA_ATTR_WRITE_COMBINE,
 	DMA_ATTR_NON_CONSISTENT,
+	DMA_ATTR_NO_KERNEL_MAPPING,
+	DMA_ATTR_STRONGLY_ORDERED,
 	DMA_ATTR_MAX,
 };
 
 #define __DMA_ATTRS_LONGS BITS_TO_LONGS(DMA_ATTR_MAX)
 
+/**
+ * struct dma_attrs - an opaque container for DMA attributes
+ * @flags - bitmask representing a collection of enum dma_attr
+ */
 struct dma_attrs {
 	unsigned long flags[__DMA_ATTRS_LONGS];
 };
@@ -30,6 +41,11 @@ static inline void init_dma_attrs(struct dma_attrs *attrs)
 }
 
 #ifdef CONFIG_HAVE_DMA_ATTRS
+/**
+ * dma_set_attr - set a specific attribute
+ * @attr: attribute to set
+ * @attrs: struct dma_attrs (may be NULL)
+ */
 static inline void dma_set_attr(enum dma_attr attr, struct dma_attrs *attrs)
 {
 	if (attrs == NULL)
@@ -38,6 +54,11 @@ static inline void dma_set_attr(enum dma_attr attr, struct dma_attrs *attrs)
 	__set_bit(attr, attrs->flags);
 }
 
+/**
+ * dma_get_attr - check for a specific attribute
+ * @attr: attribute to set
+ * @attrs: struct dma_attrs (may be NULL)
+ */
 static inline int dma_get_attr(enum dma_attr attr, struct dma_attrs *attrs)
 {
 	if (attrs == NULL)
@@ -45,7 +66,7 @@ static inline int dma_get_attr(enum dma_attr attr, struct dma_attrs *attrs)
 	BUG_ON(attr >= DMA_ATTR_MAX);
 	return test_bit(attr, attrs->flags);
 }
-#else 
+#else /* !CONFIG_HAVE_DMA_ATTRS */
 static inline void dma_set_attr(enum dma_attr attr, struct dma_attrs *attrs)
 {
 }
@@ -54,5 +75,5 @@ static inline int dma_get_attr(enum dma_attr attr, struct dma_attrs *attrs)
 {
 	return 0;
 }
-#endif 
-#endif 
+#endif /* CONFIG_HAVE_DMA_ATTRS */
+#endif /* _DMA_ATTR_H */
diff --git a/include/linux/ion.h b/include/linux/ion.h
index 5c9175e..c56faa4 100644
--- a/include/linux/ion.h
+++ b/include/linux/ion.h
@@ -2,7 +2,7 @@
  * include/linux/ion.h
  *
  * Copyright (C) 2011 Google, Inc.
- * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -22,83 +22,43 @@
 #include <linux/types.h>
 
 struct ion_handle;
+/**
+ * enum ion_heap_types - list of all possible types of heaps
+ * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
+ * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
+ * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
+ * @ION_HEAP_TYPE_IOMMU: IOMMU memory
+ * @ION_HEAP_TYPE_CP:	 memory allocated from a prereserved
+ *				carveout heap, allocations are physically
+ *				contiguous. Used for content protection.
+ * @ION_HEAP_TYPE_DMA:          memory allocated via DMA API
+ * @ION_HEAP_END:		helper for iterating over heaps
+ */
 enum ion_heap_type {
 	ION_HEAP_TYPE_SYSTEM,
 	ION_HEAP_TYPE_SYSTEM_CONTIG,
 	ION_HEAP_TYPE_CARVEOUT,
-	ION_HEAP_TYPE_IOMMU,
-	ION_HEAP_TYPE_CP,
-	ION_HEAP_TYPE_CUSTOM, 
+	ION_HEAP_TYPE_DMA,
+	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
+				 are at the end of this enum */
 	ION_NUM_HEAPS,
 };
 
 #define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
 #define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
 #define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
-#define ION_HEAP_CP_MASK		(1 << ION_HEAP_TYPE_CP)
-
-
-
-enum ion_heap_ids {
-	INVALID_HEAP_ID = -1,
-	ION_CP_MM_HEAP_ID = 8,
-	ION_CP_ROTATOR_HEAP_ID = 9,
-	ION_CP_MFC_HEAP_ID = 12,
-	ION_CP_WB_HEAP_ID = 16, 
-	ION_CAMERA_HEAP_ID = 20, 
-	ION_SF_HEAP_ID = 24,
-	ION_IOMMU_HEAP_ID = 25,
-	ION_QSECOM_HEAP_ID = 27,
-	ION_AUDIO_HEAP_ID = 28,
-
-	ION_MM_FIRMWARE_HEAP_ID = 29,
-	ION_SYSTEM_HEAP_ID = 30,
-
-	ION_HEAP_ID_RESERVED = 31 
-};
-
-enum ion_fixed_position {
-	NOT_FIXED,
-	FIXED_LOW,
-	FIXED_MIDDLE,
-	FIXED_HIGH,
-};
-
-enum cp_mem_usage {
-	VIDEO_BITSTREAM = 0x1,
-	VIDEO_PIXEL = 0x2,
-	VIDEO_NONPIXEL = 0x3,
-	MAX_USAGE = 0x4,
-	UNKNOWN = 0x7FFFFFFF,
-};
-
-#define ION_SECURE (1 << ION_HEAP_ID_RESERVED)
-
-#define ION_HEAP(bit) (1 << (bit))
-
-#define ION_VMALLOC_HEAP_NAME	"vmalloc"
-#define ION_AUDIO_HEAP_NAME	"audio"
-#define ION_SF_HEAP_NAME	"sf"
-#define ION_MM_HEAP_NAME	"mm"
-#define ION_ROTATOR_HEAP_NAME   "rotator"
-#define ION_CAMERA_HEAP_NAME	"camera_preview"
-#define ION_IOMMU_HEAP_NAME	"iommu"
-#define ION_MFC_HEAP_NAME	"mfc"
-#define ION_WB_HEAP_NAME	"wb"
-#define ION_MM_FIRMWARE_HEAP_NAME	"mm_fw"
-#define ION_QSECOM_HEAP_NAME	"qsecom"
-#define ION_FMEM_HEAP_NAME	"fmem"
-
-#define CACHED          1
-#define UNCACHED        0
-
-#define ION_CACHE_SHIFT 0
-
-#define ION_SET_CACHE(__cache)  ((__cache) << ION_CACHE_SHIFT)
+#define ION_HEAP_TYPE_DMA_MASK         (1 << ION_HEAP_TYPE_DMA)
 
-#define ION_IS_CACHED(__flags)	((__flags) & (1 << ION_CACHE_SHIFT))
-
-#define ION_IOMMU_UNMAP_DELAYED 1
+/**
+ * heap flags - the lower 16 bits are used by core ion, the upper 16
+ * bits are reserved for use by the heaps themselves.
+ */
+#define ION_FLAG_CACHED 1		/* mappings of this buffer should be
+					   cached, ion will do cache
+					   maintenance when the buffer is
+					   mapped for dma */
 
 #ifdef __KERNEL__
 #include <linux/err.h>
@@ -109,9 +69,26 @@ enum cp_mem_usage {
 struct ion_client;
 struct ion_buffer;
 
+/* This should be removed some day when phys_addr_t's are fully
+   plumbed in the kernel, and all instances of ion_phys_addr_t should
+   be converted to phys_addr_t.  For the time being many kernel interfaces
+   do not accept phys_addr_t's that would have to */
 #define ion_phys_addr_t unsigned long
 #define ion_virt_addr_t unsigned long
 
+/**
+ * struct ion_platform_heap - defines a heap in the given platform
+ * @type:	type of the heap from ion_heap_type enum
+ * @id:		unique identifier for heap.  When allocating (lower numbers
+ * 		will be allocated from first)
+ * @name:	used for debug purposes
+ * @base:	base address of heap in physical memory if applicable
+ * @size:	size of the heap in bytes if applicable
+ * @memory_type:Memory type used for the heap
+ * @has_outer_cache:    set to 1 if outer cache is used, 0 otherwise.
+ * @extra_data:	Extra data specific to each heap type
+ * @priv:	heap private data
+ */
 struct ion_platform_heap {
 	enum ion_heap_type type;
 	unsigned int id;
@@ -121,80 +98,202 @@ struct ion_platform_heap {
 	enum ion_memory_types memory_type;
 	unsigned int has_outer_cache;
 	void *extra_data;
+	void *priv;
 };
 
-struct ion_cp_heap_pdata {
-	enum ion_permission_type permission_type;
-	unsigned int align;
-	ion_phys_addr_t secure_base; 
-	size_t secure_size; 
-	int reusable;
-	int mem_is_fmem;
-	enum ion_fixed_position fixed_position;
-	int iommu_map_all;
-	int iommu_2x_map_domain;
-	ion_virt_addr_t *virt_addr;
-	int (*request_region)(void *);
-	int (*release_region)(void *);
-	void *(*setup_region)(void);
-};
-
-struct ion_co_heap_pdata {
-	int adjacent_mem_id;
-	unsigned int align;
-	int mem_is_fmem;
-	enum ion_fixed_position fixed_position;
-	int (*request_region)(void *);
-	int (*release_region)(void *);
-	void *(*setup_region)(void);
-};
-
+/**
+ * struct ion_platform_data - array of platform heaps passed from board file
+ * @has_outer_cache:    set to 1 if outer cache is used, 0 otherwise.
+ * @nr:    number of structures in the array
+ * @request_region: function to be called when the number of allocations goes
+ *						from 0 -> 1
+ * @release_region: function to be called when the number of allocations goes
+ *						from 1 -> 0
+ * @setup_region:   function to be called upon ion registration
+ * @heaps: array of platform_heap structions
+ *
+ * Provided by the board file in the form of platform data to a platform device.
+ */
 struct ion_platform_data {
 	unsigned int has_outer_cache;
 	int nr;
 	int (*request_region)(void *);
 	int (*release_region)(void *);
 	void *(*setup_region)(void);
-	struct ion_platform_heap heaps[];
+	struct ion_platform_heap *heaps;
 };
 
 #ifdef CONFIG_ION
 
+/**
+ * ion_reserve() - reserve memory for ion heaps if applicable
+ * @data:	platform data specifying starting physical address and
+ *		size
+ *
+ * Calls memblock reserve to set aside memory for heaps that are
+ * located at specific memory addresses or of specfic sizes not
+ * managed by the kernel
+ */
 void ion_reserve(struct ion_platform_data *data);
 
+/**
+ * ion_client_create() -  allocate a client and returns it
+ * @dev:	the global ion device
+ * @heap_mask:	mask of heaps this client can allocate from
+ * @name:	used for debugging
+ */
 struct ion_client *ion_client_create(struct ion_device *dev,
 				     unsigned int heap_mask, const char *name);
 
+/**
+ *  msm_ion_client_create - allocate a client using the ion_device specified in
+ *				drivers/gpu/ion/msm/msm_ion.c
+ *
+ * heap_mask and name are the same as ion_client_create, return values
+ * are the same as ion_client_create.
+ */
 
 struct ion_client *msm_ion_client_create(unsigned int heap_mask,
 					const char *name);
 
+/**
+ * ion_client_destroy() -  free's a client and all it's handles
+ * @client:	the client
+ *
+ * Free the provided client and all it's resources including
+ * any handles it is holding.
+ */
 void ion_client_destroy(struct ion_client *client);
 
+/**
+ * ion_alloc - allocate ion memory
+ * @client:	the client
+ * @len:	size of the allocation
+ * @align:	requested allocation alignment, lots of hardware blocks have
+ *		alignment requirements of some kind
+ * @heap_mask:	mask of heaps to allocate from, if multiple bits are set
+ *		heaps will be tried in order from lowest to highest order bit
+ * @flags:	heap flags, the low 16 bits are consumed by ion, the high 16
+ *		bits are passed on to the respective heap and can be heap
+ *		custom
+ *
+ * Allocate memory in one of the heaps provided in heap mask and return
+ * an opaque handle to it.
+ */
 struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
-			     size_t align, unsigned int flags);
+			     size_t align, unsigned int heap_mask,
+			     unsigned int flags);
 
+/**
+ * ion_free - free a handle
+ * @client:	the client
+ * @handle:	the handle to free
+ *
+ * Free the provided handle.
+ */
 void ion_free(struct ion_client *client, struct ion_handle *handle);
 
+/**
+ * ion_phys - returns the physical address and len of a handle
+ * @client:	the client
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_sg_table should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
 int ion_phys(struct ion_client *client, struct ion_handle *handle,
 	     ion_phys_addr_t *addr, size_t *len);
 
+/**
+ * ion_map_dma - return an sg_table describing a handle
+ * @client:	the client
+ * @handle:	the handle
+ *
+ * This function returns the sg_table describing
+ * a particular ion handle.
+ */
 struct sg_table *ion_sg_table(struct ion_client *client,
 			      struct ion_handle *handle);
 
-void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle,
-			unsigned long flags);
+/**
+ * ion_map_kernel - create mapping for the given handle
+ * @client:	the client
+ * @handle:	handle to map
+ * @flags:	flags for this mapping
+ *
+ * Map the given handle into the kernel and return a kernel address that
+ * can be used to access this address. If no flags are specified, this
+ * will return a non-secure uncached mapping.
+ */
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
 
+/**
+ * ion_unmap_kernel() - destroy a kernel mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
 void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
 
+/**
+ * ion_share_dma_buf() - given an ion client, create a dma-buf fd
+ * @client:	the client
+ * @handle:	the handle
+ */
 int ion_share_dma_buf(struct ion_client *client, struct ion_handle *handle);
 
+/**
+ * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
+ * @client:	the client
+ * @fd:		the dma-buf fd
+ *
+ * Given an dma-buf fd that was allocated through ion via ion_share_dma_buf,
+ * import that fd and return a handle representing it.  If a dma-buf from
+ * another exporter is passed in this function will return ERR_PTR(-EINVAL)
+ */
 struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd);
 
+/**
+ * ion_handle_get_flags - get the flags for a given handle
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to get the flags
+ * @flags - pointer to store the flags
+ *
+ * Gets the current flags for a handle. These flags indicate various options
+ * of the buffer (caching, security, etc.)
+ */
 int ion_handle_get_flags(struct ion_client *client, struct ion_handle *handle,
 				unsigned long *flags);
 
 
+/**
+ * ion_map_iommu - map the given handle into an iommu
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to map
+ * @domain_num - domain number to map to
+ * @partition_num - partition number to allocate iova from
+ * @align - alignment for the iova
+ * @iova_length - length of iova to map. If the iova length is
+ *		greater than the handle length, the remaining
+ *		address space will be mapped to a dummy buffer.
+ * @iova - pointer to store the iova address
+ * @buffer_size - pointer to store the size of the buffer
+ * @flags - flags for options to map
+ * @iommu_flags - flags specific to the iommu.
+ *
+ * Maps the handle into the iova space specified via domain number. Iova
+ * will be allocated from the partition specified via partition_num.
+ * Returns 0 on success, negative value on error.
+ */
 int ion_map_iommu(struct ion_client *client, struct ion_handle *handle,
 			int domain_num, int partition_num, unsigned long align,
 			unsigned long iova_length, unsigned long *iova,
@@ -202,33 +301,83 @@ int ion_map_iommu(struct ion_client *client, struct ion_handle *handle,
 			unsigned long flags, unsigned long iommu_flags);
 
 
+/**
+ * ion_handle_get_size - get the allocated size of a given handle
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to get the size
+ * @size - pointer to store the size
+ *
+ * gives the allocated size of a handle. returns 0 on success, negative
+ * value on error
+ *
+ * NOTE: This is intended to be used only to get a size to pass to map_iommu.
+ * You should *NOT* rely on this for any other usage.
+ */
 
 int ion_handle_get_size(struct ion_client *client, struct ion_handle *handle,
 			unsigned long *size);
 
+/**
+ * ion_unmap_iommu - unmap the handle from an iommu
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to unmap
+ * @domain_num - domain to unmap from
+ * @partition_num - partition to unmap from
+ *
+ * Decrement the reference count on the iommu mapping. If the count is
+ * 0, the mapping will be removed from the iommu.
+ */
 void ion_unmap_iommu(struct ion_client *client, struct ion_handle *handle,
 			int domain_num, int partition_num);
 
 
+/**
+ * ion_secure_heap - secure a heap
+ *
+ * @client - a client that has allocated from the heap heap_id
+ * @heap_id - heap id to secure.
+ * @version - version of content protection
+ * @data - extra data needed for protection
+ *
+ * Secure a heap
+ * Returns 0 on success
+ */
 int ion_secure_heap(struct ion_device *dev, int heap_id, int version,
 			void *data);
 
+/**
+ * ion_unsecure_heap - un-secure a heap
+ *
+ * @client - a client that has allocated from the heap heap_id
+ * @heap_id - heap id to un-secure.
+ * @version - version of content protection
+ * @data - extra data needed for protection
+ *
+ * Un-secure a heap
+ * Returns 0 on success
+ */
 int ion_unsecure_heap(struct ion_device *dev, int heap_id, int version,
 			void *data);
 
-int msm_ion_secure_heap(int heap_id);
-
-int msm_ion_unsecure_heap(int heap_id);
-
-int msm_ion_secure_heap_2_0(int heap_id, enum cp_mem_usage usage);
-
-int msm_ion_unsecure_heap_2_0(int heap_id, enum cp_mem_usage usage);
-
+/**
+ * msm_ion_do_cache_op - do cache operations.
+ *
+ * @client - pointer to ION client.
+ * @handle - pointer to buffer handle.
+ * @vaddr -  virtual address to operate on.
+ * @len - Length of data to do cache operation on.
+ * @cmd - Cache operation to perform:
+ *		ION_IOC_CLEAN_CACHES
+ *		ION_IOC_INV_CACHES
+ *		ION_IOC_CLEAN_INV_CACHES
+ *
+ * Returns 0 on success
+ */
 int msm_ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,
 			void *vaddr, unsigned long len, unsigned int cmd);
 
-int ion_iommu_heap_dump_size(void);
-
 #else
 static inline void ion_reserve(struct ion_platform_data *data)
 {
@@ -250,7 +399,9 @@ static inline struct ion_client *msm_ion_client_create(unsigned int heap_mask,
 static inline void ion_client_destroy(struct ion_client *client) { }
 
 static inline struct ion_handle *ion_alloc(struct ion_client *client,
-			size_t len, size_t align, unsigned int flags)
+					size_t len, size_t align,
+					unsigned int heap_mask,
+					unsigned int flags)
 {
 	return ERR_PTR(-ENODEV);
 }
@@ -327,28 +478,6 @@ static inline int ion_unsecure_heap(struct ion_device *dev, int heap_id,
 	return -ENODEV;
 }
 
-static inline int msm_ion_secure_heap(int heap_id)
-{
-	return -ENODEV;
-
-}
-
-static inline int msm_ion_unsecure_heap(int heap_id)
-{
-	return -ENODEV;
-}
-
-static inline int msm_ion_secure_heap_2_0(int heap_id, enum cp_mem_usage usage)
-{
-	return -ENODEV;
-}
-
-static inline int msm_ion_unsecure_heap_2_0(int heap_id,
-					enum cp_mem_usage usage)
-{
-	return -ENODEV;
-}
-
 static inline int msm_ion_do_cache_op(struct ion_client *client,
 			struct ion_handle *handle, void *vaddr,
 			unsigned long len, unsigned int cmd)
@@ -356,80 +485,158 @@ static inline int msm_ion_do_cache_op(struct ion_client *client,
 	return -ENODEV;
 }
 
-#endif 
-#endif 
+#endif /* CONFIG_ION */
+#endif /* __KERNEL__ */
 
+/**
+ * DOC: Ion Userspace API
+ *
+ * create a client by opening /dev/ion
+ * most operations handled via following ioctls
+ *
+ */
 
+/**
+ * struct ion_allocation_data - metadata passed from userspace for allocations
+ * @len:	size of the allocation
+ * @align:	required alignment of the allocation
+ * @heap_mask:	mask of heaps to allocate from
+ * @flags:	flags passed to heap
+ * @handle:	pointer that will be populated with a cookie to use to refer
+ *		to this allocation
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
 struct ion_allocation_data {
 	size_t len;
 	size_t align;
+	unsigned int heap_mask;
 	unsigned int flags;
 	struct ion_handle *handle;
 };
 
+
+struct ion_allocation_data_compat {
+	size_t len;
+	size_t align;
+	unsigned int flags;
+	struct ion_handle *handle;
+};
+/**
+ * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
+ * @handle:	a handle
+ * @fd:		a file descriptor representing that handle
+ *
+ * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
+ * the handle returned from ion alloc, and the kernel returns the file
+ * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
+ * provides the file descriptor and the kernel returns the handle.
+ */
 struct ion_fd_data {
 	struct ion_handle *handle;
 	int fd;
 };
 
+/**
+ * struct ion_handle_data - a handle passed to/from the kernel
+ * @handle:	a handle
+ */
 struct ion_handle_data {
 	struct ion_handle *handle;
 };
 
+/**
+ * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
+ * @cmd:	the custom ioctl function to call
+ * @arg:	additional data to pass to the custom ioctl, typically a user
+ *		pointer to a predefined structure
+ *
+ * This works just like the regular cmd and arg fields of an ioctl.
+ */
 struct ion_custom_data {
 	unsigned int cmd;
 	unsigned long arg;
 };
 
-
 struct ion_flush_data {
-	struct ion_handle *handle;
-	int fd;
-	void *vaddr;
-	unsigned int offset;
-	unsigned int length;
+        struct ion_handle *handle;
+        int fd;
+        void *vaddr;
+        unsigned int offset;
+        unsigned int length;
 };
-
 struct ion_flag_data {
-	struct ion_handle *handle;
-	unsigned long flags;
+        struct ion_handle *handle;
+        unsigned long flags;
 };
 
 #define ION_IOC_MAGIC		'I'
 
+/**
+ * DOC: ION_IOC_ALLOC - allocate memory
+ *
+ * Takes an ion_allocation_data struct and returns it with the handle field
+ * populated with the opaque handle for the allocation.
+ */
 #define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
 				      struct ion_allocation_data)
 
+
+#define ION_IOC_ALLOC_COMPAT		_IOWR(ION_IOC_MAGIC, 0, \
+				      struct ion_allocation_data_compat)
+/**
+ * DOC: ION_IOC_FREE - free memory
+ *
+ * Takes an ion_handle_data struct and frees the handle.
+ */
 #define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
 
+/**
+ * DOC: ION_IOC_MAP - get a file descriptor to mmap
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be used as an argument to mmap.
+ */
 #define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
 
+/**
+ * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be passed to another process.  The corresponding opaque handle can
+ * be retrieved via ION_IOC_IMPORT.
+ */
 #define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
 
-#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, int)
+/**
+ * DOC: ION_IOC_IMPORT - imports a shared file descriptor
+ *
+ * Takes an ion_fd_data struct with the fd field populated with a valid file
+ * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
+ * filed set to the corresponding opaque handle.
+ */
+#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, struct ion_fd_data)
+#define ION_IOC_IMPORT_COMPAT		_IOWR(ION_IOC_MAGIC, 5, int)
 
+/**
+ * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
+ *
+ * Takes the argument of the architecture specific ioctl to call and
+ * passes appropriate userdata for that ioctl
+ */
 #define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
 
-#define ION_IOC_CLEAN_CACHES_OLD	_IOWR(ION_IOC_MAGIC, 7, \
-						struct ion_flush_data)
-#define ION_IOC_INV_CACHES_OLD	_IOWR(ION_IOC_MAGIC, 8, \
-						struct ion_flush_data)
-#define ION_IOC_CLEAN_INV_CACHES_OLD	_IOWR(ION_IOC_MAGIC, 9, \
-						struct ion_flush_data)
-
-#define ION_IOC_GET_FLAGS_OLD		_IOWR(ION_IOC_MAGIC, 10, \
-						struct ion_flag_data)
-
-#define ION_IOC_MSM_MAGIC 'M'
-
-#define ION_IOC_CLEAN_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 0, \
-						struct ion_flush_data)
-#define ION_IOC_INV_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 1, \
-						struct ion_flush_data)
-#define ION_IOC_CLEAN_INV_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 2, \
-						struct ion_flush_data)
-
-#define ION_IOC_GET_FLAGS		_IOWR(ION_IOC_MSM_MAGIC, 3, \
-						struct ion_flag_data)
+#define ION_IOC_CLEAN_CACHES_COMPAT    _IOWR(ION_IOC_MAGIC, 7, \
+                                                struct ion_flush_data)
+#define ION_IOC_INV_CACHES_COMPAT      _IOWR(ION_IOC_MAGIC, 8, \
+                                                struct ion_flush_data)
+#define ION_IOC_CLEAN_INV_CACHES_COMPAT       _IOWR(ION_IOC_MAGIC, 9, \
+                                                struct ion_flush_data)
+#define ION_IOC_GET_FLAGS_COMPAT               _IOWR(ION_IOC_MAGIC, 10, \
+                                                struct ion_flag_data)
 
-#endif 
+#endif /* _LINUX_ION_H */
diff --git a/include/linux/msm_ion.h b/include/linux/msm_ion.h
index 0e28e54..d7d7507 100644
--- a/include/linux/msm_ion.h
+++ b/include/linux/msm_ion.h
@@ -1,7 +1,6 @@
 /*
- * include/linux/ion.h
  *
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -19,4 +18,321 @@
 
 #include <linux/ion.h>
 
+enum msm_ion_heap_types {
+	ION_HEAP_TYPE_MSM_START = ION_HEAP_TYPE_CUSTOM + 1,
+	ION_HEAP_TYPE_IOMMU = ION_HEAP_TYPE_MSM_START,
+	ION_HEAP_TYPE_CP,
+};
+
+/**
+ * These are the only ids that should be used for Ion heap ids.
+ * The ids listed are the order in which allocation will be attempted
+ * if specified. Don't swap the order of heap ids unless you know what
+ * you are doing!
+ * Id's are spaced by purpose to allow new Id's to be inserted in-between (for
+ * possible fallbacks)
+ */
+
+enum ion_heap_ids {
+	INVALID_HEAP_ID = -1,
+	ION_CP_MM_HEAP_ID = 8,
+	ION_CP_MFC_HEAP_ID = 12,
+	ION_CP_WB_HEAP_ID = 16, /* 8660 only */
+	ION_CAMERA_HEAP_ID = 20, /* 8660 only */
+	ION_SYSTEM_CONTIG_HEAP_ID = 21,
+	ION_ADSP_HEAP_ID = 22,
+	ION_SF_HEAP_ID = 24,
+	ION_IOMMU_HEAP_ID = 25,
+	ION_QSECOM_HEAP_ID = 27,
+	ION_AUDIO_HEAP_ID = 28,
+
+	ION_MM_FIRMWARE_HEAP_ID = 29,
+	ION_SYSTEM_HEAP_ID = 30,
+
+	ION_HEAP_ID_RESERVED = 31 /** Bit reserved for ION_SECURE flag */
+};
+
+enum ion_fixed_position {
+	NOT_FIXED,
+	FIXED_LOW,
+	FIXED_MIDDLE,
+	FIXED_HIGH,
+};
+
+enum cp_mem_usage {
+	VIDEO_BITSTREAM = 0x1,
+	VIDEO_PIXEL = 0x2,
+	VIDEO_NONPIXEL = 0x3,
+	MAX_USAGE = 0x4,
+	UNKNOWN = 0x7FFFFFFF,
+};
+
+#define ION_HEAP_CP_MASK		(1 << ION_HEAP_TYPE_CP)
+
+/**
+ * Flag to use when allocating to indicate that a heap is secure.
+ */
+#define ION_SECURE (1 << ION_HEAP_ID_RESERVED)
+
+/**
+ * Flag for clients to force contiguous memort allocation
+ *
+ * Use of this flag is carefully monitored!
+ */
+#define ION_FORCE_CONTIGUOUS (1 << 30)
+
+/**
+ * Macro should be used with ion_heap_ids defined above.
+ */
+#define ION_HEAP(bit) (1 << (bit))
+#define ion_full_heap_mask (ION_HEAP(ION_CP_MM_HEAP_ID) | \
+			   ION_HEAP(ION_CP_MFC_HEAP_ID) | \
+			   ION_HEAP(ION_CP_WB_HEAP_ID) | \
+			   ION_HEAP(ION_CAMERA_HEAP_ID) | \
+			   ION_HEAP(ION_SF_HEAP_ID) | \
+			   ION_HEAP(ION_IOMMU_HEAP_ID) | \
+			   ION_HEAP(ION_QSECOM_HEAP_ID) | \
+			   ION_HEAP(ION_AUDIO_HEAP_ID) | \
+			   ION_HEAP(ION_MM_FIRMWARE_HEAP_ID) | \
+			   ION_HEAP(ION_SYSTEM_HEAP_ID) )
+
+
+#define ION_ADSP_HEAP_NAME	"adsp"
+#define ION_VMALLOC_HEAP_NAME	"vmalloc"
+#define ION_KMALLOC_HEAP_NAME	"kmalloc"
+#define ION_AUDIO_HEAP_NAME	"audio"
+#define ION_SF_HEAP_NAME	"sf"
+#define ION_MM_HEAP_NAME	"mm"
+#define ION_CAMERA_HEAP_NAME	"camera_preview"
+#define ION_IOMMU_HEAP_NAME	"iommu"
+#define ION_MFC_HEAP_NAME	"mfc"
+#define ION_WB_HEAP_NAME	"wb"
+#define ION_MM_FIRMWARE_HEAP_NAME	"mm_fw"
+#define ION_QSECOM_HEAP_NAME	"qsecom"
+#define ION_FMEM_HEAP_NAME	"fmem"
+
+#define ION_SET_CACHED(__cache)		(__cache | ION_FLAG_CACHED)
+#define ION_SET_UNCACHED(__cache)	(__cache & ~ION_FLAG_CACHED)
+
+#define ION_IS_CACHED(__flags)	((__flags) & ION_FLAG_CACHED)
+
+#ifdef __KERNEL__
+
+/*
+ * This flag allows clients when mapping into the IOMMU to specify to
+ * defer un-mapping from the IOMMU until the buffer memory is freed.
+ */
+#define ION_IOMMU_UNMAP_DELAYED 1
+
+/**
+ * struct ion_cp_heap_pdata - defines a content protection heap in the given
+ * platform
+ * @permission_type:	Memory ID used to identify the memory to TZ
+ * @align:		Alignment requirement for the memory
+ * @secure_base:	Base address for securing the heap.
+ *			Note: This might be different from actual base address
+ *			of this heap in the case of a shared heap.
+ * @secure_size:	Memory size for securing the heap.
+ *			Note: This might be different from actual size
+ *			of this heap in the case of a shared heap.
+ * @reusable		Flag indicating whether this heap is reusable of not.
+ *			(see FMEM)
+ * @mem_is_fmem		Flag indicating whether this memory is coming from fmem
+ *			or not.
+ * @fixed_position	If nonzero, position in the fixed area.
+ * @virt_addr:		Virtual address used when using fmem.
+ * @iommu_map_all:	Indicates whether we should map whole heap into IOMMU.
+ * @iommu_2x_map_domain: Indicates the domain to use for overmapping.
+ * @request_region:	function to be called when the number of allocations
+ *			goes from 0 -> 1
+ * @release_region:	function to be called when the number of allocations
+ *			goes from 1 -> 0
+ * @setup_region:	function to be called upon ion registration
+ * @memory_type:Memory type used for the heap
+ * @no_nonsecure_alloc: don't allow non-secure allocations from this heap
+ *
+ */
+struct ion_cp_heap_pdata {
+	enum ion_permission_type permission_type;
+	unsigned int align;
+	ion_phys_addr_t secure_base; /* Base addr used when heap is shared */
+	size_t secure_size; /* Size used for securing heap when heap is shared*/
+	int reusable;
+	int mem_is_fmem;
+	int is_cma;
+	enum ion_fixed_position fixed_position;
+	int iommu_map_all;
+	int iommu_2x_map_domain;
+	ion_virt_addr_t *virt_addr;
+	int (*request_region)(void *);
+	int (*release_region)(void *);
+	void *(*setup_region)(void);
+	enum ion_memory_types memory_type;
+	int no_nonsecure_alloc;
+};
+
+/**
+ * struct ion_co_heap_pdata - defines a carveout heap in the given platform
+ * @adjacent_mem_id:	Id of heap that this heap must be adjacent to.
+ * @align:		Alignment requirement for the memory
+ * @mem_is_fmem		Flag indicating whether this memory is coming from fmem
+ *			or not.
+ * @fixed_position	If nonzero, position in the fixed area.
+ * @request_region:	function to be called when the number of allocations
+ *			goes from 0 -> 1
+ * @release_region:	function to be called when the number of allocations
+ *			goes from 1 -> 0
+ * @setup_region:	function to be called upon ion registration
+ * @memory_type:Memory type used for the heap
+ *
+ */
+struct ion_co_heap_pdata {
+	int adjacent_mem_id;
+	unsigned int align;
+	int mem_is_fmem;
+	enum ion_fixed_position fixed_position;
+	int (*request_region)(void *);
+	int (*release_region)(void *);
+	void *(*setup_region)(void);
+	enum ion_memory_types memory_type;
+};
+
+#ifdef CONFIG_ION
+/**
+ * msm_ion_secure_heap - secure a heap. Wrapper around ion_secure_heap.
+ *
+  * @heap_id - heap id to secure.
+ *
+ * Secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_secure_heap(int heap_id);
+
+/**
+ * msm_ion_unsecure_heap - unsecure a heap. Wrapper around ion_unsecure_heap.
+ *
+  * @heap_id - heap id to secure.
+ *
+ * Un-secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_unsecure_heap(int heap_id);
+
+/**
+ * msm_ion_secure_heap_2_0 - secure a heap using 2.0 APIs
+ *  Wrapper around ion_secure_heap.
+ *
+ * @heap_id - heap id to secure.
+ * @usage - usage hint to TZ
+ *
+ * Secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_secure_heap_2_0(int heap_id, enum cp_mem_usage usage);
+
+/**
+ * msm_ion_unsecure_heap - unsecure a heap secured with 3.0 APIs.
+ * Wrapper around ion_unsecure_heap.
+ *
+ * @heap_id - heap id to secure.
+ * @usage - usage hint to TZ
+ *
+ * Un-secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_unsecure_heap_2_0(int heap_id, enum cp_mem_usage usage);
+#else
+static inline int msm_ion_secure_heap(int heap_id)
+{
+	return -ENODEV;
+
+}
+
+static inline int msm_ion_unsecure_heap(int heap_id)
+{
+	return -ENODEV;
+}
+
+static inline int msm_ion_secure_heap_2_0(int heap_id, enum cp_mem_usage usage)
+{
+	return -ENODEV;
+}
+
+static inline int msm_ion_unsecure_heap_2_0(int heap_id,
+					enum cp_mem_usage usage)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_ION */
+
+#endif /* __KERNEL */
+
+/* struct ion_flush_data - data passed to ion for flushing caches
+ *
+ * @handle:	handle with data to flush
+ * @fd:		fd to flush
+ * @vaddr:	userspace virtual address mapped with mmap
+ * @offset:	offset into the handle to flush
+ * @length:	length of handle to flush
+ *
+ * Performs cache operations on the handle. If p is the start address
+ * of the handle, p + offset through p + offset + length will have
+ * the cache operations performed
+ */
+/*
+struct ion_flush_data {
+	struct ion_handle *handle;
+	int fd;
+	void *vaddr;
+	unsigned int offset;
+	unsigned int length;
+};
+*/
+/* struct ion_flag_data - information about flags for this buffer
+ *
+ * @handle:	handle to get flags from
+ * @flags:	flags of this handle
+ *
+ * Takes handle as an input and outputs the flags from the handle
+ * in the flag field.
+ */
+/*
+struct ion_flag_data {
+	struct ion_handle *handle;
+	unsigned long flags;
+};
+*/
+#define ION_IOC_MSM_MAGIC 'M'
+
+/**
+ * DOC: ION_IOC_CLEAN_CACHES - clean the caches
+ *
+ * Clean the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 0, \
+						struct ion_flush_data)
+
+/**
+ * DOC: ION_IOC_INV_CACHES - invalidate the caches
+ *
+ * Invalidate the caches of the handle specified.
+ */
+#define ION_IOC_INV_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 1, \
+						struct ion_flush_data)
+/**
+ * DOC: ION_IOC_CLEAN_INV_CACHES - clean and invalidate the caches
+ *
+ * Clean and invalidate the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_INV_CACHES	_IOWR(ION_IOC_MSM_MAGIC, 2, \
+						struct ion_flush_data)
+
+/**
+ * DOC: ION_IOC_GET_FLAGS - get the flags of the handle
+ *
+ * Gets the flags of the current handle which indicate cachability,
+ * secure state etc.
+ */
+#define ION_IOC_GET_FLAGS		_IOWR(ION_IOC_MSM_MAGIC, 3, \
+						struct ion_flag_data)
 #endif
diff --git a/include/linux/msm_vidc_dec.h b/include/linux/msm_vidc_dec.h
index 5bc6e6e..57dbaef 100644
--- a/include/linux/msm_vidc_dec.h
+++ b/include/linux/msm_vidc_dec.h
@@ -4,27 +4,43 @@
 #include <linux/types.h>
 #include <linux/ioctl.h>
 
+/* STATUS CODES */
+/* Base value for status codes */
 #define VDEC_S_BASE	0x40000000
+/* Success */
 #define VDEC_S_SUCCESS	(VDEC_S_BASE)
+/* General failure */
 #define VDEC_S_EFAIL	(VDEC_S_BASE + 1)
+/* Fatal irrecoverable  failure. Need to  tear down session. */
 #define VDEC_S_EFATAL   (VDEC_S_BASE + 2)
+/* Error detected in the passed  parameters */
 #define VDEC_S_EBADPARAM	(VDEC_S_BASE + 3)
+/* Command called in invalid  state. */
 #define VDEC_S_EINVALSTATE	(VDEC_S_BASE + 4)
- 
+ /* Insufficient OS  resources - thread, memory etc. */
 #define VDEC_S_ENOSWRES	(VDEC_S_BASE + 5)
- 
+ /* Insufficient HW resources -  core capacity  maxed  out. */
 #define VDEC_S_ENOHWRES	(VDEC_S_BASE + 6)
+/* Invalid command  called */
 #define VDEC_S_EINVALCMD	(VDEC_S_BASE + 7)
+/* Command timeout. */
 #define VDEC_S_ETIMEOUT	(VDEC_S_BASE + 8)
+/* Pre-requirement is  not met for API. */
 #define VDEC_S_ENOPREREQ	(VDEC_S_BASE + 9)
+/* Command queue is full. */
 #define VDEC_S_ECMDQFULL	(VDEC_S_BASE + 10)
+/* Command is not supported  by this driver */
 #define VDEC_S_ENOTSUPP	(VDEC_S_BASE + 11)
+/* Command is not implemented by thedriver. */
 #define VDEC_S_ENOTIMPL	(VDEC_S_BASE + 12)
+/* Command is not implemented by the driver.  */
 #define VDEC_S_BUSY	(VDEC_S_BASE + 13)
 #define VDEC_S_INPUT_BITSTREAM_ERR (VDEC_S_BASE + 14)
 
 #define VDEC_INTF_VER	1
 #define VDEC_MSG_BASE	0x0000000
+/* Codes to identify asynchronous message responses and events that driver
+  wants to communicate to the app.*/
 #define VDEC_MSG_INVALID	(VDEC_MSG_BASE + 0)
 #define VDEC_MSG_RESP_INPUT_BUFFER_DONE	(VDEC_MSG_BASE + 1)
 #define VDEC_MSG_RESP_OUTPUT_BUFFER_DONE	(VDEC_MSG_BASE + 2)
@@ -43,6 +59,7 @@
 #define VDEC_MSG_EVT_INFO_CONFIG_CHANGED	(VDEC_MSG_BASE + 15)
 #define VDEC_MSG_EVT_INFO_FIELD_DROPPED	(VDEC_MSG_BASE + 16)
 
+/*Buffer flags bits masks.*/
 #define VDEC_BUFFERFLAG_EOS	0x00000001
 #define VDEC_BUFFERFLAG_DECODEONLY	0x00000004
 #define VDEC_BUFFERFLAG_DATACORRUPT	0x00000008
@@ -51,6 +68,7 @@
 #define VDEC_BUFFERFLAG_EXTRADATA	0x00000040
 #define VDEC_BUFFERFLAG_CODECCONFIG	0x00000080
 
+/*Post processing flags bit masks*/
 #define VDEC_EXTRADATA_NONE 0x001
 #define VDEC_EXTRADATA_QP 0x004
 #define VDEC_EXTRADATA_MB_ERROR_MAP 0x008
@@ -60,6 +78,7 @@
 
 #define VDEC_EXTRADATA_EXT_DATA          0x0800
 #define VDEC_EXTRADATA_USER_DATA         0x1000
+#define VDEC_EXTRADATA_EXT_BUFFER        0x2000
 
 #define VDEC_CMDBASE	0x800
 #define VDEC_CMD_SET_INTF_VERSION	(VDEC_CMDBASE)
@@ -71,25 +90,37 @@ struct vdec_ioctl_msg {
 	void __user *out;
 };
 
+/* CMD params: InputParam:enum vdec_codec
+   OutputParam: struct vdec_profile_level*/
 #define VDEC_IOCTL_GET_PROFILE_LEVEL_SUPPORTED \
 	_IOWR(VDEC_IOCTL_MAGIC, 0, struct vdec_ioctl_msg)
 
+/*CMD params:InputParam: NULL
+  OutputParam: uint32_t(bitmask)*/
 #define VDEC_IOCTL_GET_INTERLACE_FORMAT \
 	_IOR(VDEC_IOCTL_MAGIC, 1, struct vdec_ioctl_msg)
 
+/* CMD params: InputParam:  enum vdec_codec
+   OutputParam: struct vdec_profile_level*/
 #define VDEC_IOCTL_GET_CURRENT_PROFILE_LEVEL \
 	_IOWR(VDEC_IOCTL_MAGIC, 2, struct vdec_ioctl_msg)
 
+/*CMD params: SET: InputParam: enum vdec_output_fromat  OutputParam: NULL
+  GET:  InputParam: NULL OutputParam: enum vdec_output_fromat*/
 #define VDEC_IOCTL_SET_OUTPUT_FORMAT \
 	_IOWR(VDEC_IOCTL_MAGIC, 3, struct vdec_ioctl_msg)
 #define VDEC_IOCTL_GET_OUTPUT_FORMAT \
 	_IOWR(VDEC_IOCTL_MAGIC, 4, struct vdec_ioctl_msg)
 
+/*CMD params: SET: InputParam: enum vdec_codec OutputParam: NULL
+  GET: InputParam: NULL OutputParam: enum vdec_codec*/
 #define VDEC_IOCTL_SET_CODEC \
 	_IOW(VDEC_IOCTL_MAGIC, 5, struct vdec_ioctl_msg)
 #define VDEC_IOCTL_GET_CODEC \
 	_IOR(VDEC_IOCTL_MAGIC, 6, struct vdec_ioctl_msg)
 
+/*CMD params: SET: InputParam: struct vdec_picsize outputparam: NULL
+ GET: InputParam: NULL outputparam: struct vdec_picsize*/
 #define VDEC_IOCTL_SET_PICRES \
 	_IOW(VDEC_IOCTL_MAGIC, 7, struct vdec_ioctl_msg)
 #define VDEC_IOCTL_GET_PICRES \
@@ -103,21 +134,28 @@ struct vdec_ioctl_msg {
 #define VDEC_IOCTL_SET_SEQUENCE_HEADER \
 	_IOW(VDEC_IOCTL_MAGIC, 11, struct vdec_ioctl_msg)
 
+/* CMD params: SET: InputParam - vdec_allocatorproperty, OutputParam - NULL
+   GET: InputParam - NULL, OutputParam - vdec_allocatorproperty*/
 #define VDEC_IOCTL_SET_BUFFER_REQ \
 	_IOW(VDEC_IOCTL_MAGIC, 12, struct vdec_ioctl_msg)
 #define VDEC_IOCTL_GET_BUFFER_REQ \
 	_IOR(VDEC_IOCTL_MAGIC, 13, struct vdec_ioctl_msg)
+/* CMD params: InputParam - vdec_buffer, OutputParam - uint8_t** */
 #define VDEC_IOCTL_ALLOCATE_BUFFER \
 	_IOWR(VDEC_IOCTL_MAGIC, 14, struct vdec_ioctl_msg)
+/* CMD params: InputParam - uint8_t *, OutputParam - NULL.*/
 #define VDEC_IOCTL_FREE_BUFFER \
 	_IOW(VDEC_IOCTL_MAGIC, 15, struct vdec_ioctl_msg)
 
+/*CMD params: CMD: InputParam - struct vdec_setbuffer_cmd, OutputParam - NULL*/
 #define VDEC_IOCTL_SET_BUFFER \
 	_IOW(VDEC_IOCTL_MAGIC, 16, struct vdec_ioctl_msg)
 
+/* CMD params: InputParam - struct vdec_fillbuffer_cmd, OutputParam - NULL*/
 #define VDEC_IOCTL_FILL_OUTPUT_BUFFER \
 	_IOW(VDEC_IOCTL_MAGIC, 17, struct vdec_ioctl_msg)
 
+/*CMD params: InputParam - struct vdec_frameinfo , OutputParam - NULL*/
 #define VDEC_IOCTL_DECODE_FRAME \
 	_IOW(VDEC_IOCTL_MAGIC, 18, struct vdec_ioctl_msg)
 
@@ -127,9 +165,14 @@ struct vdec_ioctl_msg {
 #define VDEC_IOCTL_CMD_PAUSE _IO(VDEC_IOCTL_MAGIC, 22)
 #define VDEC_IOCTL_CMD_RESUME _IO(VDEC_IOCTL_MAGIC, 23)
 
+/*CMD params: InputParam - enum vdec_bufferflush , OutputParam - NULL */
 #define VDEC_IOCTL_CMD_FLUSH _IOW(VDEC_IOCTL_MAGIC, 24, struct vdec_ioctl_msg)
 
+/* ========================================================
+ * IOCTL for getting asynchronous notification from driver
+ * ========================================================*/
 
+/*IOCTL params: InputParam - NULL, OutputParam - struct vdec_msginfo*/
 #define VDEC_IOCTL_GET_NEXT_MSG \
 	_IOR(VDEC_IOCTL_MAGIC, 25, struct vdec_ioctl_msg)
 
@@ -171,6 +214,19 @@ struct vdec_ioctl_msg {
 #define VDEC_IOCTL_SET_PERF_CLK \
 	_IOR(VDEC_IOCTL_MAGIC, 38, struct vdec_ioctl_msg)
 
+#define VDEC_IOCTL_SET_META_BUFFERS \
+	_IOW(VDEC_IOCTL_MAGIC, 39, struct vdec_ioctl_msg)
+
+#define VDEC_IOCTL_FREE_META_BUFFERS \
+	_IO(VDEC_IOCTL_MAGIC, 40)
+
+#define VDEC_IOCTL_GET_ENABLE_SEC_METADATA \
+	_IOR(VDEC_IOCTL_MAGIC, 41, struct vdec_ioctl_msg)
+
+/*IOCTL params:GET: InputData - NULL, OutputData - unsigned int.*/
+#define VDEC_IOCTL_GET_PERF_LEVEL \
+	_IOR(VDEC_IOCTL_MAGIC, 42, struct vdec_ioctl_msg)
+
 enum vdec_picture {
 	PICTURE_TYPE_I,
 	PICTURE_TYPE_P,
@@ -194,6 +250,7 @@ struct vdec_allocatorproperty {
 	size_t buffer_size;
 	uint32_t alignment;
 	uint32_t buf_poolid;
+	size_t meta_buffer_size;
 };
 
 struct vdec_bufferpayload {
@@ -484,6 +541,11 @@ struct vdec_aspectratioinfo {
 	uint32_t par_height;
 };
 
+struct vdec_sep_metadatainfo {
+	void __user *metabufaddr;
+	uint32_t size;
+};
+
 struct vdec_output_frameinfo {
 	void __user *bufferaddr;
 	size_t offset;
@@ -496,6 +558,9 @@ struct vdec_output_frameinfo {
 	struct vdec_framesize framesize;
 	enum vdec_interlaced_format interlaced_format;
 	struct vdec_aspectratioinfo aspect_ratio_info;
+	struct vdec_sep_metadatainfo metadata_info;
+	size_t metadata_len;
+	size_t metadata_offset;
 };
 
 union vdec_msgdata {
@@ -529,4 +594,12 @@ struct vdec_mv_buff_size{
 	int alignment;
 };
 
-#endif 
+struct vdec_meta_buffers {
+	size_t size;
+	int count;
+	int pmem_fd;
+	int pmem_fd_iommu;
+	int offset;
+};
+
+#endif /* end of macro _VDECDECODER_H_ */
diff --git a/include/linux/msm_vidc_enc.h b/include/linux/msm_vidc_enc.h
index 126209c..e4f973f 100644
--- a/include/linux/msm_vidc_enc.h
+++ b/include/linux/msm_vidc_enc.h
@@ -4,30 +4,35 @@
 #include <linux/types.h>
 #include <linux/ioctl.h>
 
+/** STATUS CODES*/
+/* Base value for status codes */
 #define VEN_S_BASE	0x00000000
-#define VEN_S_SUCCESS	(VEN_S_BASE)
-#define VEN_S_EFAIL	(VEN_S_BASE+1)
-#define VEN_S_EFATAL	(VEN_S_BASE+2)
-#define VEN_S_EBADPARAM	(VEN_S_BASE+3)
+#define VEN_S_SUCCESS	(VEN_S_BASE)/* Success */
+#define VEN_S_EFAIL	(VEN_S_BASE+1)/* General failure */
+#define VEN_S_EFATAL	(VEN_S_BASE+2)/* Fatal irrecoverable failure*/
+#define VEN_S_EBADPARAM	(VEN_S_BASE+3)/* Error passed parameters*/
+/*Command called in invalid state*/
 #define VEN_S_EINVALSTATE	(VEN_S_BASE+4)
-#define VEN_S_ENOSWRES	(VEN_S_BASE+5)
-#define VEN_S_ENOHWRES	(VEN_S_BASE+6)
-#define VEN_S_EBUFFREQ	(VEN_S_BASE+7)
-#define VEN_S_EINVALCMD	(VEN_S_BASE+8)
-#define VEN_S_ETIMEOUT	(VEN_S_BASE+9)
+#define VEN_S_ENOSWRES	(VEN_S_BASE+5)/* Insufficient OS resources*/
+#define VEN_S_ENOHWRES	(VEN_S_BASE+6)/*Insufficient HW resources */
+#define VEN_S_EBUFFREQ	(VEN_S_BASE+7)/* Buffer requirements were not met*/
+#define VEN_S_EINVALCMD	(VEN_S_BASE+8)/* Invalid command called */
+#define VEN_S_ETIMEOUT	(VEN_S_BASE+9)/* Command timeout. */
+/*Re-attempt was made when multiple invocation not supported for API.*/
 #define VEN_S_ENOREATMPT	(VEN_S_BASE+10)
-#define VEN_S_ENOPREREQ	(VEN_S_BASE+11)
-#define VEN_S_ECMDQFULL	(VEN_S_BASE+12)
-#define VEN_S_ENOTSUPP	(VEN_S_BASE+13)
-#define VEN_S_ENOTIMPL	(VEN_S_BASE+14)
-#define VEN_S_ENOTPMEM	(VEN_S_BASE+15)
-#define VEN_S_EFLUSHED	(VEN_S_BASE+16)
-#define VEN_S_EINSUFBUF	(VEN_S_BASE+17)
+#define VEN_S_ENOPREREQ	(VEN_S_BASE+11)/*Pre-requirement is not met for API*/
+#define VEN_S_ECMDQFULL	(VEN_S_BASE+12)/*Command queue is full*/
+#define VEN_S_ENOTSUPP	(VEN_S_BASE+13)/*Command not supported*/
+#define VEN_S_ENOTIMPL	(VEN_S_BASE+14)/*Command not implemented.*/
+#define VEN_S_ENOTPMEM	(VEN_S_BASE+15)/*Buffer is not from PMEM*/
+#define VEN_S_EFLUSHED	(VEN_S_BASE+16)/*returned buffer was flushed*/
+#define VEN_S_EINSUFBUF	(VEN_S_BASE+17)/*provided buffer size insufficient*/
 #define VEN_S_ESAMESTATE	(VEN_S_BASE+18)
 #define VEN_S_EINVALTRANS	(VEN_S_BASE+19)
 
 #define VEN_INTF_VER			 1
 
+/*Asynchronous messages from driver*/
 #define VEN_MSG_INDICATION	0
 #define VEN_MSG_INPUT_BUFFER_DONE	1
 #define VEN_MSG_OUTPUT_BUFFER_DONE	2
@@ -39,105 +44,129 @@
 #define VEN_MSG_PAUSE	8
 #define VEN_MSG_RESUME	9
 #define VEN_MSG_STOP_READING_MSG	10
+#define VEN_MSG_LTRUSE_FAILED 11
 
+/*Buffer flags bits masks*/
 #define VEN_BUFFLAG_EOS	0x00000001
 #define VEN_BUFFLAG_ENDOFFRAME	0x00000010
 #define VEN_BUFFLAG_SYNCFRAME	0x00000020
 #define VEN_BUFFLAG_EXTRADATA	0x00000040
 #define VEN_BUFFLAG_CODECCONFIG	0x00000080
 
+/*Post processing flags bit masks*/
 #define VEN_EXTRADATA_NONE          0x001
 #define VEN_EXTRADATA_QCOMFILLER    0x002
 #define VEN_EXTRADATA_SLICEINFO     0x100
-
-
-#define VEN_FRAME_TYPE_I	1
-#define VEN_FRAME_TYPE_P	2
-#define VEN_FRAME_TYPE_B	3
-
-#define VEN_CODEC_MPEG4	1
-#define VEN_CODEC_H264	2
-#define VEN_CODEC_H263	3
-
-#define VEN_PROFILE_MPEG4_SP      1
-#define VEN_PROFILE_MPEG4_ASP     2
-#define VEN_PROFILE_H264_BASELINE 3
-#define VEN_PROFILE_H264_MAIN     4
-#define VEN_PROFILE_H264_HIGH     5
-#define VEN_PROFILE_H263_BASELINE 6
-
-#define VEN_LEVEL_MPEG4_0	 0x1
-#define VEN_LEVEL_MPEG4_1	 0x2
-#define VEN_LEVEL_MPEG4_2	 0x3
-#define VEN_LEVEL_MPEG4_3	 0x4
-#define VEN_LEVEL_MPEG4_4	 0x5
-#define VEN_LEVEL_MPEG4_5	 0x6
-#define VEN_LEVEL_MPEG4_3b	 0x7
-#define VEN_LEVEL_MPEG4_6	 0x8
-
-#define VEN_LEVEL_H264_1	 0x9
-#define VEN_LEVEL_H264_1b        0xA
-#define VEN_LEVEL_H264_1p1	 0xB
-#define VEN_LEVEL_H264_1p2	 0xC
-#define VEN_LEVEL_H264_1p3	 0xD
-#define VEN_LEVEL_H264_2	 0xE
-#define VEN_LEVEL_H264_2p1	 0xF
-#define VEN_LEVEL_H264_2p2	0x10
-#define VEN_LEVEL_H264_3	0x11
-#define VEN_LEVEL_H264_3p1	0x12
-#define VEN_LEVEL_H264_3p2	0x13
-#define VEN_LEVEL_H264_4	0x14
-
-#define VEN_LEVEL_H263_10	0x15
-#define VEN_LEVEL_H263_20	0x16
-#define VEN_LEVEL_H263_30	0x17
-#define VEN_LEVEL_H263_40	0x18
-#define VEN_LEVEL_H263_45	0x19
-#define VEN_LEVEL_H263_50	0x1A
-#define VEN_LEVEL_H263_60	0x1B
-#define VEN_LEVEL_H263_70	0x1C
-
+#define VEN_EXTRADATA_LTRINFO       0x200
+
+/*ENCODER CONFIGURATION CONSTANTS*/
+
+/*Encoded video frame types*/
+#define VEN_FRAME_TYPE_I	1/* I frame type */
+#define VEN_FRAME_TYPE_P	2/* P frame type */
+#define VEN_FRAME_TYPE_B	3/* B frame type */
+
+/*Video codec types*/
+#define VEN_CODEC_MPEG4	1/* MPEG4 Codec */
+#define VEN_CODEC_H264	2/* H.264 Codec */
+#define VEN_CODEC_H263	3/* H.263 Codec */
+
+/*Video codec profile types.*/
+#define VEN_PROFILE_MPEG4_SP      1/* 1 - MPEG4 SP profile      */
+#define VEN_PROFILE_MPEG4_ASP     2/* 2 - MPEG4 ASP profile     */
+#define VEN_PROFILE_H264_BASELINE 3/* 3 - H264 Baseline profile	*/
+#define VEN_PROFILE_H264_MAIN     4/* 4 - H264 Main profile     */
+#define VEN_PROFILE_H264_HIGH     5/* 5 - H264 High profile     */
+#define VEN_PROFILE_H263_BASELINE 6/* 6 - H263 Baseline profile */
+
+/*Video codec profile level types.*/
+#define VEN_LEVEL_MPEG4_0	 0x1/* MPEG4 Level 0  */
+#define VEN_LEVEL_MPEG4_1	 0x2/* MPEG4 Level 1  */
+#define VEN_LEVEL_MPEG4_2	 0x3/* MPEG4 Level 2  */
+#define VEN_LEVEL_MPEG4_3	 0x4/* MPEG4 Level 3  */
+#define VEN_LEVEL_MPEG4_4	 0x5/* MPEG4 Level 4  */
+#define VEN_LEVEL_MPEG4_5	 0x6/* MPEG4 Level 5  */
+#define VEN_LEVEL_MPEG4_3b	 0x7/* MPEG4 Level 3b */
+#define VEN_LEVEL_MPEG4_6	 0x8/* MPEG4 Level 6  */
+
+#define VEN_LEVEL_H264_1	 0x9/* H.264 Level 1   */
+#define VEN_LEVEL_H264_1b        0xA/* H.264 Level 1b  */
+#define VEN_LEVEL_H264_1p1	 0xB/* H.264 Level 1.1 */
+#define VEN_LEVEL_H264_1p2	 0xC/* H.264 Level 1.2 */
+#define VEN_LEVEL_H264_1p3	 0xD/* H.264 Level 1.3 */
+#define VEN_LEVEL_H264_2	 0xE/* H.264 Level 2   */
+#define VEN_LEVEL_H264_2p1	 0xF/* H.264 Level 2.1 */
+#define VEN_LEVEL_H264_2p2	0x10/* H.264 Level 2.2 */
+#define VEN_LEVEL_H264_3	0x11/* H.264 Level 3   */
+#define VEN_LEVEL_H264_3p1	0x12/* H.264 Level 3.1 */
+#define VEN_LEVEL_H264_3p2	0x13/* H.264 Level 3.2 */
+#define VEN_LEVEL_H264_4	0x14/* H.264 Level 4   */
+
+#define VEN_LEVEL_H263_10	0x15/* H.263 Level 10  */
+#define VEN_LEVEL_H263_20	0x16/* H.263 Level 20  */
+#define VEN_LEVEL_H263_30	0x17/* H.263 Level 30  */
+#define VEN_LEVEL_H263_40	0x18/* H.263 Level 40  */
+#define VEN_LEVEL_H263_45	0x19/* H.263 Level 45  */
+#define VEN_LEVEL_H263_50	0x1A/* H.263 Level 50  */
+#define VEN_LEVEL_H263_60	0x1B/* H.263 Level 60  */
+#define VEN_LEVEL_H263_70	0x1C/* H.263 Level 70  */
+
+/*Entropy coding model selection for H.264 encoder.*/
 #define VEN_ENTROPY_MODEL_CAVLC	1
 #define VEN_ENTROPY_MODEL_CABAC	2
-#define VEN_CABAC_MODEL_0	1
-#define VEN_CABAC_MODEL_1	2
-#define VEN_CABAC_MODEL_2	3
+/*Cabac model number (0,1,2) for encoder.*/
+#define VEN_CABAC_MODEL_0	1/* CABAC Model 0. */
+#define VEN_CABAC_MODEL_1	2/* CABAC Model 1. */
+#define VEN_CABAC_MODEL_2	3/* CABAC Model 2. */
 
-#define VEN_DB_DISABLE	1
-#define VEN_DB_ALL_BLKG_BNDRY	2
-#define VEN_DB_SKIP_SLICE_BNDRY	3
+/*Deblocking filter control type for encoder.*/
+#define VEN_DB_DISABLE	1/* 1 - Disable deblocking filter*/
+#define VEN_DB_ALL_BLKG_BNDRY	2/* 2 - All blocking boundary filtering*/
+#define VEN_DB_SKIP_SLICE_BNDRY	3/* 3 - Filtering except sliceboundary*/
 
+/*Different methods of Multi slice selection.*/
 #define VEN_MSLICE_OFF	1
-#define VEN_MSLICE_CNT_MB	2 
-#define VEN_MSLICE_CNT_BYTE	3 
-#define VEN_MSLICE_GOB	4 
+#define VEN_MSLICE_CNT_MB	2 /*number of MBscount per slice*/
+#define VEN_MSLICE_CNT_BYTE	3 /*number of bytes count per slice.*/
+#define VEN_MSLICE_GOB	4 /*Multi slice by GOB for H.263 only.*/
 
+/*Different modes for Rate Control.*/
 #define VEN_RC_OFF	1
 #define VEN_RC_VBR_VFR	2
 #define VEN_RC_VBR_CFR	3
 #define VEN_RC_CBR_VFR	4
 #define VEN_RC_CBR_CFR	5
 
+/*Different modes for flushing buffers*/
 #define VEN_FLUSH_INPUT	1
 #define VEN_FLUSH_OUTPUT	2
 #define VEN_FLUSH_ALL	3
 
-#define VEN_INPUTFMT_NV12	1
-#define VEN_INPUTFMT_NV21	2
-#define VEN_INPUTFMT_NV12_16M2KA	3
+/*Different input formats for YUV data.*/
+#define VEN_INPUTFMT_NV12	1/* NV12 Linear */
+#define VEN_INPUTFMT_NV21	2/* NV21 Linear */
+#define VEN_INPUTFMT_NV12_16M2KA	3/* NV12 Linear */
+#define VEN_INPUTFMT_NV21_16M2KA	4
+
 
-#define VEN_ROTATION_0	1
-#define VEN_ROTATION_90	2
-#define VEN_ROTATION_180	3
-#define VEN_ROTATION_270	4
+/*Different allowed rotation modes.*/
+#define VEN_ROTATION_0	1/* 0 degrees */
+#define VEN_ROTATION_90	2/* 90 degrees */
+#define VEN_ROTATION_180	3/* 180 degrees */
+#define VEN_ROTATION_270	4/* 270 degrees */
 
+/*IOCTL timeout values*/
 #define VEN_TIMEOUT_INFINITE	0xffffffff
 
+/*Different allowed intra refresh modes.*/
 #define VEN_IR_OFF	1
 #define VEN_IR_CYCLIC	2
 #define VEN_IR_RANDOM	3
 
+/*IOCTL BASE CODES Not to be used directly by the client.*/
+/* Base value for ioctls that are not related to encoder configuration.*/
 #define VEN_IOCTLBASE_NENC	0x800
+/* Base value for encoder configuration ioctls*/
 #define VEN_IOCTLBASE_ENC	0x850
 
 struct venc_ioctl_msg{
@@ -145,63 +174,87 @@ struct venc_ioctl_msg{
 	void __user *out;
 };
 
+/*NON ENCODER CONFIGURATION IOCTLs*/
 
+/*IOCTL params:SET: InputData - unsigned long, OutputData - NULL*/
 #define VEN_IOCTL_SET_INTF_VERSION \
 	_IOW(VEN_IOCTLBASE_NENC, 0, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_timeout, OutputData - venc_msg*/
 #define VEN_IOCTL_CMD_READ_NEXT_MSG \
 	_IOWR(VEN_IOCTLBASE_NENC, 1, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - NULL, OutputData - NULL*/
 #define VEN_IOCTL_CMD_STOP_READ_MSG	_IO(VEN_IOCTLBASE_NENC, 2)
 
+/*IOCTL params:SET: InputData - venc_allocatorproperty, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_allocatorproperty*/
 #define VEN_IOCTL_SET_INPUT_BUFFER_REQ \
 	_IOW(VEN_IOCTLBASE_NENC, 3, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_INPUT_BUFFER_REQ \
 	_IOR(VEN_IOCTLBASE_NENC, 4, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_bufferpayload, OutputData - NULL*/
 #define VEN_IOCTL_CMD_ALLOC_INPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 5, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_bufferpayload, OutputData - NULL*/
 #define VEN_IOCTL_SET_INPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 6, struct venc_ioctl_msg)
 
+/*IOCTL params: CMD: InputData - venc_bufferpayload, OutputData - NULL*/
 #define VEN_IOCTL_CMD_FREE_INPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 7, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_allocatorproperty, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_allocatorproperty*/
 #define VEN_IOCTL_SET_OUTPUT_BUFFER_REQ \
 	_IOW(VEN_IOCTLBASE_NENC, 8, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_OUTPUT_BUFFER_REQ \
 	_IOR(VEN_IOCTLBASE_NENC, 9, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_bufferpayload, OutputData - NULL*/
 #define VEN_IOCTL_CMD_ALLOC_OUTPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 10, struct venc_ioctl_msg)
 
 
+/*IOCTL params:CMD: InputData - venc_bufferpayload, OutputData - NULL*/
 #define VEN_IOCTL_SET_OUTPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 11, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_bufferpayload, OutputData - NULL.*/
 #define VEN_IOCTL_CMD_FREE_OUTPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 12, struct venc_ioctl_msg)
 
 
+/* Asynchronous respone message code:* VEN_MSG_START*/
 #define VEN_IOCTL_CMD_START	_IO(VEN_IOCTLBASE_NENC, 13)
 
 
+/*IOCTL params:CMD: InputData - venc_buffer, OutputData - NULL
+ Asynchronous respone message code:VEN_MSG_INPUT_BUFFER_DONE*/
 #define VEN_IOCTL_CMD_ENCODE_FRAME \
 	_IOW(VEN_IOCTLBASE_NENC, 14, struct venc_ioctl_msg)
 
 
+/*IOCTL params:CMD: InputData - venc_buffer, OutputData - NULL
+ Asynchronous response message code:VEN_MSG_OUTPUT_BUFFER_DONE*/
 #define VEN_IOCTL_CMD_FILL_OUTPUT_BUFFER \
 	_IOW(VEN_IOCTLBASE_NENC, 15, struct venc_ioctl_msg)
 
+/*IOCTL params:CMD: InputData - venc_bufferflush, OutputData - NULL
+ * Asynchronous response message code:VEN_MSG_INPUT_BUFFER_DONE*/
 #define VEN_IOCTL_CMD_FLUSH \
 	_IOW(VEN_IOCTLBASE_NENC, 16, struct venc_ioctl_msg)
 
 
+/*Asynchronous respone message code:VEN_MSG_PAUSE*/
 #define VEN_IOCTL_CMD_PAUSE	_IO(VEN_IOCTLBASE_NENC, 17)
 
+/*Asynchronous respone message code:VEN_MSG_RESUME*/
 #define VEN_IOCTL_CMD_RESUME _IO(VEN_IOCTLBASE_NENC, 18)
 
+/* Asynchronous respone message code:VEN_MSG_STOP*/
 #define VEN_IOCTL_CMD_STOP _IO(VEN_IOCTLBASE_NENC, 19)
 
 #define VEN_IOCTL_SET_RECON_BUFFER \
@@ -215,131 +268,177 @@ struct venc_ioctl_msg{
 
 
 
+/*ENCODER PROPERTY CONFIGURATION & CAPABILITY IOCTLs*/
 
+/*IOCTL params:SET: InputData - venc_basecfg, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_basecfg*/
 #define VEN_IOCTL_SET_BASE_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 1, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_BASE_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 2, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_switch, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_switch*/
 #define VEN_IOCTL_SET_LIVE_MODE \
 	_IOW(VEN_IOCTLBASE_ENC, 3, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_LIVE_MODE \
 	_IOR(VEN_IOCTLBASE_ENC, 4, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_profile, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_profile*/
 #define VEN_IOCTL_SET_CODEC_PROFILE \
 	_IOW(VEN_IOCTLBASE_ENC, 5, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_CODEC_PROFILE \
 	_IOR(VEN_IOCTLBASE_ENC, 6, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - ven_profilelevel, OutputData - NULL
+  GET: InputData - NULL, OutputData - ven_profilelevel*/
 #define VEN_IOCTL_SET_PROFILE_LEVEL \
 	_IOW(VEN_IOCTLBASE_ENC, 7, struct venc_ioctl_msg)
 
 #define VEN_IOCTL_GET_PROFILE_LEVEL \
 	_IOR(VEN_IOCTLBASE_ENC, 8, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_switch, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_switch*/
 #define VEN_IOCTL_SET_SHORT_HDR \
 	_IOW(VEN_IOCTLBASE_ENC, 9, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_SHORT_HDR \
 	_IOR(VEN_IOCTLBASE_ENC, 10, struct venc_ioctl_msg)
 
 
+/*IOCTL params: SET: InputData - venc_sessionqp, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_sessionqp*/
 #define VEN_IOCTL_SET_SESSION_QP \
 	_IOW(VEN_IOCTLBASE_ENC, 11, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_SESSION_QP \
 	_IOR(VEN_IOCTLBASE_ENC, 12, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_intraperiod, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_intraperiod*/
 #define VEN_IOCTL_SET_INTRA_PERIOD \
 	_IOW(VEN_IOCTLBASE_ENC, 13, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_INTRA_PERIOD \
 	_IOR(VEN_IOCTLBASE_ENC, 14, struct venc_ioctl_msg)
 
 
+/* Request an Iframe*/
 #define VEN_IOCTL_CMD_REQUEST_IFRAME _IO(VEN_IOCTLBASE_ENC, 15)
 
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_capability*/
 #define VEN_IOCTL_GET_CAPABILITY \
 	_IOR(VEN_IOCTLBASE_ENC, 16, struct venc_ioctl_msg)
 
 
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_seqheader*/
 #define VEN_IOCTL_GET_SEQUENCE_HDR \
 	_IOR(VEN_IOCTLBASE_ENC, 17, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_entropycfg, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_entropycfg*/
 #define VEN_IOCTL_SET_ENTROPY_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 18, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_ENTROPY_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 19, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_dbcfg, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_dbcfg*/
 #define VEN_IOCTL_SET_DEBLOCKING_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 20, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_DEBLOCKING_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 21, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_intrarefresh, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_intrarefresh*/
 #define VEN_IOCTL_SET_INTRA_REFRESH \
 	_IOW(VEN_IOCTLBASE_ENC, 22, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_INTRA_REFRESH \
 	_IOR(VEN_IOCTLBASE_ENC, 23, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_multiclicecfg, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_multiclicecfg*/
 #define VEN_IOCTL_SET_MULTI_SLICE_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 24, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_MULTI_SLICE_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 25, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_ratectrlcfg, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_ratectrlcfg*/
 #define VEN_IOCTL_SET_RATE_CTRL_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 26, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_RATE_CTRL_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 27, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_voptimingcfg, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_voptimingcfg*/
 #define VEN_IOCTL_SET_VOP_TIMING_CFG \
 	_IOW(VEN_IOCTLBASE_ENC, 28, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_VOP_TIMING_CFG \
 	_IOR(VEN_IOCTLBASE_ENC, 29, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_framerate, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_framerate*/
 #define VEN_IOCTL_SET_FRAME_RATE \
 	_IOW(VEN_IOCTLBASE_ENC, 30, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_FRAME_RATE \
 	_IOR(VEN_IOCTLBASE_ENC, 31, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_targetbitrate, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_targetbitrate*/
 #define VEN_IOCTL_SET_TARGET_BITRATE \
 	_IOW(VEN_IOCTLBASE_ENC, 32, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_TARGET_BITRATE \
 	_IOR(VEN_IOCTLBASE_ENC, 33, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_rotation, OutputData - NULL
+  GET: InputData - NULL, OutputData - venc_rotation*/
 #define VEN_IOCTL_SET_ROTATION \
 	_IOW(VEN_IOCTLBASE_ENC, 34, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_ROTATION \
 	_IOR(VEN_IOCTLBASE_ENC, 35, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_headerextension, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_headerextension*/
 #define VEN_IOCTL_SET_HEC \
 	_IOW(VEN_IOCTLBASE_ENC, 36, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_HEC \
 	_IOR(VEN_IOCTLBASE_ENC, 37, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_switch, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_switch*/
 #define VEN_IOCTL_SET_DATA_PARTITION \
 	_IOW(VEN_IOCTLBASE_ENC, 38, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_DATA_PARTITION \
 	_IOR(VEN_IOCTLBASE_ENC, 39, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - venc_switch, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_switch*/
 #define VEN_IOCTL_SET_RVLC \
 	_IOW(VEN_IOCTLBASE_ENC, 40, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_RVLC \
 	_IOR(VEN_IOCTLBASE_ENC, 41, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_switch, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_switch*/
 #define VEN_IOCTL_SET_AC_PREDICTION \
 	_IOW(VEN_IOCTLBASE_ENC, 42, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_AC_PREDICTION \
 	_IOR(VEN_IOCTLBASE_ENC, 43, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - venc_qprange, OutputData - NULL
+ GET: InputData - NULL, OutputData - venc_qprange*/
 #define VEN_IOCTL_SET_QP_RANGE \
 	_IOW(VEN_IOCTLBASE_ENC, 44, struct venc_ioctl_msg)
 #define VEN_IOCTL_GET_QP_RANGE \
@@ -352,16 +451,76 @@ struct venc_ioctl_msg{
 	_IOW(VEN_IOCTLBASE_ENC, 47, struct venc_ioctl_msg)
 
 
+/*IOCTL params:SET: InputData - unsigned int, OutputData - NULL.*/
 #define VEN_IOCTL_SET_EXTRADATA \
 	_IOW(VEN_IOCTLBASE_ENC, 48, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - unsigned int.*/
 #define VEN_IOCTL_GET_EXTRADATA \
 	_IOR(VEN_IOCTLBASE_ENC, 49, struct venc_ioctl_msg)
 
+/*IOCTL params:SET: InputData - NULL, OutputData - NULL.*/
 #define VEN_IOCTL_SET_SLICE_DELIVERY_MODE \
 	_IO(VEN_IOCTLBASE_ENC, 50)
 
-#define VEN_IOCTL_SET_PERF_CLK \
-    _IOR(VEN_IOCTLBASE_ENC, 51, struct venc_ioctl_msg)
+/*IOCTL params:SET: InputData - unsigned int, OutputData - NULL*/
+#define VEN_IOCTL_SET_SPS_PPS_FOR_IDR \
+	_IOW(VEN_IOCTLBASE_ENC, 51, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - NULL, OutputData - NULL.*/
+#define VEN_IOCTL_SET_VUI_BITSTREAM_RESTRICT_FLAG \
+	_IO(VEN_IOCTLBASE_ENC, 52)
+
+/*IOCTL params:GET: InputData - NULL, OutputData - unsigned int.*/
+#define VEN_IOCTL_GET_PERF_LEVEL \
+	_IOR(VEN_IOCTLBASE_ENC, 53, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_range, OutputData - NULL.*/
+#define VEN_IOCTL_SET_CAPABILITY_LTRCOUNT \
+	_IOW(VEN_IOCTLBASE_ENC, 54, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_range.*/
+#define VEN_IOCTL_GET_CAPABILITY_LTRCOUNT \
+	_IOR(VEN_IOCTLBASE_ENC, 55, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_ltrmode, OutputData - NULL.*/
+#define VEN_IOCTL_SET_LTRMODE \
+	_IOW(VEN_IOCTLBASE_ENC, 56, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_ltrmode.*/
+#define VEN_IOCTL_GET_LTRMODE \
+	_IOR(VEN_IOCTLBASE_ENC, 57, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_ltrcount, OutputData - NULL.*/
+#define VEN_IOCTL_SET_LTRCOUNT \
+	_IOW(VEN_IOCTLBASE_ENC, 58, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_ltrcount.*/
+#define VEN_IOCTL_GET_LTRCOUNT \
+	_IOR(VEN_IOCTLBASE_ENC, 59, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_ltrperiod, OutputData - NULL.*/
+#define VEN_IOCTL_SET_LTRPERIOD \
+	_IOW(VEN_IOCTLBASE_ENC, 60, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_ltrperiod.*/
+#define VEN_IOCTL_GET_LTRPERIOD \
+	_IOR(VEN_IOCTLBASE_ENC, 61, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_ltruse, OutputData - NULL.*/
+#define VEN_IOCTL_SET_LTRUSE \
+	_IOW(VEN_IOCTLBASE_ENC, 62, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_ltruse.*/
+#define VEN_IOCTL_GET_LTRUSE \
+	_IOR(VEN_IOCTLBASE_ENC, 63, struct venc_ioctl_msg)
+
+/*IOCTL params:SET: InputData - venc_ltrmark, OutputData - NULL.*/
+#define VEN_IOCTL_SET_LTRMARK \
+	_IOW(VEN_IOCTLBASE_ENC, 64, struct venc_ioctl_msg)
+/*IOCTL params:GET: InputData - NULL, OutputData - venc_ltrmark.*/
+#define VEN_IOCTL_GET_LTRMARK \
+	_IOR(VEN_IOCTLBASE_ENC, 65, struct venc_ioctl_msg)
+
+struct venc_range {
+	unsigned long        max;
+	unsigned long        min;
+	unsigned long        step_size;
+};
 
 struct venc_switch{
 	unsigned char	status;
@@ -394,6 +553,9 @@ struct venc_buffer{
  long long	timestamp;
  unsigned long	flags;
  void	*clientdata;
+	unsigned long	metadata_len;
+	unsigned long	metadata_offset;
+	unsigned long	metadata_ltrid;
 };
 
 struct venc_basecfg{
@@ -445,7 +607,7 @@ struct venc_capability{
 };
 
 struct venc_entropycfg{
-	unsigned longentropysel;
+	unsigned long	entropysel;
 	unsigned long	cabacmodel;
 };
 
@@ -519,4 +681,21 @@ struct venc_recon_buff_size{
 	int alignment;
 };
 
-#endif 
+struct venc_ltrmode {
+	unsigned long ltr_mode;
+};
+
+struct venc_ltrcount {
+	unsigned long ltr_count;
+};
+
+struct venc_ltrperiod {
+	unsigned long ltr_period;
+};
+
+struct venc_ltruse {
+	unsigned long ltr_id;
+	unsigned long ltr_frames;
+};
+
+#endif /* _MSM_VIDC_ENC_H_ */
diff --git a/include/media/msm/vcd_api.h b/include/media/msm/vcd_api.h
index e9ee050..a6ceb4d 100644
--- a/include/media/msm/vcd_api.h
+++ b/include/media/msm/vcd_api.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -66,7 +66,7 @@ struct vcd_frame_data {
 	u32 alloc_len;
 	u32 data_len;
 	u32 offset;
-	s64 time_stamp; 
+	s64 time_stamp; /* in usecs*/
 	u32 flags;
 	u32 frm_clnt_data;
 	struct vcd_property_dec_output_buffer dec_op_prop;
@@ -78,6 +78,9 @@ struct vcd_frame_data {
 	u32 desc_size;
 	struct ion_handle *buff_ion_handle;
 	struct vcd_aspect_ratio aspect_ratio_info;
+	u32 metadata_len;
+	u32 metadata_offset;
+	u32 curr_ltr_id;
 };
 
 struct vcd_sequence_hdr {
@@ -100,6 +103,7 @@ struct vcd_buffer_requirement {
 	size_t sz;
 	u32 align;
 	u32 buf_pool_id;
+	size_t meta_buffer_size;
 };
 
 struct vcd_init_config {
@@ -116,6 +120,7 @@ struct vcd_init_config {
 	void (*timer_stop) (void *timer_handle);
 };
 
+/*Flags passed to vcd_open*/
 #define VCD_CP_SESSION 0x00000001
 
 u32 vcd_init(struct vcd_init_config *config, s32 *driver_handle);
diff --git a/include/media/msm/vcd_property.h b/include/media/msm/vcd_property.h
index ff0da1b..d579ff7 100644
--- a/include/media/msm/vcd_property.h
+++ b/include/media/msm/vcd_property.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -57,6 +57,18 @@
 #define VCD_I_SET_TURBO_CLK (VCD_START_BASE + 0x29)
 #define VCD_I_ENABLE_DELIMITER_FLAG (VCD_START_BASE + 0x2A)
 #define VCD_I_ENABLE_VUI_TIMING_INFO (VCD_START_BASE + 0x2B)
+#define VCD_I_SET_EXT_METABUFFER (VCD_START_BASE + 0x2C)
+#define VCD_I_FREE_EXT_METABUFFER (VCD_START_BASE + 0x2D)
+#define VCD_I_ENABLE_SEC_METADATA (VCD_START_BASE + 0x2E)
+#define VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG (VCD_START_BASE + 0x2F)
+#define VCD_I_GET_CURR_PERF_LEVEL (VCD_START_BASE + 0x30)
+#define VCD_I_LTR_MODE (VCD_START_BASE + 0x31)
+#define VCD_I_LTR_COUNT (VCD_START_BASE + 0x32)
+#define VCD_I_LTR_PERIOD (VCD_START_BASE + 0x33)
+#define VCD_I_LTR_USE (VCD_START_BASE + 0x34)
+#define VCD_I_CAPABILITY_LTR_COUNT (VCD_START_BASE + 0x35)
+#define VCD_I_LTR_MARK (VCD_START_BASE + 0x36)
+
 
 #define VCD_START_REQ      (VCD_START_BASE + 0x1000)
 #define VCD_I_REQ_IFRAME   (VCD_START_REQ + 0x1)
@@ -114,9 +126,11 @@ enum vcd_perf_level {
 #define VCD_METADATA_VC1            0x040
 #define VCD_METADATA_PASSTHROUGH    0x080
 #define VCD_METADATA_ENC_SLICE      0x100
+#define VCD_METADATA_LTR_INFO       0x200
 
 #define VCD_METADATA_EXT_DATA       0x0800
 #define VCD_METADATA_USER_DATA      0x1000
+#define VCD_METADATA_SEPARATE_BUF   0x2000
 
 struct vcd_property_meta_data_enable {
 	u32 meta_data_enable_flag;
@@ -146,7 +160,8 @@ enum vcd_yuv_buffer_format {
 	VCD_BUFFER_FORMAT_NV12      = 0x1,
 	VCD_BUFFER_FORMAT_TILE_4x2    = 0x2,
 	VCD_BUFFER_FORMAT_NV12_16M2KA = 0x3,
-	VCD_BUFFER_FORMAT_TILE_1x1    = 0x4
+	VCD_BUFFER_FORMAT_TILE_1x1    = 0x4,
+	VCD_BUFFER_FORMAT_NV21_16M2KA = 0x5
 };
 
 struct vcd_property_buffer_format {
@@ -309,7 +324,7 @@ struct vcd_property_vop_timing {
 };
 
 struct vcd_property_vop_timing_constant_delta {
-	u32 constant_delta; 
+	u32 constant_delta; /*In usecs */
 };
 
 struct vcd_property_short_header {
@@ -383,4 +398,54 @@ struct vcd_property_vui_timing_info_enable {
 	u32 vui_timing_info;
 };
 
+struct vcd_property_meta_buffer {
+	u8 *kernel_virtual_addr;
+	u8 *physical_addr;
+	u32 size;
+	u32 count;
+	int pmem_fd;
+	u32 offset;
+	u8 *dev_addr;
+	void *client_data;
+	u8 *kernel_virt_addr_iommu;
+	u8 *physical_addr_iommu;
+	int pmem_fd_iommu;
+	u8 *dev_addr_iommu;
+	void *client_data_iommu;
+};
+
+struct vcd_property_bitstream_restrict_enable {
+	u32 bitstream_restrict_enable_flag;
+};
+
+struct vcd_property_range_type {
+	u32 min;
+	u32 max;
+	u32 step_size;
+};
+
+enum vcd_property_ltrmode {
+	VCD_LTR_MODE_DISABLE = 0,
+	VCD_LTR_MODE_MANUAL = 1,
+	VCD_LTR_MODE_AUTO = 2,
+	VCD_LTR_MODE_MAX = 0x7fffffff
+};
+
+struct vcd_property_ltrmode_type {
+	enum vcd_property_ltrmode ltr_mode;
+};
+
+struct vcd_property_ltrcount_type {
+	u32 ltr_count;
+};
+
+struct vcd_property_ltrperiod_type {
+	u32 ltr_period;
+};
+
+struct vcd_property_ltruse_type {
+	u32 ltr_id;
+	u32 ltr_frames;
+};
+
 #endif
diff --git a/include/media/msm/vcd_status.h b/include/media/msm/vcd_status.h
index 7e8ec0b..f8270c2 100644
--- a/include/media/msm/vcd_status.h
+++ b/include/media/msm/vcd_status.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -33,6 +33,7 @@
 #define VCD_EVT_IND_RESOURCES_LOST        (VCD_EVT_IND_BASE + 0x4)
 #define VCD_EVT_IND_INFO_OUTPUT_RECONFIG  (VCD_EVT_IND_BASE + 0x5)
 #define VCD_EVT_IND_INFO_FIELD_DROPPED    (VCD_EVT_IND_BASE + 0x6)
+#define VCD_EVT_IND_INFO_LTRUSE_FAILED    (VCD_EVT_IND_BASE + 0x7)
 
 #define VCD_S_SUCCESS           0x0
 
diff --git a/include/media/msm/vidc_init.h b/include/media/msm/vidc_init.h
index c681213..b945d8f 100644
--- a/include/media/msm/vidc_init.h
+++ b/include/media/msm/vidc_init.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,12 +13,13 @@
 
 #ifndef VIDC_INIT_H
 #define VIDC_INIT_H
-#include <linux/ion.h>
+#include <linux/msm_ion.h>
 #include <media/msm/vidc_type.h>
 #include <media/msm/vcd_property.h>
 
 #define VIDC_MAX_NUM_CLIENTS 4
 #define MAX_VIDEO_NUM_OF_BUFF 100
+#define MAX_META_BUFFERS 32
 
 enum buffer_dir {
 	BUFFER_TYPE_INPUT,
@@ -30,6 +31,7 @@ struct buf_addr_table {
 	unsigned long kernel_vaddr;
 	unsigned long phy_addr;
 	unsigned long buff_ion_flag;
+	unsigned long buff_len;
 	struct ion_handle *buff_ion_handle;
 	int pmem_fd;
 	struct file *file;
@@ -37,6 +39,11 @@ struct buf_addr_table {
 	void *client_data;
 };
 
+struct meta_buffer_addr_table {
+	u8 *kernel_vir_addr;
+	u8 *kernel_vir_addr_iommu;
+};
+
 struct video_client_ctx {
 	void *vcd_handle;
 	u32 num_of_input_buffers;
@@ -49,17 +56,22 @@ struct video_client_ctx {
 	wait_queue_head_t msg_wait;
 	struct completion event;
 	struct vcd_property_h264_mv_buffer vcd_h264_mv_buffer;
+	struct vcd_property_meta_buffer vcd_meta_buffer;
 	struct vcd_property_enc_recon_buffer recon_buffer[4];
 	u32 event_status;
 	u32 seq_header_set;
 	u32 stop_msg;
 	u32 stop_called;
 	u32 stop_sync_cb;
+	size_t meta_buf_size;
 	struct ion_client *user_ion_client;
 	struct ion_handle *seq_hdr_ion_handle;
 	struct ion_handle *h264_mv_ion_handle;
 	struct ion_handle *recon_buffer_ion_handle[4];
+	struct ion_handle *meta_buffer_ion_handle;
+	struct ion_handle *meta_buffer_iommu_ion_handle;
 	u32 dmx_disable;
+	struct meta_buffer_addr_table meta_addr_table[MAX_META_BUFFERS];
 };
 
 void __iomem *vidc_get_ioaddr(void);
diff --git a/include/media/msm/vidc_type.h b/include/media/msm/vidc_type.h
index d4db0a0..04d28b2 100644
--- a/include/media/msm/vidc_type.h
+++ b/include/media/msm/vidc_type.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 6c6ce4a..46bf2ed 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -44,8 +44,15 @@
 int sysctl_oom_dump_tasks = 1;
 static DEFINE_SPINLOCK(zone_scan_lock);
 
-extern void show_meminfo(void);
-
+/*
+ * compare_swap_oom_score_adj() - compare and swap current's oom_score_adj
+ * @old_val: old oom_score_adj for compare
+ * @new_val: new oom_score_adj for swap
+ *
+ * Sets the oom_score_adj value for current to @new_val iff its present value is
+ * @old_val.  Usually used to reinstate a previous value to prevent racing with
+ * userspacing tuning the value in the interim.
+ */
 void compare_swap_oom_score_adj(int old_val, int new_val)
 {
 	struct sighand_struct *sighand = current->sighand;
@@ -57,6 +64,14 @@ void compare_swap_oom_score_adj(int old_val, int new_val)
 	spin_unlock_irq(&sighand->siglock);
 }
 
+/**
+ * test_set_oom_score_adj() - set current's oom_score_adj and return old value
+ * @new_val: new oom_score_adj value
+ *
+ * Sets the oom_score_adj value for current to @new_val with proper
+ * synchronization and returns the old value.  Usually used to temporarily
+ * set a value, save the old value in the caller, and then reinstate it later.
+ */
 int test_set_oom_score_adj(int new_val)
 {
 	struct sighand_struct *sighand = current->sighand;
@@ -72,6 +87,15 @@ int test_set_oom_score_adj(int new_val)
 }
 
 #ifdef CONFIG_NUMA
+/**
+ * has_intersects_mems_allowed() - check task eligiblity for kill
+ * @tsk: task struct of which task to consider
+ * @mask: nodemask passed to page allocator for mempolicy ooms
+ *
+ * Task eligibility is determined by whether or not a candidate task, @tsk,
+ * shares the same mempolicy nodes as current if it is bound by such a policy
+ * and whether or not it has the same set of allowed cpuset nodes.
+ */
 static bool has_intersects_mems_allowed(struct task_struct *tsk,
 					const nodemask_t *mask)
 {
@@ -79,9 +103,19 @@ static bool has_intersects_mems_allowed(struct task_struct *tsk,
 
 	do {
 		if (mask) {
+			/*
+			 * If this is a mempolicy constrained oom, tsk's
+			 * cpuset is irrelevant.  Only return true if its
+			 * mempolicy intersects current, otherwise it may be
+			 * needlessly killed.
+			 */
 			if (mempolicy_nodemask_intersects(tsk, mask))
 				return true;
 		} else {
+			/*
+			 * This is not a mempolicy constrained oom, so only
+			 * check the mems of tsk's cpuset.
+			 */
 			if (cpuset_mems_allowed_intersects(current, tsk))
 				return true;
 		}
@@ -95,8 +129,14 @@ static bool has_intersects_mems_allowed(struct task_struct *tsk,
 {
 	return true;
 }
-#endif 
+#endif /* CONFIG_NUMA */
 
+/*
+ * The process p may have detached its own ->mm while exiting or through
+ * use_mm(), but one or more of its subthreads may still have a valid
+ * pointer.  Return p, or any of its subthreads with a valid ->mm, with
+ * task_lock() held.
+ */
 struct task_struct *find_lock_task_mm(struct task_struct *p)
 {
 	struct task_struct *t = p;
@@ -111,6 +151,7 @@ struct task_struct *find_lock_task_mm(struct task_struct *p)
 	return NULL;
 }
 
+/* return true if the task is not adequate as candidate victim task. */
 static bool oom_unkillable_task(struct task_struct *p,
 		const struct mem_cgroup *memcg, const nodemask_t *nodemask)
 {
@@ -119,17 +160,26 @@ static bool oom_unkillable_task(struct task_struct *p,
 	if (p->flags & PF_KTHREAD)
 		return true;
 
-	
+	/* When mem_cgroup_out_of_memory() and p is not member of the group */
 	if (memcg && !task_in_mem_cgroup(p, memcg))
 		return true;
 
-	
+	/* p may not have freeable memory in nodemask */
 	if (!has_intersects_mems_allowed(p, nodemask))
 		return true;
 
 	return false;
 }
 
+/**
+ * oom_badness - heuristic function to determine which candidate task to kill
+ * @p: task struct of which task we should calculate
+ * @totalpages: total present RAM allowed for page allocation
+ *
+ * The heuristic for determining which task to kill is made to be as simple and
+ * predictable as possible.  The goal is to return the highest value for the
+ * task consuming the most memory to avoid subsequent oom failures.
+ */
 unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
 		      const nodemask_t *nodemask, unsigned long totalpages)
 {
@@ -147,9 +197,17 @@ unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
 		return 0;
 	}
 
+	/*
+	 * The memory controller may have a limit of 0 bytes, so avoid a divide
+	 * by zero, if necessary.
+	 */
 	if (!totalpages)
 		totalpages = 1;
 
+	/*
+	 * The baseline for the badness score is the proportion of RAM that each
+	 * task's rss, pagetable and swap space use.
+	 */
 	points = get_mm_rss(p->mm) + p->mm->nr_ptes;
 	points += get_mm_counter(p->mm, MM_SWAPENTS);
 
@@ -157,16 +215,33 @@ unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
 	points /= totalpages;
 	task_unlock(p);
 
+	/*
+	 * Root processes get 3% bonus, just like the __vm_enough_memory()
+	 * implementation used by LSMs.
+	 */
 	if (has_capability_noaudit(p, CAP_SYS_ADMIN))
 		points -= 30;
 
+	/*
+	 * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may
+	 * either completely disable oom killing or always prefer a certain
+	 * task.
+	 */
 	points += p->signal->oom_score_adj;
 
+	/*
+	 * Never return 0 for an eligible task that may be killed since it's
+	 * possible that no single user task uses more than 0.1% of memory and
+	 * no single admin tasks uses more than 3.0%.
+	 */
 	if (points <= 0)
 		return 1;
 	return (points < 1000) ? points : 1000;
 }
 
+/*
+ * Determine the type of allocation constraint.
+ */
 #ifdef CONFIG_NUMA
 static enum oom_constraint constrained_alloc(struct zonelist *zonelist,
 				gfp_t gfp_mask, nodemask_t *nodemask,
@@ -178,14 +253,24 @@ static enum oom_constraint constrained_alloc(struct zonelist *zonelist,
 	bool cpuset_limited = false;
 	int nid;
 
-	
+	/* Default to all available memory */
 	*totalpages = totalram_pages + total_swap_pages;
 
 	if (!zonelist)
 		return CONSTRAINT_NONE;
+	/*
+	 * Reach here only when __GFP_NOFAIL is used. So, we should avoid
+	 * to kill current.We have to random task kill in this case.
+	 * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.
+	 */
 	if (gfp_mask & __GFP_THISNODE)
 		return CONSTRAINT_NONE;
 
+	/*
+	 * This is not a __GFP_THISNODE allocation, so a truncated nodemask in
+	 * the page allocator means a mempolicy is in effect.  Cpuset policy
+	 * is enforced in get_page_from_freelist().
+	 */
 	if (nodemask && !nodes_subset(node_states[N_HIGH_MEMORY], *nodemask)) {
 		*totalpages = total_swap_pages;
 		for_each_node_mask(nid, *nodemask)
@@ -193,7 +278,7 @@ static enum oom_constraint constrained_alloc(struct zonelist *zonelist,
 		return CONSTRAINT_MEMORY_POLICY;
 	}
 
-	
+	/* Check this allocation failure is caused by cpuset's wall function */
 	for_each_zone_zonelist_nodemask(zone, z, zonelist,
 			high_zoneidx, nodemask)
 		if (!cpuset_zone_allowed_softwall(zone, gfp_mask))
@@ -217,6 +302,12 @@ static enum oom_constraint constrained_alloc(struct zonelist *zonelist,
 }
 #endif
 
+/*
+ * Simple selection loop. We chose the process with the highest
+ * number of 'points'. We expect the caller will lock the tasklist.
+ *
+ * (not docbooked, we don't want this one cluttering up the manual)
+ */
 static struct task_struct *select_bad_process(unsigned int *ppoints,
 		unsigned long totalpages, struct mem_cgroup *memcg,
 		const nodemask_t *nodemask, bool force_kill)
@@ -233,6 +324,15 @@ static struct task_struct *select_bad_process(unsigned int *ppoints,
 		if (oom_unkillable_task(p, memcg, nodemask))
 			continue;
 
+		/*
+		 * This task already has access to memory reserves and is
+		 * being killed. Don't allow any other task access to the
+		 * memory reserve.
+		 *
+		 * Note: this may have a chance of deadlock if it gets
+		 * blocked waiting for another task which itself is waiting
+		 * for memory. Is there a better alternative?
+		 */
 		if (test_tsk_thread_flag(p, TIF_MEMDIE)) {
 			if (unlikely(frozen(p)))
 				__thaw_task(p);
@@ -243,10 +343,24 @@ static struct task_struct *select_bad_process(unsigned int *ppoints,
 			continue;
 
 		if (p->flags & PF_EXITING) {
+			/*
+			 * If p is the current task and is in the process of
+			 * releasing memory, we allow the "kill" to set
+			 * TIF_MEMDIE, which will allow it to gain access to
+			 * memory reserves.  Otherwise, it may stall forever.
+			 *
+			 * The loop isn't broken here, however, in case other
+			 * threads are found to have already been oom killed.
+			 */
 			if (p == current) {
 				chosen = p;
 				*ppoints = 1000;
 			} else if (!force_kill) {
+				/*
+				 * If this task is not being ptraced on exit,
+				 * then wait for it to finish before killing
+				 * some other task unnecessarily.
+				 */
 				if (!(p->group_leader->ptrace & PT_TRACE_EXIT))
 					return ERR_PTR(-1UL);
 			}
@@ -262,6 +376,19 @@ static struct task_struct *select_bad_process(unsigned int *ppoints,
 	return chosen;
 }
 
+/**
+ * dump_tasks - dump current memory state of all system tasks
+ * @mem: current's memory controller, if constrained
+ * @nodemask: nodemask passed to page allocator for mempolicy ooms
+ *
+ * Dumps the current memory state of all eligible tasks.  Tasks not in the same
+ * memcg, not in the same cpuset, or bound to a disjoint set of mempolicy nodes
+ * are not shown.
+ * State information includes task's pid, uid, tgid, vm size, rss, cpu, oom_adj
+ * value, oom_score_adj value, and name.
+ *
+ * Call with tasklist_lock read-locked.
+ */
 static void dump_tasks(const struct mem_cgroup *memcg, const nodemask_t *nodemask)
 {
 	struct task_struct *p;
@@ -274,6 +401,11 @@ static void dump_tasks(const struct mem_cgroup *memcg, const nodemask_t *nodemas
 
 		task = find_lock_task_mm(p);
 		if (!task) {
+			/*
+			 * This is a kthread or all of p's threads have already
+			 * detached their mm's.  There's no need to report
+			 * them; they can't be oom killed anyway.
+			 */
 			continue;
 		}
 
@@ -297,7 +429,6 @@ static void dump_header(struct task_struct *p, gfp_t gfp_mask, int order,
 	cpuset_print_task_mems_allowed(current);
 	task_unlock(current);
 	dump_stack();
-	show_meminfo();
 	mem_cgroup_print_oom_info(memcg, p);
 	show_mem(SHOW_MEM_FILTER_NODES);
 	if (sysctl_oom_dump_tasks)
@@ -318,6 +449,10 @@ static void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 	static DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,
 					      DEFAULT_RATELIMIT_BURST);
 
+	/*
+	 * If the task is already exiting, don't alarm the sysadmin or kill
+	 * its children or threads, just set TIF_MEMDIE so it can die quickly
+	 */
 	if (p->flags & PF_EXITING) {
 		set_tsk_thread_flag(p, TIF_MEMDIE);
 		return;
@@ -331,12 +466,21 @@ static void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		message, task_pid_nr(p), p->comm, points);
 	task_unlock(p);
 
+	/*
+	 * If any of p's children has a different mm and is eligible for kill,
+	 * the one with the highest oom_badness() score is sacrificed for its
+	 * parent.  This attempts to lose the minimal amount of work done while
+	 * still freeing memory.
+	 */
 	do {
 		list_for_each_entry(child, &t->children, sibling) {
 			unsigned int child_points;
 
 			if (child->mm == p->mm)
 				continue;
+			/*
+			 * oom_badness() returns 0 if the thread is unkillable
+			 */
 			child_points = oom_badness(child, memcg, nodemask,
 								totalpages);
 			if (child_points > victim_points) {
@@ -350,7 +494,7 @@ static void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 	if (!victim)
 		return;
 
-	
+	/* mm cannot safely be dereferenced after task_unlock(victim) */
 	mm = victim->mm;
 	pr_err("Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB\n",
 		task_pid_nr(victim), victim->comm, K(victim->mm->total_vm),
@@ -358,13 +502,22 @@ static void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		K(get_mm_counter(victim->mm, MM_FILEPAGES)));
 	task_unlock(victim);
 
+	/*
+	 * Kill all user processes sharing victim->mm in other thread groups, if
+	 * any.  They don't get access to memory reserves, though, to avoid
+	 * depletion of all memory.  This prevents mm->mmap_sem livelock when an
+	 * oom killed thread cannot exit because it requires the semaphore and
+	 * its contended by another thread trying to allocate memory itself.
+	 * That thread will now get access to memory reserves since it has a
+	 * pending fatal signal.
+	 */
 	for_each_process(p)
 		if (p->mm == mm && !same_thread_group(p, victim) &&
 		    !(p->flags & PF_KTHREAD)) {
 			if (p->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)
 				continue;
 
-			task_lock(p);	
+			task_lock(p);	/* Protect ->comm from prctl() */
 			pr_err("Kill process %d (%s) sharing same memory\n",
 				task_pid_nr(p), p->comm);
 			task_unlock(p);
@@ -376,12 +529,20 @@ static void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 }
 #undef K
 
+/*
+ * Determines whether the kernel must panic because of the panic_on_oom sysctl.
+ */
 static void check_panic_on_oom(enum oom_constraint constraint, gfp_t gfp_mask,
 				int order, const nodemask_t *nodemask)
 {
 	if (likely(!sysctl_panic_on_oom))
 		return;
 	if (sysctl_panic_on_oom != 2) {
+		/*
+		 * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel
+		 * does not panic for cpuset, mempolicy, or memcg allocation
+		 * failures.
+		 */
 		if (constraint != CONSTRAINT_NONE)
 			return;
 	}
@@ -400,6 +561,11 @@ void mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,
 	unsigned int points = 0;
 	struct task_struct *p;
 
+	/*
+	 * If current has a pending SIGKILL, then automatically select it.  The
+	 * goal is to allow it to allocate so that it may quickly exit and free
+	 * its memory.
+	 */
 	if (fatal_signal_pending(current)) {
 		set_thread_flag(TIF_MEMDIE);
 		return;
@@ -430,6 +596,11 @@ int unregister_oom_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL_GPL(unregister_oom_notifier);
 
+/*
+ * Try to acquire the OOM killer lock for the zones in zonelist.  Returns zero
+ * if a parallel OOM killing is already taking place that includes a zone in
+ * the zonelist.  Otherwise, locks all zones in the zonelist and returns 1.
+ */
 int try_set_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)
 {
 	struct zoneref *z;
@@ -445,6 +616,11 @@ int try_set_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)
 	}
 
 	for_each_zone_zonelist(zone, z, zonelist, gfp_zone(gfp_mask)) {
+		/*
+		 * Lock each zone in the zonelist under zone_scan_lock so a
+		 * parallel invocation of try_set_zonelist_oom() doesn't succeed
+		 * when it shouldn't.
+		 */
 		zone_set_flag(zone, ZONE_OOM_LOCKED);
 	}
 
@@ -453,6 +629,11 @@ int try_set_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)
 	return ret;
 }
 
+/*
+ * Clears the ZONE_OOM_LOCKED flag for all zones in the zonelist so that failed
+ * allocation attempts with zonelists containing them may now recall the OOM
+ * killer, if necessary.
+ */
 void clear_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)
 {
 	struct zoneref *z;
@@ -465,6 +646,11 @@ void clear_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)
 	spin_unlock(&zone_scan_lock);
 }
 
+/*
+ * Try to acquire the oom killer lock for all system zones.  Returns zero if a
+ * parallel oom killing is taking place, otherwise locks all zones and returns
+ * non-zero.
+ */
 static int try_set_system_oom(void)
 {
 	struct zone *zone;
@@ -483,6 +669,10 @@ static int try_set_system_oom(void)
 	return ret;
 }
 
+/*
+ * Clears ZONE_OOM_LOCKED for all system zones so that failed allocation
+ * attempts or page faults may now recall the oom killer, if necessary.
+ */
 static void clear_system_oom(void)
 {
 	struct zone *zone;
@@ -493,6 +683,19 @@ static void clear_system_oom(void)
 	spin_unlock(&zone_scan_lock);
 }
 
+/**
+ * out_of_memory - kill the "best" process when we run out of memory
+ * @zonelist: zonelist pointer
+ * @gfp_mask: memory allocation flags
+ * @order: amount of memory being requested as a power of 2
+ * @nodemask: nodemask passed to page allocator
+ * @force_kill: true if a task must be killed, even if others are exiting
+ *
+ * If we run out of memory, we have the choice between either
+ * killing a random task (bad), letting the system crash (worse)
+ * OR try to be smart about which process to kill. Note that we
+ * don't have to be perfect here, we just have to be good.
+ */
 void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,
 		int order, nodemask_t *nodemask, bool force_kill)
 {
@@ -506,14 +709,23 @@ void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,
 
 	blocking_notifier_call_chain(&oom_notify_list, 0, &freed);
 	if (freed > 0)
-		
+		/* Got some memory back in the last second. */
 		return;
 
+	/*
+	 * If current has a pending SIGKILL, then automatically select it.  The
+	 * goal is to allow it to allocate so that it may quickly exit and free
+	 * its memory.
+	 */
 	if (fatal_signal_pending(current)) {
 		set_thread_flag(TIF_MEMDIE);
 		return;
 	}
 
+	/*
+	 * Check if there were limitations on the allocation (only relevant for
+	 * NUMA) that may require different handling.
+	 */
 	constraint = constrained_alloc(zonelist, gfp_mask, nodemask,
 						&totalpages);
 	mpol_mask = (constraint == CONSTRAINT_MEMORY_POLICY) ? nodemask : NULL;
@@ -531,7 +743,7 @@ void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,
 
 	p = select_bad_process(&points, totalpages, NULL, mpol_mask,
 			       force_kill);
-	
+	/* Found nothing?!?! Either we hang forever, or we panic. */
 	if (!p) {
 		dump_header(NULL, gfp_mask, order, NULL, mpol_mask);
 		read_unlock(&tasklist_lock);
@@ -545,10 +757,20 @@ void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,
 out:
 	read_unlock(&tasklist_lock);
 
+	/*
+	 * Give "p" a good chance of killing itself before we
+	 * retry to allocate memory unless "p" is current
+	 */
 	if (killed && !test_thread_flag(TIF_MEMDIE))
 		schedule_timeout_uninterruptible(1);
 }
 
+/*
+ * The pagefault handler calls here because it is out of memory, so kill a
+ * memory-hogging task.  If a populated zone has ZONE_OOM_LOCKED set, a parallel
+ * oom killing is already in progress so do nothing.  If a task is found with
+ * TIF_MEMDIE set, it has been killed so do nothing and allow it to exit.
+ */
 void pagefault_out_of_memory(void)
 {
 	if (try_set_system_oom()) {
diff --git a/sound/soc/msm/qdsp6/q6asm.c b/sound/soc/msm/qdsp6/q6asm.c
index 97ffc6e..8a854df 100644
--- a/sound/soc/msm/qdsp6/q6asm.c
+++ b/sound/soc/msm/qdsp6/q6asm.c
@@ -38,7 +38,7 @@
 #include <mach/peripheral-loader.h>
 #include <mach/qdsp6v2/audio_acdb.h>
 #include <mach/qdsp6v2/rtac.h>
-
+#include <linux/msm_ion.h>
 #include <sound/apr_audio.h>
 #include <sound/q6asm.h>
 
@@ -536,7 +536,7 @@ int q6asm_audio_client_buf_alloc(unsigned int dir,
 					}
 					buf[cnt].handle = ion_alloc
 						(buf[cnt].client, bufsz, SZ_4K,
-						(0x1 << ION_AUDIO_HEAP_ID));
+						(0x1 << ION_AUDIO_HEAP_ID), 0);
 					if (IS_ERR_OR_NULL((void *)
 						buf[cnt].handle)) {
 						pr_err("%s: ION memory allocation for AUDIO failed\n",
@@ -558,8 +558,7 @@ int q6asm_audio_client_buf_alloc(unsigned int dir,
 					}
 
 					buf[cnt].data = ion_map_kernel
-					(buf[cnt].client, buf[cnt].handle,
-							 0);
+                                          (buf[cnt].client, buf[cnt].handle);
 					if (IS_ERR_OR_NULL((void *)
 						buf[cnt].data)) {
 						pr_err("%s: ION memory mapping for AUDIO failed\n",
@@ -672,7 +671,7 @@ int q6asm_audio_client_buf_alloc_contiguous(unsigned int dir,
 		goto fail;
 	}
 	buf[0].handle = ion_alloc(buf[0].client, bufsz * bufcnt, SZ_4K,
-				  (0x1 << ION_AUDIO_HEAP_ID));
+				  (0x1 << ION_AUDIO_HEAP_ID), 0);
 	if (IS_ERR_OR_NULL((void *) buf[0].handle)) {
 		pr_err("%s: ION memory allocation for AUDIO failed\n",
 			__func__);
@@ -689,7 +688,7 @@ int q6asm_audio_client_buf_alloc_contiguous(unsigned int dir,
 		goto fail;
 	}
 
-	buf[0].data = ion_map_kernel(buf[0].client, buf[0].handle, 0);
+	buf[0].data = ion_map_kernel(buf[0].client, buf[0].handle);
 	if (IS_ERR_OR_NULL((void *) buf[0].data)) {
 		pr_err("%s: ION memory mapping for AUDIO failed\n", __func__);
 		mutex_unlock(&ac->cmd_lock);
-- 
1.8.4

